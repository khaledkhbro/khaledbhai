"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_screenshot-pricing_ts"],{

/***/ "(app-pages-browser)/./lib/screenshot-pricing.ts":
/*!***********************************!*\
  !*** ./lib/screenshot-pricing.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateScreenshotCosts: () => (/* binding */ calculateScreenshotCosts),\n/* harmony export */   getScreenshotPricingSettings: () => (/* binding */ getScreenshotPricingSettings),\n/* harmony export */   getScreenshotPricingTiers: () => (/* binding */ getScreenshotPricingTiers),\n/* harmony export */   updateScreenshotPricingSetting: () => (/* binding */ updateScreenshotPricingSetting),\n/* harmony export */   updateScreenshotPricingTier: () => (/* binding */ updateScreenshotPricingTier)\n/* harmony export */ });\n// Screenshot pricing management functions - localStorage based\n// localStorage keys\nconst STORAGE_KEYS = {\n    SETTINGS: \"screenshot_pricing_settings\",\n    TIERS: \"screenshot_pricing_tiers\"\n};\n// Default settings\nconst DEFAULT_SETTINGS = {\n    max_screenshots_allowed: 5,\n    default_screenshot_fee: 0.05,\n    enable_percentage_pricing: true,\n    platform_screenshot_fee: 0\n};\n// Default tiers\nconst DEFAULT_TIERS = [\n    {\n        id: 1,\n        screenshot_number: 1,\n        percentage_fee: 0,\n        is_free: true,\n        is_active: true\n    },\n    {\n        id: 2,\n        screenshot_number: 2,\n        percentage_fee: 3,\n        is_free: false,\n        is_active: true\n    },\n    {\n        id: 3,\n        screenshot_number: 3,\n        percentage_fee: 3,\n        is_free: false,\n        is_active: true\n    },\n    {\n        id: 4,\n        screenshot_number: 4,\n        percentage_fee: 5,\n        is_free: false,\n        is_active: true\n    },\n    {\n        id: 5,\n        screenshot_number: 5,\n        percentage_fee: 5,\n        is_free: false,\n        is_active: true\n    }\n];\n// Initialize default data if not exists\nfunction initializeDefaultData() {\n    if (false) {}\n    if (!localStorage.getItem(STORAGE_KEYS.SETTINGS)) {\n        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(DEFAULT_SETTINGS));\n    }\n    if (!localStorage.getItem(STORAGE_KEYS.TIERS)) {\n        localStorage.setItem(STORAGE_KEYS.TIERS, JSON.stringify(DEFAULT_TIERS));\n    }\n}\n// Get screenshot pricing tiers from localStorage\nasync function getScreenshotPricingTiers() {\n    try {\n        if (false) {}\n        initializeDefaultData();\n        const stored = localStorage.getItem(STORAGE_KEYS.TIERS);\n        if (stored) {\n            const tiers = JSON.parse(stored);\n            return tiers.filter((tier)=>tier.is_active).sort((a, b)=>a.screenshot_number - b.screenshot_number);\n        }\n        return DEFAULT_TIERS;\n    } catch (error) {\n        console.error(\"Error in getScreenshotPricingTiers:\", error);\n        return DEFAULT_TIERS;\n    }\n}\n// Get screenshot pricing settings from localStorage\nasync function getScreenshotPricingSettings() {\n    try {\n        if (false) {}\n        initializeDefaultData();\n        const stored = localStorage.getItem(STORAGE_KEYS.SETTINGS);\n        if (stored) {\n            return JSON.parse(stored);\n        }\n        return DEFAULT_SETTINGS;\n    } catch (error) {\n        console.error(\"Error in getScreenshotPricingSettings:\", error);\n        return DEFAULT_SETTINGS;\n    }\n}\n// Calculate screenshot costs based on job cost and screenshot count\nasync function calculateScreenshotCosts(screenshotCount, totalJobCost) {\n    try {\n        const [tiers, settings] = await Promise.all([\n            getScreenshotPricingTiers(),\n            getScreenshotPricingSettings()\n        ]);\n        const screenshotCosts = [];\n        let totalScreenshotCost = 0;\n        for(let i = 1; i <= Math.min(screenshotCount, settings.max_screenshots_allowed); i++){\n            const tier = tiers.find((t)=>t.screenshot_number === i);\n            if (tier) {\n                const isFree = tier.is_free;\n                const percentage = tier.percentage_fee;\n                const cost = isFree ? 0 : totalJobCost * percentage / 100;\n                screenshotCosts.push({\n                    screenshotNumber: i,\n                    cost,\n                    percentage,\n                    isFree\n                });\n                totalScreenshotCost += cost;\n            } else {\n                // Fallback to default pricing if tier not found\n                const cost = settings.enable_percentage_pricing ? 0 : settings.default_screenshot_fee;\n                screenshotCosts.push({\n                    screenshotNumber: i,\n                    cost,\n                    percentage: 0,\n                    isFree: false\n                });\n                totalScreenshotCost += cost;\n            }\n        }\n        // Generate breakdown text\n        const breakdown = screenshotCosts.map((sc)=>{\n            if (sc.isFree) {\n                return \"Screenshot \".concat(sc.screenshotNumber, \": Free\");\n            } else if (sc.percentage > 0) {\n                return \"Screenshot \".concat(sc.screenshotNumber, \": \").concat(sc.percentage, \"% ($\").concat(sc.cost.toFixed(2), \")\");\n            } else {\n                return \"Screenshot \".concat(sc.screenshotNumber, \": $\").concat(sc.cost.toFixed(2));\n            }\n        }).join(\", \");\n        return {\n            screenshotCount: Math.min(screenshotCount, settings.max_screenshots_allowed),\n            totalJobCost,\n            screenshotCosts,\n            totalScreenshotCost,\n            breakdown\n        };\n    } catch (error) {\n        console.error(\"Error calculating screenshot costs:\", error);\n        // Fallback calculation\n        const fallbackCost = screenshotCount * 0.05;\n        return {\n            screenshotCount,\n            totalJobCost,\n            screenshotCosts: [],\n            totalScreenshotCost: fallbackCost,\n            breakdown: \"\".concat(screenshotCount, \" screenshots �� $0.05 = $\").concat(fallbackCost.toFixed(2))\n        };\n    }\n}\n// Update screenshot pricing tier (admin function)\nasync function updateScreenshotPricingTier(tierId, updates) {\n    try {\n        if (false) {}\n        const tiers = await getScreenshotPricingTiers();\n        const allTiers = JSON.parse(localStorage.getItem(STORAGE_KEYS.TIERS) || \"[]\");\n        const updatedTiers = allTiers.map((tier)=>tier.id === tierId ? {\n                ...tier,\n                ...updates\n            } : tier);\n        localStorage.setItem(STORAGE_KEYS.TIERS, JSON.stringify(updatedTiers));\n    } catch (error) {\n        console.error(\"Error in updateScreenshotPricingTier:\", error);\n        throw error;\n    }\n}\n// Update screenshot pricing setting (admin function)\nasync function updateScreenshotPricingSetting(settingName, settingValue) {\n    try {\n        if (false) {}\n        const settings = await getScreenshotPricingSettings();\n        const updatedSettings = {\n            ...settings,\n            [settingName]: settingValue\n        };\n        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(updatedSettings));\n    } catch (error) {\n        console.error(\"Error in updateScreenshotPricingSetting:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zY3JlZW5zaG90LXByaWNpbmcudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSwrREFBK0Q7QUE2Qi9ELG9CQUFvQjtBQUNwQixNQUFNQSxlQUFlO0lBQ25CQyxVQUFVO0lBQ1ZDLE9BQU87QUFDVDtBQUVBLG1CQUFtQjtBQUNuQixNQUFNQyxtQkFBOEM7SUFDbERDLHlCQUF5QjtJQUN6QkMsd0JBQXdCO0lBQ3hCQywyQkFBMkI7SUFDM0JDLHlCQUF5QjtBQUMzQjtBQUVBLGdCQUFnQjtBQUNoQixNQUFNQyxnQkFBeUM7SUFDN0M7UUFBRUMsSUFBSTtRQUFHQyxtQkFBbUI7UUFBR0MsZ0JBQWdCO1FBQUdDLFNBQVM7UUFBTUMsV0FBVztJQUFLO0lBQ2pGO1FBQUVKLElBQUk7UUFBR0MsbUJBQW1CO1FBQUdDLGdCQUFnQjtRQUFHQyxTQUFTO1FBQU9DLFdBQVc7SUFBSztJQUNsRjtRQUFFSixJQUFJO1FBQUdDLG1CQUFtQjtRQUFHQyxnQkFBZ0I7UUFBR0MsU0FBUztRQUFPQyxXQUFXO0lBQUs7SUFDbEY7UUFBRUosSUFBSTtRQUFHQyxtQkFBbUI7UUFBR0MsZ0JBQWdCO1FBQUdDLFNBQVM7UUFBT0MsV0FBVztJQUFLO0lBQ2xGO1FBQUVKLElBQUk7UUFBR0MsbUJBQW1CO1FBQUdDLGdCQUFnQjtRQUFHQyxTQUFTO1FBQU9DLFdBQVc7SUFBSztDQUNuRjtBQUVELHdDQUF3QztBQUN4QyxTQUFTQztJQUNQLElBQUksS0FBNkIsRUFBRTtJQUVuQyxJQUFJLENBQUNDLGFBQWFDLE9BQU8sQ0FBQ2hCLGFBQWFDLFFBQVEsR0FBRztRQUNoRGMsYUFBYUUsT0FBTyxDQUFDakIsYUFBYUMsUUFBUSxFQUFFaUIsS0FBS0MsU0FBUyxDQUFDaEI7SUFDN0Q7SUFFQSxJQUFJLENBQUNZLGFBQWFDLE9BQU8sQ0FBQ2hCLGFBQWFFLEtBQUssR0FBRztRQUM3Q2EsYUFBYUUsT0FBTyxDQUFDakIsYUFBYUUsS0FBSyxFQUFFZ0IsS0FB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QixZQUFZLEVBQUVDO1FBQ2pCO1FBRUFoRCxhQUFhRSxPQUFPLENBQUNqQixhQUFhQyxRQUFRLEVBQUVpQixLQUFLQyxTQUFTLENBQUM2QztJQUM3RCxFQUFFLE9BQU9uQyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw0Q0FBNENBO1FBQzFELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9saWIvc2NyZWVuc2hvdC1wcmljaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNjcmVlbnNob3QgcHJpY2luZyBtYW5hZ2VtZW50IGZ1bmN0aW9ucyAtIGxvY2FsU3RvcmFnZSBiYXNlZFxuZXhwb3J0IGludGVyZmFjZSBTY3JlZW5zaG90UHJpY2luZ1RpZXIge1xuICBpZDogbnVtYmVyXG4gIHNjcmVlbnNob3RfbnVtYmVyOiBudW1iZXJcbiAgcGVyY2VudGFnZV9mZWU6IG51bWJlclxuICBpc19mcmVlOiBib29sZWFuXG4gIGlzX2FjdGl2ZTogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcmVlbnNob3RQcmljaW5nU2V0dGluZ3Mge1xuICBtYXhfc2NyZWVuc2hvdHNfYWxsb3dlZDogbnVtYmVyXG4gIGRlZmF1bHRfc2NyZWVuc2hvdF9mZWU6IG51bWJlclxuICBlbmFibGVfcGVyY2VudGFnZV9wcmljaW5nOiBib29sZWFuXG4gIHBsYXRmb3JtX3NjcmVlbnNob3RfZmVlOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY3JlZW5zaG90UHJpY2luZ0NhbGN1bGF0aW9uIHtcbiAgc2NyZWVuc2hvdENvdW50OiBudW1iZXJcbiAgdG90YWxKb2JDb3N0OiBudW1iZXJcbiAgc2NyZWVuc2hvdENvc3RzOiBBcnJheTx7XG4gICAgc2NyZWVuc2hvdE51bWJlcjogbnVtYmVyXG4gICAgY29zdDogbnVtYmVyXG4gICAgcGVyY2VudGFnZTogbnVtYmVyXG4gICAgaXNGcmVlOiBib29sZWFuXG4gIH0+XG4gIHRvdGFsU2NyZWVuc2hvdENvc3Q6IG51bWJlclxuICBicmVha2Rvd246IHN0cmluZ1xufVxuXG4vLyBsb2NhbFN0b3JhZ2Uga2V5c1xuY29uc3QgU1RPUkFHRV9LRVlTID0ge1xuICBTRVRUSU5HUzogXCJzY3JlZW5zaG90X3ByaWNpbmdfc2V0dGluZ3NcIixcbiAgVElFUlM6IFwic2NyZWVuc2hvdF9wcmljaW5nX3RpZXJzXCIsXG59XG5cbi8vIERlZmF1bHQgc2V0dGluZ3NcbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFNjcmVlbnNob3RQcmljaW5nU2V0dGluZ3MgPSB7XG4gIG1heF9zY3JlZW5zaG90c19hbGxvd2VkOiA1LFxuICBkZWZhdWx0X3NjcmVlbnNob3RfZmVlOiAwLjA1LFxuICBlbmFibGVfcGVyY2VudGFnZV9wcmljaW5nOiB0cnVlLFxuICBwbGF0Zm9ybV9zY3JlZW5zaG90X2ZlZTogMCxcbn1cblxuLy8gRGVmYXVsdCB0aWVyc1xuY29uc3QgREVGQVVMVF9USUVSUzogU2NyZWVuc2hvdFByaWNpbmdUaWVyW10gPSBbXG4gIHsgaWQ6IDEsIHNjcmVlbnNob3RfbnVtYmVyOiAxLCBwZXJjZW50YWdlX2ZlZTogMCwgaXNfZnJlZTogdHJ1ZSwgaXNfYWN0aXZlOiB0cnVlIH0sXG4gIHsgaWQ6IDIsIHNjcmVlbnNob3RfbnVtYmVyOiAyLCBwZXJjZW50YWdlX2ZlZTogMywgaXNfZnJlZTogZmFsc2UsIGlzX2FjdGl2ZTogdHJ1ZSB9LFxuICB7IGlkOiAzLCBzY3JlZW5zaG90X251bWJlcjogMywgcGVyY2VudGFnZV9mZWU6IDMsIGlzX2ZyZWU6IGZhbHNlLCBpc19hY3RpdmU6IHRydWUgfSxcbiAgeyBpZDogNCwgc2NyZWVuc2hvdF9udW1iZXI6IDQsIHBlcmNlbnRhZ2VfZmVlOiA1LCBpc19mcmVlOiBmYWxzZSwgaXNfYWN0aXZlOiB0cnVlIH0sXG4gIHsgaWQ6IDUsIHNjcmVlbnNob3RfbnVtYmVyOiA1LCBwZXJjZW50YWdlX2ZlZTogNSwgaXNfZnJlZTogZmFsc2UsIGlzX2FjdGl2ZTogdHJ1ZSB9LFxuXVxuXG4vLyBJbml0aWFsaXplIGRlZmF1bHQgZGF0YSBpZiBub3QgZXhpc3RzXG5mdW5jdGlvbiBpbml0aWFsaXplRGVmYXVsdERhdGEoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICBpZiAoIWxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZUy5TRVRUSU5HUykpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuU0VUVElOR1MsIEpTT04uc3RyaW5naWZ5KERFRkFVTFRfU0VUVElOR1MpKVxuICB9XG5cbiAgaWYgKCFsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuVElFUlMpKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLlRJRVJTLCBKU09OLnN0cmluZ2lmeShERUZBVUxUX1RJRVJTKSlcbiAgfVxufVxuXG4vLyBHZXQgc2NyZWVuc2hvdCBwcmljaW5nIHRpZXJzIGZyb20gbG9jYWxTdG9yYWdlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2NyZWVuc2hvdFByaWNpbmdUaWVycygpOiBQcm9taXNlPFNjcmVlbnNob3RQcmljaW5nVGllcltdPiB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBERUZBVUxUX1RJRVJTXG5cbiAgICBpbml0aWFsaXplRGVmYXVsdERhdGEoKVxuXG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLlRJRVJTKVxuICAgIGlmIChzdG9yZWQpIHtcbiAgICAgIGNvbnN0IHRpZXJzID0gSlNPTi5wYXJzZShzdG9yZWQpIGFzIFNjcmVlbnNob3RQcmljaW5nVGllcltdXG4gICAgICByZXR1cm4gdGllcnMuZmlsdGVyKCh0aWVyKSA9PiB0aWVyLmlzX2FjdGl2ZSkuc29ydCgoYSwgYikgPT4gYS5zY3JlZW5zaG90X251bWJlciAtIGIuc2NyZWVuc2hvdF9udW1iZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuIERFRkFVTFRfVElFUlNcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2V0U2NyZWVuc2hvdFByaWNpbmdUaWVyczpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIERFRkFVTFRfVElFUlNcbiAgfVxufVxuXG4vLyBHZXQgc2NyZWVuc2hvdCBwcmljaW5nIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2NyZWVuc2hvdFByaWNpbmdTZXR0aW5ncygpOiBQcm9taXNlPFNjcmVlbnNob3RQcmljaW5nU2V0dGluZ3M+IHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIERFRkFVTFRfU0VUVElOR1NcblxuICAgIGluaXRpYWxpemVEZWZhdWx0RGF0YSgpXG5cbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuU0VUVElOR1MpXG4gICAgaWYgKHN0b3JlZCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkKSBhcyBTY3JlZW5zaG90UHJpY2luZ1NldHRpbmdzXG4gICAgfVxuXG4gICAgcmV0dXJuIERFRkFVTFRfU0VUVElOR1NcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZ2V0U2NyZWVuc2hvdFByaWNpbmdTZXR0aW5nczpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIERFRkFVTFRfU0VUVElOR1NcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgc2NyZWVuc2hvdCBjb3N0cyBiYXNlZCBvbiBqb2IgY29zdCBhbmQgc2NyZWVuc2hvdCBjb3VudFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyhcbiAgc2NyZWVuc2hvdENvdW50OiBudW1iZXIsXG4gIHRvdGFsSm9iQ29zdDogbnVtYmVyLFxuKTogUHJvbWlzZTxTY3JlZW5zaG90UHJpY2luZ0NhbGN1bGF0aW9uPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgW3RpZXJzLCBzZXR0aW5nc10gPSBhd2FpdCBQcm9taXNlLmFsbChbZ2V0U2NyZWVuc2hvdFByaWNpbmdUaWVycygpLCBnZXRTY3JlZW5zaG90UHJpY2luZ1NldHRpbmdzKCldKVxuXG4gICAgY29uc3Qgc2NyZWVuc2hvdENvc3RzOiBBcnJheTx7XG4gICAgICBzY3JlZW5zaG90TnVtYmVyOiBudW1iZXJcbiAgICAgIGNvc3Q6IG51bWJlclxuICAgICAgcGVyY2VudGFnZTogbnVtYmVyXG4gICAgICBpc0ZyZWU6IGJvb2xlYW5cbiAgICB9PiA9IFtdXG5cbiAgICBsZXQgdG90YWxTY3JlZW5zaG90Q29zdCA9IDBcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IE1hdGgubWluKHNjcmVlbnNob3RDb3VudCwgc2V0dGluZ3MubWF4X3NjcmVlbnNob3RzX2FsbG93ZWQpOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpZXIgPSB0aWVycy5maW5kKCh0KSA9PiB0LnNjcmVlbnNob3RfbnVtYmVyID09PSBpKVxuXG4gICAgICBpZiAodGllcikge1xuICAgICAgICBjb25zdCBpc0ZyZWUgPSB0aWVyLmlzX2ZyZWVcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IHRpZXIucGVyY2VudGFnZV9mZWVcbiAgICAgICAgY29uc3QgY29zdCA9IGlzRnJlZSA/IDAgOiAodG90YWxKb2JDb3N0ICogcGVyY2VudGFnZSkgLyAxMDBcblxuICAgICAgICBzY3JlZW5zaG90Q29zdHMucHVzaCh7XG4gICAgICAgICAgc2NyZWVuc2hvdE51bWJlcjogaSxcbiAgICAgICAgICBjb3N0LFxuICAgICAgICAgIHBlcmNlbnRhZ2UsXG4gICAgICAgICAgaXNGcmVlLFxuICAgICAgICB9KVxuXG4gICAgICAgIHRvdGFsU2NyZWVuc2hvdENvc3QgKz0gY29zdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZGVmYXVsdCBwcmljaW5nIGlmIHRpZXIgbm90IGZvdW5kXG4gICAgICAgIGNvbnN0IGNvc3QgPSBzZXR0aW5ncy5lbmFibGVfcGVyY2VudGFnZV9wcmljaW5nID8gMCA6IHNldHRpbmdzLmRlZmF1bHRfc2NyZWVuc2hvdF9mZWVcbiAgICAgICAgc2NyZWVuc2hvdENvc3RzLnB1c2goe1xuICAgICAgICAgIHNjcmVlbnNob3ROdW1iZXI6IGksXG4gICAgICAgICAgY29zdCxcbiAgICAgICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgICAgIGlzRnJlZTogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICAgIHRvdGFsU2NyZWVuc2hvdENvc3QgKz0gY29zdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGJyZWFrZG93biB0ZXh0XG4gICAgY29uc3QgYnJlYWtkb3duID0gc2NyZWVuc2hvdENvc3RzXG4gICAgICAubWFwKChzYykgPT4ge1xuICAgICAgICBpZiAoc2MuaXNGcmVlKSB7XG4gICAgICAgICAgcmV0dXJuIGBTY3JlZW5zaG90ICR7c2Muc2NyZWVuc2hvdE51bWJlcn06IEZyZWVgXG4gICAgICAgIH0gZWxzZSBpZiAoc2MucGVyY2VudGFnZSA+IDApIHtcbiAgICAgICAgICByZXR1cm4gYFNjcmVlbnNob3QgJHtzYy5zY3JlZW5zaG90TnVtYmVyfTogJHtzYy5wZXJjZW50YWdlfSUgKCQke3NjLmNvc3QudG9GaXhlZCgyKX0pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgU2NyZWVuc2hvdCAke3NjLnNjcmVlbnNob3ROdW1iZXJ9OiAkJHtzYy5jb3N0LnRvRml4ZWQoMil9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oXCIsIFwiKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbnNob3RDb3VudDogTWF0aC5taW4oc2NyZWVuc2hvdENvdW50LCBzZXR0aW5ncy5tYXhfc2NyZWVuc2hvdHNfYWxsb3dlZCksXG4gICAgICB0b3RhbEpvYkNvc3QsXG4gICAgICBzY3JlZW5zaG90Q29zdHMsXG4gICAgICB0b3RhbFNjcmVlbnNob3RDb3N0LFxuICAgICAgYnJlYWtkb3duLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsY3VsYXRpbmcgc2NyZWVuc2hvdCBjb3N0czpcIiwgZXJyb3IpXG4gICAgLy8gRmFsbGJhY2sgY2FsY3VsYXRpb25cbiAgICBjb25zdCBmYWxsYmFja0Nvc3QgPSBzY3JlZW5zaG90Q291bnQgKiAwLjA1XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbnNob3RDb3VudCxcbiAgICAgIHRvdGFsSm9iQ29zdCxcbiAgICAgIHNjcmVlbnNob3RDb3N0czogW10sXG4gICAgICB0b3RhbFNjcmVlbnNob3RDb3N0OiBmYWxsYmFja0Nvc3QsXG4gICAgICBicmVha2Rvd246IGAke3NjcmVlbnNob3RDb3VudH0gc2NyZWVuc2hvdHMg77+977+9ICQwLjA1ID0gJCR7ZmFsbGJhY2tDb3N0LnRvRml4ZWQoMil9YCxcbiAgICB9XG4gIH1cbn1cblxuLy8gVXBkYXRlIHNjcmVlbnNob3QgcHJpY2luZyB0aWVyIChhZG1pbiBmdW5jdGlvbilcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVTY3JlZW5zaG90UHJpY2luZ1RpZXIoXG4gIHRpZXJJZDogbnVtYmVyLFxuICB1cGRhdGVzOiBQYXJ0aWFsPFNjcmVlbnNob3RQcmljaW5nVGllcj4sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgICBjb25zdCB0aWVycyA9IGF3YWl0IGdldFNjcmVlbnNob3RQcmljaW5nVGllcnMoKVxuICAgIGNvbnN0IGFsbFRpZXJzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuVElFUlMpIHx8IFwiW11cIikgYXMgU2NyZWVuc2hvdFByaWNpbmdUaWVyW11cblxuICAgIGNvbnN0IHVwZGF0ZWRUaWVycyA9IGFsbFRpZXJzLm1hcCgodGllcikgPT4gKHRpZXIuaWQgPT09IHRpZXJJZCA/IHsgLi4udGllciwgLi4udXBkYXRlcyB9IDogdGllcikpXG5cbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuVElFUlMsIEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRUaWVycykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHVwZGF0ZVNjcmVlbnNob3RQcmljaW5nVGllcjpcIiwgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBVcGRhdGUgc2NyZWVuc2hvdCBwcmljaW5nIHNldHRpbmcgKGFkbWluIGZ1bmN0aW9uKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVNjcmVlbnNob3RQcmljaW5nU2V0dGluZyhzZXR0aW5nTmFtZTogc3RyaW5nLCBzZXR0aW5nVmFsdWU6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgZ2V0U2NyZWVuc2hvdFByaWNpbmdTZXR0aW5ncygpXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICBbc2V0dGluZ05hbWVdOiBzZXR0aW5nVmFsdWUsXG4gICAgfVxuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLlNFVFRJTkdTLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiB1cGRhdGVTY3JlZW5zaG90UHJpY2luZ1NldHRpbmc6XCIsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJTVE9SQUdFX0tFWVMiLCJTRVRUSU5HUyIsIlRJRVJTIiwiREVGQVVMVF9TRVRUSU5HUyIsIm1heF9zY3JlZW5zaG90c19hbGxvd2VkIiwiZGVmYXVsdF9zY3JlZW5zaG90X2ZlZSIsImVuYWJsZV9wZXJjZW50YWdlX3ByaWNpbmciLCJwbGF0Zm9ybV9zY3JlZW5zaG90X2ZlZSIsIkRFRkFVTFRfVElFUlMiLCJpZCIsInNjcmVlbnNob3RfbnVtYmVyIiwicGVyY2VudGFnZV9mZWUiLCJpc19mcmVlIiwiaXNfYWN0aXZlIiwiaW5pdGlhbGl6ZURlZmF1bHREYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0U2NyZWVuc2hvdFByaWNpbmdUaWVycyIsInN0b3JlZCIsInRpZXJzIiwicGFyc2UiLCJmaWx0ZXIiLCJ0aWVyIiwic29ydCIsImEiLCJiIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0U2NyZWVuc2hvdFByaWNpbmdTZXR0aW5ncyIsImNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyIsInNjcmVlbnNob3RDb3VudCIsInRvdGFsSm9iQ29zdCIsInNldHRpbmdzIiwiUHJvbWlzZSIsImFsbCIsInNjcmVlbnNob3RDb3N0cyIsInRvdGFsU2NyZWVuc2hvdENvc3QiLCJpIiwiTWF0aCIsIm1pbiIsImZpbmQiLCJ0IiwiaXNGcmVlIiwicGVyY2VudGFnZSIsImNvc3QiLCJwdXNoIiwic2NyZWVuc2hvdE51bWJlciIsImJyZWFrZG93biIsIm1hcCIsInNjIiwidG9GaXhlZCIsImpvaW4iLCJmYWxsYmFja0Nvc3QiLCJ1cGRhdGVTY3JlZW5zaG90UHJpY2luZ1RpZXIiLCJ0aWVySWQiLCJ1cGRhdGVzIiwiYWxsVGllcnMiLCJ1cGRhdGVkVGllcnMiLCJ1cGRhdGVTY3JlZW5zaG90UHJpY2luZ1NldHRpbmciLCJzZXR0aW5nTmFtZSIsInNldHRpbmdWYWx1ZSIsInVwZGF0ZWRTZXR0aW5ncyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/screenshot-pricing.ts\n"));

/***/ })

}]);