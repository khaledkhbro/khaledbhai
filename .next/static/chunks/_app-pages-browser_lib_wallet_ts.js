"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_wallet_ts"],{

/***/ "(app-pages-browser)/./lib/notifications.ts":
/*!******************************!*\
  !*** ./lib/notifications.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotification: () => (/* binding */ createNotification),\n/* harmony export */   getRecentActivity: () => (/* binding */ getRecentActivity),\n/* harmony export */   getUnreadNotificationCount: () => (/* binding */ getUnreadNotificationCount),\n/* harmony export */   getUserNotifications: () => (/* binding */ getUserNotifications),\n/* harmony export */   markAllNotificationsAsRead: () => (/* binding */ markAllNotificationsAsRead),\n/* harmony export */   markNotificationAsRead: () => (/* binding */ markNotificationAsRead)\n/* harmony export */ });\n// Notification system for real-time user updates\nconst NOTIFICATIONS_STORAGE_KEY = \"marketplace-notifications\";\nconst getStoredNotifications = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(NOTIFICATIONS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveNotifications = (notifications)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(NOTIFICATIONS_STORAGE_KEY, JSON.stringify(notifications));\n    } catch (error) {\n        console.error(\"Failed to save notifications:\", error);\n    }\n};\nasync function createNotification(data) {\n    const newNotification = {\n        id: \"notif_\".concat(Date.now()),\n        userId: data.userId,\n        type: data.type,\n        title: data.title,\n        description: data.description,\n        timestamp: new Date().toISOString(),\n        read: false,\n        actionUrl: data.actionUrl\n    };\n    const notifications = getStoredNotifications();\n    notifications.push(newNotification);\n    saveNotifications(notifications);\n    return newNotification;\n}\nasync function getUserNotifications(userId) {\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId).sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n}\nasync function markNotificationAsRead(notificationId) {\n    const notifications = getStoredNotifications();\n    const notificationIndex = notifications.findIndex((n)=>n.id === notificationId);\n    if (notificationIndex !== -1) {\n        notifications[notificationIndex].read = true;\n        saveNotifications(notifications);\n    }\n}\nasync function markAllNotificationsAsRead(userId) {\n    const notifications = getStoredNotifications();\n    const updatedNotifications = notifications.map((n)=>n.userId === userId ? {\n            ...n,\n            read: true\n        } : n);\n    saveNotifications(updatedNotifications);\n}\nasync function getRecentActivity(userId) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId).sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).slice(0, limit);\n}\nasync function getUnreadNotificationCount(userId) {\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId && !n.read).length;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2xpYi9ub3RpZmljYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vdGlmaWNhdGlvbiBzeXN0ZW0gZm9yIHJlYWwtdGltZSB1c2VyIHVwZGF0ZXNcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uIHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VySWQ6IHN0cmluZ1xuICB0eXBlOiBcImpvYlwiIHwgXCJtZXNzYWdlXCIgfCBcInBheW1lbnRcIiB8IFwic3lzdGVtXCJcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIHJlYWQ6IGJvb2xlYW5cbiAgYWN0aW9uVXJsPzogc3RyaW5nXG59XG5cbmNvbnN0IE5PVElGSUNBVElPTlNfU1RPUkFHRV9LRVkgPSBcIm1hcmtldHBsYWNlLW5vdGlmaWNhdGlvbnNcIlxuXG5jb25zdCBnZXRTdG9yZWROb3RpZmljYXRpb25zID0gKCk6IE5vdGlmaWNhdGlvbltdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKE5PVElGSUNBVElPTlNfU1RPUkFHRV9LRVkpXG4gICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmNvbnN0IHNhdmVOb3RpZmljYXRpb25zID0gKG5vdGlmaWNhdGlvbnM6IE5vdGlmaWNhdGlvbltdKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShOT1RJRklDQVRJT05TX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb25zKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbm90aWZpY2F0aW9uczpcIiwgZXJyb3IpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvbihkYXRhOiB7XG4gIHVzZXJJZDogc3RyaW5nXG4gIHR5cGU6IFwiam9iXCIgfCBcIm1lc3NhZ2VcIiB8IFwicGF5bWVudFwiIHwgXCJzeXN0ZW1cIlxuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgYWN0aW9uVXJsPzogc3RyaW5nXG59KTogUHJvbWlzZTxOb3RpZmljYXRpb24+IHtcbiAgY29uc3QgbmV3Tm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24gPSB7XG4gICAgaWQ6IGBub3RpZl8ke0RhdGUubm93KCl9YCxcbiAgICB1c2VySWQ6IGRhdGEudXNlcklkLFxuICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICByZWFkOiBmYWxzZSxcbiAgICBhY3Rpb25Vcmw6IGRhdGEuYWN0aW9uVXJsLFxuICB9XG5cbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICBub3RpZmljYXRpb25zLnB1c2gobmV3Tm90aWZpY2F0aW9uKVxuICBzYXZlTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb25zKVxuXG4gIHJldHVybiBuZXdOb3RpZmljYXRpb25cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJOb3RpZmljYXRpb25zKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxOb3RpZmljYXRpb25bXT4ge1xuICBjb25zdCBub3RpZmljYXRpb25zID0gZ2V0U3RvcmVkTm90aWZpY2F0aW9ucygpXG4gIHJldHVybiBub3RpZmljYXRpb25zXG4gICAgLmZpbHRlcigobikgPT4gbi51c2VySWQgPT09IHVzZXJJZClcbiAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi50aW1lc3RhbXApLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEudGltZXN0YW1wKS5nZXRUaW1lKCkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrTm90aWZpY2F0aW9uQXNSZWFkKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICBjb25zdCBub3RpZmljYXRpb25JbmRleCA9IG5vdGlmaWNhdGlvbnMuZmluZEluZGV4KChuKSA9PiBuLmlkID09PSBub3RpZmljYXRpb25JZClcblxuICBpZiAobm90aWZpY2F0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgbm90aWZpY2F0aW9uc1tub3RpZmljYXRpb25JbmRleF0ucmVhZCA9IHRydWVcbiAgICBzYXZlTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb25zKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrQWxsTm90aWZpY2F0aW9uc0FzUmVhZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBub3RpZmljYXRpb25zID0gZ2V0U3RvcmVkTm90aWZpY2F0aW9ucygpXG4gIGNvbnN0IHVwZGF0ZWROb3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9ucy5tYXAoKG4pID0+IChuLnVzZXJJZCA9PT0gdXNlcklkID8geyAuLi5uLCByZWFkOiB0cnVlIH0gOiBuKSlcbiAgc2F2ZU5vdGlmaWNhdGlvbnModXBkYXRlZE5vdGlmaWNhdGlvbnMpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRBY3Rpdml0eSh1c2VySWQ6IHN0cmluZywgbGltaXQgPSAxMCk6IFByb21pc2U8Tm90aWZpY2F0aW9uW10+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICByZXR1cm4gbm90aWZpY2F0aW9uc1xuICAgIC5maWx0ZXIoKG4pID0+IG4udXNlcklkID09PSB1c2VySWQpXG4gICAgLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudGltZXN0YW1wKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVucmVhZE5vdGlmaWNhdGlvbkNvdW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICByZXR1cm4gbm90aWZpY2F0aW9ucy5maWx0ZXIoKG4pID0+IG4udXNlcklkID09PSB1c2VySWQgJiYgIW4ucmVhZCkubGVuZ3RoXG59XG4iXSwibmFtZXMiOlsiTk9USUZJQ0FUSU9OU19TVE9SQUdFX0tFWSIsImdldFN0b3JlZE5vdGlmaWNhdGlvbnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2F2ZU5vdGlmaWNhdGlvbnMiLCJub3RpZmljYXRpb25zIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsImRhdGEiLCJuZXdOb3RpZmljYXRpb24iLCJpZCIsIkRhdGUiLCJub3ciLCJ1c2VySWQiLCJ0eXBlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwicmVhZCIsImFjdGlvblVybCIsInB1c2giLCJnZXRVc2VyTm90aWZpY2F0aW9ucyIsImZpbHRlciIsIm4iLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsIm5vdGlmaWNhdGlvbklkIiwibm90aWZpY2F0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJtYXJrQWxsTm90aWZpY2F0aW9uc0FzUmVhZCIsInVwZGF0ZWROb3RpZmljYXRpb25zIiwibWFwIiwiZ2V0UmVjZW50QWN0aXZpdHkiLCJsaW1pdCIsInNsaWNlIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/notifications.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/wallet.ts":
/*!***********************!*\
  !*** ./lib/wallet.ts ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEarnings: () => (/* binding */ addEarnings),\n/* harmony export */   addPaymentMethod: () => (/* binding */ addPaymentMethod),\n/* harmony export */   addWalletTransaction: () => (/* binding */ addWalletTransaction),\n/* harmony export */   createDeposit: () => (/* binding */ createDeposit),\n/* harmony export */   createWithdrawal: () => (/* binding */ createWithdrawal),\n/* harmony export */   getAdminFeeSettings: () => (/* binding */ getAdminFeeSettings),\n/* harmony export */   getPaymentMethods: () => (/* binding */ getPaymentMethods),\n/* harmony export */   getPendingPayments: () => (/* binding */ getPendingPayments),\n/* harmony export */   getTransactions: () => (/* binding */ getTransactions),\n/* harmony export */   getUpcomingPayments: () => (/* binding */ getUpcomingPayments),\n/* harmony export */   getWallet: () => (/* binding */ getWallet),\n/* harmony export */   getWalletTransactions: () => (/* binding */ getWalletTransactions),\n/* harmony export */   processTipPayment: () => (/* binding */ processTipPayment),\n/* harmony export */   updateAdminFeeSettings: () => (/* binding */ updateAdminFeeSettings),\n/* harmony export */   validateTipBalance: () => (/* binding */ validateTipBalance)\n/* harmony export */ });\n/* harmony import */ var _notifications__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\");\n// Wallet-related types\n// Real wallet functions using localStorage\nasync function getWallet(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const wallets = JSON.parse(localStorage.getItem(\"wallets\") || \"{}\");\n    if (!wallets[userId]) {\n        const newWallet = {\n            id: \"wallet_\".concat(userId),\n            userId,\n            balance: 0,\n            depositBalance: 0,\n            earningsBalance: 0,\n            pendingBalance: 0,\n            totalEarned: 0,\n            totalSpent: 0,\n            upcomingPayments: 0,\n            pendingPayments: 0,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        wallets[userId] = newWallet;\n        localStorage.setItem(\"wallets\", JSON.stringify(wallets));\n        return newWallet;\n    }\n    return wallets[userId];\n}\nasync function getTransactions(walletId, filters) {\n    await new Promise((resolve)=>setTimeout(resolve, 400));\n    const transactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n    let filteredTransactions = transactions.filter((t)=>t.walletId === walletId);\n    if (filters === null || filters === void 0 ? void 0 : filters.type) {\n        filteredTransactions = filteredTransactions.filter((t)=>t.type === filters.type);\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.status) {\n        filteredTransactions = filteredTransactions.filter((t)=>t.status === filters.status);\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.limit) {\n        filteredTransactions = filteredTransactions.slice(0, filters.limit);\n    }\n    return filteredTransactions.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n}\nasync function getWalletTransactions(userId) {\n    const wallet = await getWallet(userId);\n    return getTransactions(wallet.id);\n}\nasync function getPaymentMethods(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 200));\n    const paymentMethods = JSON.parse(localStorage.getItem(\"payment_methods\") || \"{}\");\n    return paymentMethods[userId] || [];\n}\nfunction generateUniqueId() {\n    // Use crypto.randomUUID() if available (modern browsers)\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    // Fallback to timestamp + random string for better uniqueness\n    return \"\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n}\nasync function createDeposit(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    const wallet = await getWallet(data.userId);\n    const feeSettings = await getAdminFeeSettings(\"deposit\");\n    const feeAmount = calculateFee(data.amount, feeSettings);\n    const netAmount = data.amount - feeAmount;\n    const newTransaction = {\n        id: \"txn_\".concat(generateUniqueId()),\n        walletId: wallet.id,\n        type: \"deposit\",\n        amount: data.amount,\n        feeAmount,\n        netAmount,\n        balanceType: \"deposit\",\n        description: \"Deposit from payment method\".concat(feeAmount > 0 ? \" (Fee: $\".concat(feeAmount.toFixed(2), \")\") : \"\"),\n        status: \"completed\",\n        createdAt: new Date().toISOString()\n    };\n    // Update wallet deposit balance\n    const wallets = JSON.parse(localStorage.getItem(\"wallets\") || \"{}\");\n    wallets[data.userId].depositBalance += netAmount;\n    wallets[data.userId].balance += netAmount // Legacy compatibility\n    ;\n    wallets[data.userId].updatedAt = new Date().toISOString();\n    localStorage.setItem(\"wallets\", JSON.stringify(wallets));\n    // Save transaction and fee collection\n    const transactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n    transactions.push(newTransaction);\n    localStorage.setItem(\"wallet_transactions\", JSON.stringify(transactions));\n    if (feeAmount > 0) {\n        await recordFeeCollection(newTransaction.id, \"deposit\", data.amount, feeSettings, feeAmount);\n    }\n    return newTransaction;\n}\nasync function createWithdrawal(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    const wallet = await getWallet(data.userId);\n    // Only earnings balance can be withdrawn\n    if (wallet.earningsBalance < data.amount) {\n        throw new Error(\"Insufficient earnings balance for withdrawal\");\n    }\n    const feeSettings = await getAdminFeeSettings(\"withdrawal\");\n    const feeAmount = calculateFee(data.amount, feeSettings);\n    const netAmount = data.amount - feeAmount;\n    const newTransaction = {\n        id: \"txn_\".concat(generateUniqueId()),\n        walletId: wallet.id,\n        type: \"withdrawal\",\n        amount: -data.amount,\n        feeAmount,\n        netAmount: -netAmount,\n        balanceType: \"earnings\",\n        description: \"Withdrawal to payment method\".concat(feeAmount > 0 ? \" (Fee: $\".concat(feeAmount.toFixed(2), \")\") : \"\"),\n        status: \"pending\",\n        createdAt: new Date().toISOString()\n    };\n    // Update wallet earnings balance\n    const wallets = JSON.parse(localStorage.getItem(\"wallets\") || \"{}\");\n    wallets[data.userId].earningsBalance -= data.amount;\n    wallets[data.userId].totalSpent += data.amount;\n    wallets[data.userId].updatedAt = new Date().toISOString();\n    localStorage.setItem(\"wallets\", JSON.stringify(wallets));\n    // Save transaction and fee collection\n    const transactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n    transactions.push(newTransaction);\n    localStorage.setItem(\"wallet_transactions\", JSON.stringify(transactions));\n    if (feeAmount > 0) {\n        await recordFeeCollection(newTransaction.id, \"withdrawal\", data.amount, feeSettings, feeAmount);\n    }\n    return newTransaction;\n}\nasync function addPaymentMethod(userId, method) {\n    const paymentMethods = JSON.parse(localStorage.getItem(\"payment_methods\") || \"{}\");\n    if (!paymentMethods[userId]) {\n        paymentMethods[userId] = [];\n    }\n    const newMethod = {\n        id: \"pm_\".concat(Date.now()),\n        userId,\n        ...method,\n        createdAt: new Date().toISOString()\n    };\n    paymentMethods[userId].push(newMethod);\n    localStorage.setItem(\"payment_methods\", JSON.stringify(paymentMethods));\n    return newMethod;\n}\nasync function addEarnings(data) {\n    const wallet = await getWallet(data.userId);\n    const newTransaction = {\n        id: \"txn_\".concat(generateUniqueId()),\n        walletId: wallet.id,\n        type: \"earning\",\n        amount: data.amount,\n        feeAmount: 0,\n        netAmount: data.amount,\n        balanceType: \"earnings\",\n        description: data.description,\n        referenceId: data.referenceId,\n        referenceType: data.referenceType,\n        status: \"completed\",\n        createdAt: new Date().toISOString()\n    };\n    // Update wallet earnings balance\n    const wallets = JSON.parse(localStorage.getItem(\"wallets\") || \"{}\");\n    wallets[data.userId].earningsBalance += data.amount;\n    wallets[data.userId].totalEarned += data.amount;\n    wallets[data.userId].updatedAt = new Date().toISOString();\n    localStorage.setItem(\"wallets\", JSON.stringify(wallets));\n    // Save transaction\n    const transactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n    transactions.push(newTransaction);\n    localStorage.setItem(\"wallet_transactions\", JSON.stringify(transactions));\n    return newTransaction;\n}\n// Admin fee management functions\nasync function getAdminFeeSettings(feeType) {\n    const feeSettings = JSON.parse(localStorage.getItem(\"admin_fee_settings\") || \"{}\");\n    if (!feeSettings[feeType]) {\n        // Default fee settings\n        const defaultSettings = {\n            id: \"fee_\".concat(feeType),\n            feeType: feeType,\n            feePercentage: feeType === \"deposit\" ? 2.5 : feeType === \"withdrawal\" ? 1.0 : feeType === \"tip\" ? 0 : 3.0,\n            feeFixed: feeType === \"withdrawal\" ? 0.25 : feeType === \"tip\" ? 0 : 0,\n            minimumFee: feeType === \"deposit\" ? 0.5 : feeType === \"tip\" ? 0.5 : 0.25,\n            maximumFee: feeType === \"tip\" ? 100 : undefined,\n            isActive: feeType === \"tip\" ? true : true,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n        feeSettings[feeType] = defaultSettings;\n        localStorage.setItem(\"admin_fee_settings\", JSON.stringify(feeSettings));\n        return defaultSettings;\n    }\n    return feeSettings[feeType];\n}\nasync function updateAdminFeeSettings(feeType, settings) {\n    const feeSettings = JSON.parse(localStorage.getItem(\"admin_fee_settings\") || \"{}\");\n    if (!feeSettings[feeType]) {\n        throw new Error(\"Fee settings not found\");\n    }\n    feeSettings[feeType] = {\n        ...feeSettings[feeType],\n        ...settings,\n        updatedAt: new Date().toISOString()\n    };\n    localStorage.setItem(\"admin_fee_settings\", JSON.stringify(feeSettings));\n    return feeSettings[feeType];\n}\nfunction calculateFee(amount, feeSettings) {\n    if (!feeSettings.isActive) return 0;\n    let fee = amount * feeSettings.feePercentage / 100 + feeSettings.feeFixed;\n    if (fee < feeSettings.minimumFee) {\n        fee = feeSettings.minimumFee;\n    }\n    if (feeSettings.maximumFee && fee > feeSettings.maximumFee) {\n        fee = feeSettings.maximumFee;\n    }\n    return Math.round(fee * 100) / 100 // Round to 2 decimal places\n    ;\n}\nasync function recordFeeCollection(transactionId, feeType, originalAmount, feeSettings, feeAmount) {\n    const feeCollections = JSON.parse(localStorage.getItem(\"admin_fee_collections\") || \"[]\");\n    const feeCollection = {\n        id: \"fee_\".concat(generateUniqueId()),\n        transactionId,\n        feeType,\n        originalAmount,\n        feePercentage: feeSettings.feePercentage,\n        feeFixed: feeSettings.feeFixed,\n        feeAmount,\n        collectedAt: new Date().toISOString()\n    };\n    feeCollections.push(feeCollection);\n    localStorage.setItem(\"admin_fee_collections\", JSON.stringify(feeCollections));\n}\nasync function getUpcomingPayments(userId) {\n    const schedules = JSON.parse(localStorage.getItem(\"payment_schedules\") || \"[]\");\n    return schedules.filter((s)=>s.userId === userId && s.status === \"scheduled\").sort((a, b)=>new Date(a.scheduledDate).getTime() - new Date(b.scheduledDate).getTime());\n}\nasync function getPendingPayments(userId) {\n    return getTransactions(\"wallet_\".concat(userId), {\n        status: \"pending\"\n    });\n}\n\nasync function addWalletTransaction(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    console.log(\"[v0] 💰 WALLET: Starting transaction for user:\", data.userId);\n    console.log(\"[v0] 💰 WALLET: Transaction type:\", data.type, \"Amount:\", data.amount);\n    console.log(\"[v0] 💰 WALLET: Description:\", data.description);\n    console.log(\"[v0] 💰 WALLET: Reference ID:\", data.referenceId);\n    if (data.referenceId) {\n        const existingTransactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n        const duplicateTransaction = existingTransactions.find((t)=>t.referenceId === data.referenceId && t.referenceType === data.referenceType && t.status === \"completed\");\n        if (duplicateTransaction) {\n            console.log(\"[v0] ⚠️ WALLET: Duplicate transaction prevented for referenceId: \".concat(data.referenceId));\n            console.log(\"[v0] ⚠️ WALLET: Existing transaction ID: \".concat(duplicateTransaction.id));\n            throw new Error(\"Transaction with reference ID \".concat(data.referenceId, \" already exists\"));\n        }\n    }\n    const wallet = await getWallet(data.userId);\n    const balanceType = data.balanceType || (data.type === \"earning\" ? \"earnings\" : \"deposit\");\n    console.log(\"[v0] 💰 WALLET: Current wallet state before transaction:\");\n    console.log(\"[v0] 💰 WALLET: - Earnings balance:\", wallet.earningsBalance);\n    console.log(\"[v0] 💰 WALLET: - Deposit balance:\", wallet.depositBalance);\n    console.log(\"[v0] 💰 WALLET: - Total earned:\", wallet.totalEarned);\n    const newTransaction = {\n        id: \"txn_\".concat(generateUniqueId()),\n        walletId: wallet.id,\n        type: data.type,\n        amount: data.amount,\n        feeAmount: 0,\n        netAmount: data.amount,\n        balanceType,\n        description: data.description,\n        referenceId: data.referenceId,\n        referenceType: data.referenceType,\n        status: \"completed\",\n        createdAt: new Date().toISOString()\n    };\n    // Update wallet balance based on transaction type and balance type\n    const wallets = JSON.parse(localStorage.getItem(\"wallets\") || \"{}\");\n    if (data.type === \"earning\") {\n        console.log(\"[v0] 💰 WALLET: Adding\", data.amount, \"to earnings balance\");\n        wallets[data.userId].earningsBalance += data.amount;\n        wallets[data.userId].totalEarned += data.amount;\n        console.log(\"[v0] 💰 WALLET: New earnings balance:\", wallets[data.userId].earningsBalance);\n        console.log(\"[v0] 💰 WALLET: New total earned:\", wallets[data.userId].totalEarned);\n    } else if (data.type === \"deposit\") {\n        console.log(\"[v0] 💰 WALLET: Adding\", data.amount, \"to deposit balance\");\n        wallets[data.userId].depositBalance += data.amount;\n        console.log(\"[v0] 💰 WALLET: New deposit balance:\", wallets[data.userId].depositBalance);\n    } else if (data.type === \"withdrawal\") {\n        const withdrawAmount = Math.abs(data.amount);\n        console.log(\"[v0] 💰 WALLET: Subtracting\", withdrawAmount, \"from earnings balance\");\n        wallets[data.userId].earningsBalance -= withdrawAmount;\n        wallets[data.userId].totalSpent += withdrawAmount;\n        console.log(\"[v0] 💰 WALLET: New earnings balance:\", wallets[data.userId].earningsBalance);\n    } else if (data.type === \"payment\") {\n        const paymentAmount = Math.abs(data.amount);\n        console.log(\"[v0] 💰 WALLET: Subtracting\", paymentAmount, \"from deposit balance for payment\");\n        wallets[data.userId].depositBalance -= paymentAmount;\n        wallets[data.userId].totalSpent += paymentAmount;\n        console.log(\"[v0] 💰 WALLET: New deposit balance:\", wallets[data.userId].depositBalance);\n        console.log(\"[v0] 💰 WALLET: New total spent:\", wallets[data.userId].totalSpent);\n    } else if (data.type === \"refund\") {\n        const refundAmount = Math.abs(data.amount);\n        if (balanceType === \"deposit\") {\n            console.log(\"[v0] 💰 WALLET: Adding\", refundAmount, \"refund to deposit balance\");\n            wallets[data.userId].depositBalance += refundAmount;\n            console.log(\"[v0] 💰 WALLET: New deposit balance:\", wallets[data.userId].depositBalance);\n        } else {\n            console.log(\"[v0] 💰 WALLET: Adding\", refundAmount, \"refund to earnings balance\");\n            wallets[data.userId].earningsBalance += refundAmount;\n            console.log(\"[v0] 💰 WALLET: New earnings balance:\", wallets[data.userId].earningsBalance);\n        }\n    }\n    wallets[data.userId].updatedAt = new Date().toISOString();\n    localStorage.setItem(\"wallets\", JSON.stringify(wallets));\n    // Save transaction\n    const transactions = JSON.parse(localStorage.getItem(\"wallet_transactions\") || \"[]\");\n    transactions.push(newTransaction);\n    localStorage.setItem(\"wallet_transactions\", JSON.stringify(transactions));\n    try {\n        const notificationTitle = getTransactionNotificationTitle(data.type, data.amount);\n        const notificationDescription = data.description;\n        await (0,_notifications__WEBPACK_IMPORTED_MODULE_0__.createNotification)({\n            userId: data.userId,\n            type: \"payment\",\n            title: notificationTitle,\n            description: notificationDescription,\n            actionUrl: \"/dashboard/wallet\"\n        });\n        console.log(\"[v0] 🔔 NOTIFICATION: Created transaction notification for user:\", data.userId);\n    } catch (error) {\n        console.error(\"[v0] ❌ NOTIFICATION: Failed to create transaction notification:\", error);\n    }\n    console.log(\"[v0] ✅ WALLET: Transaction completed successfully!\");\n    console.log(\"[v0] 💰 WALLET: Transaction ID:\", newTransaction.id);\n    console.log(\"[v0] 💰 WALLET: Final earnings balance:\", wallets[data.userId].earningsBalance);\n    return newTransaction;\n}\nfunction getTransactionNotificationTitle(type, amount) {\n    const absAmount = Math.abs(amount);\n    const formattedAmount = \"$\".concat(absAmount.toFixed(2));\n    switch(type){\n        case \"earning\":\n            return \"\\uD83D\\uDCB0 Earnings Added: \".concat(formattedAmount);\n        case \"deposit\":\n            return \"\\uD83D\\uDCB3 Deposit Successful: \".concat(formattedAmount);\n        case \"withdrawal\":\n            return \"\\uD83C\\uDFE6 Withdrawal Processed: \".concat(formattedAmount);\n        case \"payment\":\n            return \"\\uD83D\\uDCB8 Payment Made: \".concat(formattedAmount);\n        case \"refund\":\n            return \"\\uD83D\\uDD04 Refund Received: \".concat(formattedAmount);\n        default:\n            return \"\\uD83D\\uDCB0 Transaction: \".concat(formattedAmount);\n    }\n}\nasync function validateTipBalance(userId, tipAmount) {\n    try {\n        const wallet = await getWallet(userId);\n        // Check if user has sufficient deposit balance for tip\n        if (wallet.depositBalance < tipAmount) {\n            return {\n                valid: false,\n                error: \"Insufficient deposit balance. Required: $\".concat(tipAmount.toFixed(2), \", Available: $\").concat(wallet.depositBalance.toFixed(2))\n            };\n        }\n        // Get tip settings to check limits\n        const tipSettings = await getAdminFeeSettings(\"tip\");\n        if (tipSettings.isActive) {\n            // Check minimum tip\n            if (tipAmount < tipSettings.minimumFee) {\n                return {\n                    valid: false,\n                    error: \"Minimum tip amount is $\".concat(tipSettings.minimumFee.toFixed(2))\n                };\n            }\n            // Check maximum tip\n            if (tipSettings.maximumFee && tipAmount > tipSettings.maximumFee) {\n                return {\n                    valid: false,\n                    error: \"Maximum tip amount is $\".concat(tipSettings.maximumFee.toFixed(2))\n                };\n            }\n        }\n        return {\n            valid: true\n        };\n    } catch (error) {\n        console.error(\"[v0] Error validating tip balance:\", error);\n        return {\n            valid: false,\n            error: \"Failed to validate tip balance\"\n        };\n    }\n}\nasync function processTipPayment(data) {\n    try {\n        console.log(\"[v0] 🎁 TIP: Processing tip payment:\", data.tipAmount, \"from\", data.employerId, \"to\", data.workerId);\n        // Validate tip balance first\n        const validation = await validateTipBalance(data.employerId, data.tipAmount);\n        if (!validation.valid) {\n            return {\n                success: false,\n                error: validation.error\n            };\n        }\n        const tipSettings = await getAdminFeeSettings(\"tip\");\n        let feeAmount = 0;\n        if (tipSettings.isActive) {\n            feeAmount = calculateFee(data.tipAmount, tipSettings);\n        }\n        const netTipAmount = data.tipAmount - feeAmount;\n        // Deduct tip amount from employer's deposit balance\n        const employerTransaction = await addWalletTransaction({\n            userId: data.employerId,\n            type: \"payment\",\n            amount: -data.tipAmount,\n            description: \"Tip payment: \".concat(data.description).concat(feeAmount > 0 ? \" (Fee: $\".concat(feeAmount.toFixed(2), \")\") : \"\"),\n            referenceId: data.referenceId,\n            referenceType: \"tip_payment\",\n            balanceType: \"deposit\"\n        });\n        // Add tip to worker's earnings balance\n        const workerTransaction = await addWalletTransaction({\n            userId: data.workerId,\n            type: \"earning\",\n            amount: netTipAmount,\n            description: \"Tip received: \".concat(data.description),\n            referenceId: data.referenceId,\n            referenceType: \"tip\",\n            balanceType: \"earnings\"\n        });\n        console.log(\"[v0] ✅ TIP: Tip processed successfully!\");\n        console.log(\"[v0] 💰 TIP: Employer charged:\", data.tipAmount, \"Worker received:\", netTipAmount, \"Fee:\", feeAmount);\n        return {\n            success: true,\n            transactions: [\n                employerTransaction,\n                workerTransaction\n            ]\n        };\n    } catch (error) {\n        console.error(\"[v0] ❌ TIP: Failed to process tip payment:\", error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : \"Failed to process tip payment\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aG9tZS9wcm9qZWN0L2xpYi93YWxsZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV2FsbGV0LXJlbGF0ZWQgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0IHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VySWQ6IHN0cmluZ1xuICBiYWxhbmNlOiBudW1iZXIgLy8gTGVnYWN5IGZpZWxkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGRlcG9zaXRCYWxhbmNlOiBudW1iZXIgLy8gQ2Fubm90IGJlIHdpdGhkcmF3blxuICBlYXJuaW5nc0JhbGFuY2U6IG51bWJlciAvLyBDYW4gYmUgd2l0aGRyYXduXG4gIHBlbmRpbmdCYWxhbmNlOiBudW1iZXJcbiAgdG90YWxFYXJuZWQ6IG51bWJlclxuICB0b3RhbFNwZW50OiBudW1iZXJcbiAgdXBjb21pbmdQYXltZW50czogbnVtYmVyXG4gIHBlbmRpbmdQYXltZW50czogbnVtYmVyXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIHVwZGF0ZWRBdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FsbGV0VHJhbnNhY3Rpb24ge1xuICBpZDogc3RyaW5nXG4gIHdhbGxldElkOiBzdHJpbmdcbiAgdHlwZTogXCJkZXBvc2l0XCIgfCBcIndpdGhkcmF3YWxcIiB8IFwicGF5bWVudFwiIHwgXCJlYXJuaW5nXCIgfCBcInJlZnVuZFwiXG4gIGFtb3VudDogbnVtYmVyXG4gIGZlZUFtb3VudDogbnVtYmVyXG4gIG5ldEFtb3VudDogbnVtYmVyXG4gIGJhbGFuY2VUeXBlOiBcImRlcG9zaXRcIiB8IFwiZWFybmluZ3NcIlxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHJlZmVyZW5jZUlkPzogc3RyaW5nXG4gIHJlZmVyZW5jZVR5cGU/OiBzdHJpbmdcbiAgc3RhdHVzOiBcInBlbmRpbmdcIiB8IFwiY29tcGxldGVkXCIgfCBcImZhaWxlZFwiXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bWVudE1ldGhvZCB7XG4gIGlkOiBzdHJpbmdcbiAgdXNlcklkOiBzdHJpbmdcbiAgdHlwZTogXCJjYXJkXCIgfCBcInBheXBhbFwiIHwgXCJiYW5rX2FjY291bnRcIlxuICBsYXN0ND86IHN0cmluZ1xuICBicmFuZD86IHN0cmluZ1xuICBpc0RlZmF1bHQ6IGJvb2xlYW5cbiAgY3JlYXRlZEF0OiBzdHJpbmdcbn1cblxuLy8gQWRtaW4gZmVlIHNldHRpbmdzIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBBZG1pbkZlZVNldHRpbmdzIHtcbiAgaWQ6IHN0cmluZ1xuICBmZWVUeXBlOiBcImRlcG9zaXRcIiB8IFwid2l0aGRyYXdhbFwiIHwgXCJ0cmFuc2FjdGlvblwiIHwgXCJ0aXBcIlxuICBmZWVQZXJjZW50YWdlOiBudW1iZXJcbiAgZmVlRml4ZWQ6IG51bWJlclxuICBtaW5pbXVtRmVlOiBudW1iZXJcbiAgbWF4aW11bUZlZT86IG51bWJlclxuICBpc0FjdGl2ZTogYm9vbGVhblxuICBjcmVhdGVkQXQ6IHN0cmluZ1xuICB1cGRhdGVkQXQ6IHN0cmluZ1xufVxuXG4vLyBQYXltZW50IHNjaGVkdWxlIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBQYXltZW50U2NoZWR1bGUge1xuICBpZDogc3RyaW5nXG4gIHVzZXJJZDogc3RyaW5nXG4gIGFtb3VudDogbnVtYmVyXG4gIHNjaGVkdWxlZERhdGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHJlZmVyZW5jZUlkPzogc3RyaW5nXG4gIHJlZmVyZW5jZVR5cGU/OiBzdHJpbmdcbiAgc3RhdHVzOiBcInNjaGVkdWxlZFwiIHwgXCJwcm9jZXNzZWRcIiB8IFwiZmFpbGVkXCIgfCBcImNhbmNlbGxlZFwiXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIHByb2Nlc3NlZEF0Pzogc3RyaW5nXG59XG5cbi8vIFJlYWwgd2FsbGV0IGZ1bmN0aW9ucyB1c2luZyBsb2NhbFN0b3JhZ2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRXYWxsZXQodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFdhbGxldD4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IHdhbGxldHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0c1wiKSB8fCBcInt9XCIpXG5cbiAgaWYgKCF3YWxsZXRzW3VzZXJJZF0pIHtcbiAgICBjb25zdCBuZXdXYWxsZXQ6IFdhbGxldCA9IHtcbiAgICAgIGlkOiBgd2FsbGV0XyR7dXNlcklkfWAsXG4gICAgICB1c2VySWQsXG4gICAgICBiYWxhbmNlOiAwLFxuICAgICAgZGVwb3NpdEJhbGFuY2U6IDAsXG4gICAgICBlYXJuaW5nc0JhbGFuY2U6IDAsXG4gICAgICBwZW5kaW5nQmFsYW5jZTogMCxcbiAgICAgIHRvdGFsRWFybmVkOiAwLFxuICAgICAgdG90YWxTcGVudDogMCxcbiAgICAgIHVwY29taW5nUGF5bWVudHM6IDAsXG4gICAgICBwZW5kaW5nUGF5bWVudHM6IDAsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cbiAgICB3YWxsZXRzW3VzZXJJZF0gPSBuZXdXYWxsZXRcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIndhbGxldHNcIiwgSlNPTi5zdHJpbmdpZnkod2FsbGV0cykpXG4gICAgcmV0dXJuIG5ld1dhbGxldFxuICB9XG5cbiAgcmV0dXJuIHdhbGxldHNbdXNlcklkXVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zKFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICBmaWx0ZXJzPzoge1xuICAgIHR5cGU/OiBzdHJpbmdcbiAgICBzdGF0dXM/OiBzdHJpbmdcbiAgICBsaW1pdD86IG51bWJlclxuICB9LFxuKTogUHJvbWlzZTxXYWxsZXRUcmFuc2FjdGlvbltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDQwMCkpXG5cbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIndhbGxldF90cmFuc2FjdGlvbnNcIikgfHwgXCJbXVwiKVxuICBsZXQgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMuZmlsdGVyKCh0OiBXYWxsZXRUcmFuc2FjdGlvbikgPT4gdC53YWxsZXRJZCA9PT0gd2FsbGV0SWQpXG5cbiAgaWYgKGZpbHRlcnM/LnR5cGUpIHtcbiAgICBmaWx0ZXJlZFRyYW5zYWN0aW9ucyA9IGZpbHRlcmVkVHJhbnNhY3Rpb25zLmZpbHRlcigodDogV2FsbGV0VHJhbnNhY3Rpb24pID0+IHQudHlwZSA9PT0gZmlsdGVycy50eXBlKVxuICB9XG5cbiAgaWYgKGZpbHRlcnM/LnN0YXR1cykge1xuICAgIGZpbHRlcmVkVHJhbnNhY3Rpb25zID0gZmlsdGVyZWRUcmFuc2FjdGlvbnMuZmlsdGVyKCh0OiBXYWxsZXRUcmFuc2FjdGlvbikgPT4gdC5zdGF0dXMgPT09IGZpbHRlcnMuc3RhdHVzKVxuICB9XG5cbiAgaWYgKGZpbHRlcnM/LmxpbWl0KSB7XG4gICAgZmlsdGVyZWRUcmFuc2FjdGlvbnMgPSBmaWx0ZXJlZFRyYW5zYWN0aW9ucy5zbGljZSgwLCBmaWx0ZXJzLmxpbWl0KVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkVHJhbnNhY3Rpb25zLnNvcnQoXG4gICAgKGE6IFdhbGxldFRyYW5zYWN0aW9uLCBiOiBXYWxsZXRUcmFuc2FjdGlvbikgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCksXG4gIClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdhbGxldFRyYW5zYWN0aW9ucyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8V2FsbGV0VHJhbnNhY3Rpb25bXT4ge1xuICBjb25zdCB3YWxsZXQgPSBhd2FpdCBnZXRXYWxsZXQodXNlcklkKVxuICByZXR1cm4gZ2V0VHJhbnNhY3Rpb25zKHdhbGxldC5pZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBheW1lbnRNZXRob2RzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxQYXltZW50TWV0aG9kW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSlcblxuICBjb25zdCBwYXltZW50TWV0aG9kcyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJwYXltZW50X21ldGhvZHNcIikgfHwgXCJ7fVwiKVxuICByZXR1cm4gcGF5bWVudE1ldGhvZHNbdXNlcklkXSB8fCBbXVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVuaXF1ZUlkKCk6IHN0cmluZyB7XG4gIC8vIFVzZSBjcnlwdG8ucmFuZG9tVVVJRCgpIGlmIGF2YWlsYWJsZSAobW9kZXJuIGJyb3dzZXJzKVxuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpXG4gIH1cblxuICAvLyBGYWxsYmFjayB0byB0aW1lc3RhbXAgKyByYW5kb20gc3RyaW5nIGZvciBiZXR0ZXIgdW5pcXVlbmVzc1xuICByZXR1cm4gYCR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGVwb3NpdChkYXRhOiB7XG4gIGFtb3VudDogbnVtYmVyXG4gIHBheW1lbnRNZXRob2RJZDogc3RyaW5nXG4gIHVzZXJJZDogc3RyaW5nXG59KTogUHJvbWlzZTxXYWxsZXRUcmFuc2FjdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcblxuICBjb25zdCB3YWxsZXQgPSBhd2FpdCBnZXRXYWxsZXQoZGF0YS51c2VySWQpXG4gIGNvbnN0IGZlZVNldHRpbmdzID0gYXdhaXQgZ2V0QWRtaW5GZWVTZXR0aW5ncyhcImRlcG9zaXRcIilcbiAgY29uc3QgZmVlQW1vdW50ID0gY2FsY3VsYXRlRmVlKGRhdGEuYW1vdW50LCBmZWVTZXR0aW5ncylcbiAgY29uc3QgbmV0QW1vdW50ID0gZGF0YS5hbW91bnQgLSBmZWVBbW91bnRcblxuICBjb25zdCBuZXdUcmFuc2FjdGlvbjogV2FsbGV0VHJhbnNhY3Rpb24gPSB7XG4gICAgaWQ6IGB0eG5fJHtnZW5lcmF0ZVVuaXF1ZUlkKCl9YCxcbiAgICB3YWxsZXRJZDogd2FsbGV0LmlkLFxuICAgIHR5cGU6IFwiZGVwb3NpdFwiLFxuICAgIGFtb3VudDogZGF0YS5hbW91bnQsXG4gICAgZmVlQW1vdW50LFxuICAgIG5ldEFtb3VudCxcbiAgICBiYWxhbmNlVHlwZTogXCJkZXBvc2l0XCIsXG4gICAgZGVzY3JpcHRpb246IGBEZXBvc2l0IGZyb20gcGF5bWVudCBtZXRob2Qke2ZlZUFtb3VudCA+IDAgPyBgIChGZWU6ICQke2ZlZUFtb3VudC50b0ZpeGVkKDIpfSlgIDogXCJcIn1gLFxuICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIC8vIFVwZGF0ZSB3YWxsZXQgZGVwb3NpdCBiYWxhbmNlXG4gIGNvbnN0IHdhbGxldHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0c1wiKSB8fCBcInt9XCIpXG4gIHdhbGxldHNbZGF0YS51c2VySWRdLmRlcG9zaXRCYWxhbmNlICs9IG5ldEFtb3VudFxuICB3YWxsZXRzW2RhdGEudXNlcklkXS5iYWxhbmNlICs9IG5ldEFtb3VudCAvLyBMZWdhY3kgY29tcGF0aWJpbGl0eVxuICB3YWxsZXRzW2RhdGEudXNlcklkXS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ3YWxsZXRzXCIsIEpTT04uc3RyaW5naWZ5KHdhbGxldHMpKVxuXG4gIC8vIFNhdmUgdHJhbnNhY3Rpb24gYW5kIGZlZSBjb2xsZWN0aW9uXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ3YWxsZXRfdHJhbnNhY3Rpb25zXCIpIHx8IFwiW11cIilcbiAgdHJhbnNhY3Rpb25zLnB1c2gobmV3VHJhbnNhY3Rpb24pXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwid2FsbGV0X3RyYW5zYWN0aW9uc1wiLCBKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbnMpKVxuXG4gIGlmIChmZWVBbW91bnQgPiAwKSB7XG4gICAgYXdhaXQgcmVjb3JkRmVlQ29sbGVjdGlvbihuZXdUcmFuc2FjdGlvbi5pZCwgXCJkZXBvc2l0XCIsIGRhdGEuYW1vdW50LCBmZWVTZXR0aW5ncywgZmVlQW1vdW50KVxuICB9XG5cbiAgcmV0dXJuIG5ld1RyYW5zYWN0aW9uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXaXRoZHJhd2FsKGRhdGE6IHtcbiAgYW1vdW50OiBudW1iZXJcbiAgcGF5bWVudE1ldGhvZElkOiBzdHJpbmdcbiAgdXNlcklkOiBzdHJpbmdcbn0pOiBQcm9taXNlPFdhbGxldFRyYW5zYWN0aW9uPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuXG4gIGNvbnN0IHdhbGxldCA9IGF3YWl0IGdldFdhbGxldChkYXRhLnVzZXJJZClcblxuICAvLyBPbmx5IGVhcm5pbmdzIGJhbGFuY2UgY2FuIGJlIHdpdGhkcmF3blxuICBpZiAod2FsbGV0LmVhcm5pbmdzQmFsYW5jZSA8IGRhdGEuYW1vdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdWZmaWNpZW50IGVhcm5pbmdzIGJhbGFuY2UgZm9yIHdpdGhkcmF3YWxcIilcbiAgfVxuXG4gIGNvbnN0IGZlZVNldHRpbmdzID0gYXdhaXQgZ2V0QWRtaW5GZWVTZXR0aW5ncyhcIndpdGhkcmF3YWxcIilcbiAgY29uc3QgZmVlQW1vdW50ID0gY2FsY3VsYXRlRmVlKGRhdGEuYW1vdW50LCBmZWVTZXR0aW5ncylcbiAgY29uc3QgbmV0QW1vdW50ID0gZGF0YS5hbW91bnQgLSBmZWVBbW91bnRcblxuICBjb25zdCBuZXdUcmFuc2FjdGlvbjogV2FsbGV0VHJhbnNhY3Rpb24gPSB7XG4gICAgaWQ6IGB0eG5fJHtnZW5lcmF0ZVVuaXF1ZUlkKCl9YCxcbiAgICB3YWxsZXRJZDogd2FsbGV0LmlkLFxuICAgIHR5cGU6IFwid2l0aGRyYXdhbFwiLFxuICAgIGFtb3VudDogLWRhdGEuYW1vdW50LFxuICAgIGZlZUFtb3VudCxcbiAgICBuZXRBbW91bnQ6IC1uZXRBbW91bnQsXG4gICAgYmFsYW5jZVR5cGU6IFwiZWFybmluZ3NcIixcbiAgICBkZXNjcmlwdGlvbjogYFdpdGhkcmF3YWwgdG8gcGF5bWVudCBtZXRob2Qke2ZlZUFtb3VudCA+IDAgPyBgIChGZWU6ICQke2ZlZUFtb3VudC50b0ZpeGVkKDIpfSlgIDogXCJcIn1gLFxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cblxuICAvLyBVcGRhdGUgd2FsbGV0IGVhcm5pbmdzIGJhbGFuY2VcbiAgY29uc3Qgd2FsbGV0cyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ3YWxsZXRzXCIpIHx8IFwie31cIilcbiAgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlIC09IGRhdGEuYW1vdW50XG4gIHdhbGxldHNbZGF0YS51c2VySWRdLnRvdGFsU3BlbnQgKz0gZGF0YS5hbW91bnRcbiAgd2FsbGV0c1tkYXRhLnVzZXJJZF0udXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwid2FsbGV0c1wiLCBKU09OLnN0cmluZ2lmeSh3YWxsZXRzKSlcblxuICAvLyBTYXZlIHRyYW5zYWN0aW9uIGFuZCBmZWUgY29sbGVjdGlvblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0X3RyYW5zYWN0aW9uc1wiKSB8fCBcIltdXCIpXG4gIHRyYW5zYWN0aW9ucy5wdXNoKG5ld1RyYW5zYWN0aW9uKVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIndhbGxldF90cmFuc2FjdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb25zKSlcblxuICBpZiAoZmVlQW1vdW50ID4gMCkge1xuICAgIGF3YWl0IHJlY29yZEZlZUNvbGxlY3Rpb24obmV3VHJhbnNhY3Rpb24uaWQsIFwid2l0aGRyYXdhbFwiLCBkYXRhLmFtb3VudCwgZmVlU2V0dGluZ3MsIGZlZUFtb3VudClcbiAgfVxuXG4gIHJldHVybiBuZXdUcmFuc2FjdGlvblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUGF5bWVudE1ldGhvZChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIG1ldGhvZDogT21pdDxQYXltZW50TWV0aG9kLCBcImlkXCIgfCBcInVzZXJJZFwiIHwgXCJjcmVhdGVkQXRcIj4sXG4pOiBQcm9taXNlPFBheW1lbnRNZXRob2Q+IHtcbiAgY29uc3QgcGF5bWVudE1ldGhvZHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwicGF5bWVudF9tZXRob2RzXCIpIHx8IFwie31cIilcblxuICBpZiAoIXBheW1lbnRNZXRob2RzW3VzZXJJZF0pIHtcbiAgICBwYXltZW50TWV0aG9kc1t1c2VySWRdID0gW11cbiAgfVxuXG4gIGNvbnN0IG5ld01ldGhvZDogUGF5bWVudE1ldGhvZCA9IHtcbiAgICBpZDogYHBtXyR7RGF0ZS5ub3coKX1gLFxuICAgIHVzZXJJZCxcbiAgICAuLi5tZXRob2QsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cblxuICBwYXltZW50TWV0aG9kc1t1c2VySWRdLnB1c2gobmV3TWV0aG9kKVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInBheW1lbnRfbWV0aG9kc1wiLCBKU09OLnN0cmluZ2lmeShwYXltZW50TWV0aG9kcykpXG5cbiAgcmV0dXJuIG5ld01ldGhvZFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkRWFybmluZ3MoZGF0YToge1xuICBhbW91bnQ6IG51bWJlclxuICB1c2VySWQ6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHJlZmVyZW5jZUlkPzogc3RyaW5nXG4gIHJlZmVyZW5jZVR5cGU/OiBzdHJpbmdcbn0pOiBQcm9taXNlPFdhbGxldFRyYW5zYWN0aW9uPiB7XG4gIGNvbnN0IHdhbGxldCA9IGF3YWl0IGdldFdhbGxldChkYXRhLnVzZXJJZClcblxuICBjb25zdCBuZXdUcmFuc2FjdGlvbjogV2FsbGV0VHJhbnNhY3Rpb24gPSB7XG4gICAgaWQ6IGB0eG5fJHtnZW5lcmF0ZVVuaXF1ZUlkKCl9YCxcbiAgICB3YWxsZXRJZDogd2FsbGV0LmlkLFxuICAgIHR5cGU6IFwiZWFybmluZ1wiLFxuICAgIGFtb3VudDogZGF0YS5hbW91bnQsXG4gICAgZmVlQW1vdW50OiAwLFxuICAgIG5ldEFtb3VudDogZGF0YS5hbW91bnQsXG4gICAgYmFsYW5jZVR5cGU6IFwiZWFybmluZ3NcIixcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICByZWZlcmVuY2VJZDogZGF0YS5yZWZlcmVuY2VJZCxcbiAgICByZWZlcmVuY2VUeXBlOiBkYXRhLnJlZmVyZW5jZVR5cGUsXG4gICAgc3RhdHVzOiBcImNvbXBsZXRlZFwiLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgLy8gVXBkYXRlIHdhbGxldCBlYXJuaW5ncyBiYWxhbmNlXG4gIGNvbnN0IHdhbGxldHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0c1wiKSB8fCBcInt9XCIpXG4gIHdhbGxldHNbZGF0YS51c2VySWRdLmVhcm5pbmdzQmFsYW5jZSArPSBkYXRhLmFtb3VudFxuICB3YWxsZXRzW2RhdGEudXNlcklkXS50b3RhbEVhcm5lZCArPSBkYXRhLmFtb3VudFxuICB3YWxsZXRzW2RhdGEudXNlcklkXS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ3YWxsZXRzXCIsIEpTT04uc3RyaW5naWZ5KHdhbGxldHMpKVxuXG4gIC8vIFNhdmUgdHJhbnNhY3Rpb25cbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIndhbGxldF90cmFuc2FjdGlvbnNcIikgfHwgXCJbXVwiKVxuICB0cmFuc2FjdGlvbnMucHVzaChuZXdUcmFuc2FjdGlvbilcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ3YWxsZXRfdHJhbnNhY3Rpb25zXCIsIEpTT04uc3RyaW5naWZ5KHRyYW5zYWN0aW9ucykpXG5cbiAgcmV0dXJuIG5ld1RyYW5zYWN0aW9uXG59XG5cbi8vIEFkbWluIGZlZSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFkbWluRmVlU2V0dGluZ3MoZmVlVHlwZTogc3RyaW5nKTogUHJvbWlzZTxBZG1pbkZlZVNldHRpbmdzPiB7XG4gIGNvbnN0IGZlZVNldHRpbmdzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFkbWluX2ZlZV9zZXR0aW5nc1wiKSB8fCBcInt9XCIpXG5cbiAgaWYgKCFmZWVTZXR0aW5nc1tmZWVUeXBlXSkge1xuICAgIC8vIERlZmF1bHQgZmVlIHNldHRpbmdzXG4gICAgY29uc3QgZGVmYXVsdFNldHRpbmdzOiBBZG1pbkZlZVNldHRpbmdzID0ge1xuICAgICAgaWQ6IGBmZWVfJHtmZWVUeXBlfWAsXG4gICAgICBmZWVUeXBlOiBmZWVUeXBlIGFzIFwiZGVwb3NpdFwiIHwgXCJ3aXRoZHJhd2FsXCIgfCBcInRyYW5zYWN0aW9uXCIgfCBcInRpcFwiLFxuICAgICAgZmVlUGVyY2VudGFnZTogZmVlVHlwZSA9PT0gXCJkZXBvc2l0XCIgPyAyLjUgOiBmZWVUeXBlID09PSBcIndpdGhkcmF3YWxcIiA/IDEuMCA6IGZlZVR5cGUgPT09IFwidGlwXCIgPyAwIDogMy4wLFxuICAgICAgZmVlRml4ZWQ6IGZlZVR5cGUgPT09IFwid2l0aGRyYXdhbFwiID8gMC4yNSA6IGZlZVR5cGUgPT09IFwidGlwXCIgPyAwIDogMCxcbiAgICAgIG1pbmltdW1GZWU6IGZlZVR5cGUgPT09IFwiZGVwb3NpdFwiID8gMC41IDogZmVlVHlwZSA9PT0gXCJ0aXBcIiA/IDAuNSA6IDAuMjUsXG4gICAgICBtYXhpbXVtRmVlOiBmZWVUeXBlID09PSBcInRpcFwiID8gMTAwIDogdW5kZWZpbmVkLFxuICAgICAgaXNBY3RpdmU6IGZlZVR5cGUgPT09IFwidGlwXCIgPyB0cnVlIDogdHJ1ZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuICAgIGZlZVNldHRpbmdzW2ZlZVR5cGVdID0gZGVmYXVsdFNldHRpbmdzXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhZG1pbl9mZWVfc2V0dGluZ3NcIiwgSlNPTi5zdHJpbmdpZnkoZmVlU2V0dGluZ3MpKVxuICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3NcbiAgfVxuXG4gIHJldHVybiBmZWVTZXR0aW5nc1tmZWVUeXBlXVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlQWRtaW5GZWVTZXR0aW5ncyhcbiAgZmVlVHlwZTogc3RyaW5nLFxuICBzZXR0aW5nczogUGFydGlhbDxBZG1pbkZlZVNldHRpbmdzPixcbik6IFByb21pc2U8QWRtaW5GZWVTZXR0aW5ncz4ge1xuICBjb25zdCBmZWVTZXR0aW5ncyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhZG1pbl9mZWVfc2V0dGluZ3NcIikgfHwgXCJ7fVwiKVxuXG4gIGlmICghZmVlU2V0dGluZ3NbZmVlVHlwZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWUgc2V0dGluZ3Mgbm90IGZvdW5kXCIpXG4gIH1cblxuICBmZWVTZXR0aW5nc1tmZWVUeXBlXSA9IHtcbiAgICAuLi5mZWVTZXR0aW5nc1tmZWVUeXBlXSxcbiAgICAuLi5zZXR0aW5ncyxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiYWRtaW5fZmVlX3NldHRpbmdzXCIsIEpTT04uc3RyaW5naWZ5KGZlZVNldHRpbmdzKSlcbiAgcmV0dXJuIGZlZVNldHRpbmdzW2ZlZVR5cGVdXG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUZlZShhbW91bnQ6IG51bWJlciwgZmVlU2V0dGluZ3M6IEFkbWluRmVlU2V0dGluZ3MpOiBudW1iZXIge1xuICBpZiAoIWZlZVNldHRpbmdzLmlzQWN0aXZlKSByZXR1cm4gMFxuXG4gIGxldCBmZWUgPSAoYW1vdW50ICogZmVlU2V0dGluZ3MuZmVlUGVyY2VudGFnZSkgLyAxMDAgKyBmZWVTZXR0aW5ncy5mZWVGaXhlZFxuXG4gIGlmIChmZWUgPCBmZWVTZXR0aW5ncy5taW5pbXVtRmVlKSB7XG4gICAgZmVlID0gZmVlU2V0dGluZ3MubWluaW11bUZlZVxuICB9XG5cbiAgaWYgKGZlZVNldHRpbmdzLm1heGltdW1GZWUgJiYgZmVlID4gZmVlU2V0dGluZ3MubWF4aW11bUZlZSkge1xuICAgIGZlZSA9IGZlZVNldHRpbmdzLm1heGltdW1GZWVcbiAgfVxuXG4gIHJldHVybiBNYXRoLnJvdW5kKGZlZSAqIDEwMCkgLyAxMDAgLy8gUm91bmQgdG8gMiBkZWNpbWFsIHBsYWNlc1xufVxuXG5hc3luYyBmdW5jdGlvbiByZWNvcmRGZWVDb2xsZWN0aW9uKFxuICB0cmFuc2FjdGlvbklkOiBzdHJpbmcsXG4gIGZlZVR5cGU6IHN0cmluZyxcbiAgb3JpZ2luYWxBbW91bnQ6IG51bWJlcixcbiAgZmVlU2V0dGluZ3M6IEFkbWluRmVlU2V0dGluZ3MsXG4gIGZlZUFtb3VudDogbnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGZlZUNvbGxlY3Rpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFkbWluX2ZlZV9jb2xsZWN0aW9uc1wiKSB8fCBcIltdXCIpXG5cbiAgY29uc3QgZmVlQ29sbGVjdGlvbiA9IHtcbiAgICBpZDogYGZlZV8ke2dlbmVyYXRlVW5pcXVlSWQoKX1gLFxuICAgIHRyYW5zYWN0aW9uSWQsXG4gICAgZmVlVHlwZSxcbiAgICBvcmlnaW5hbEFtb3VudCxcbiAgICBmZWVQZXJjZW50YWdlOiBmZWVTZXR0aW5ncy5mZWVQZXJjZW50YWdlLFxuICAgIGZlZUZpeGVkOiBmZWVTZXR0aW5ncy5mZWVGaXhlZCxcbiAgICBmZWVBbW91bnQsXG4gICAgY29sbGVjdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIGZlZUNvbGxlY3Rpb25zLnB1c2goZmVlQ29sbGVjdGlvbilcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJhZG1pbl9mZWVfY29sbGVjdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkoZmVlQ29sbGVjdGlvbnMpKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXBjb21pbmdQYXltZW50cyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UGF5bWVudFNjaGVkdWxlW10+IHtcbiAgY29uc3Qgc2NoZWR1bGVzID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInBheW1lbnRfc2NoZWR1bGVzXCIpIHx8IFwiW11cIilcbiAgcmV0dXJuIHNjaGVkdWxlc1xuICAgIC5maWx0ZXIoKHM6IFBheW1lbnRTY2hlZHVsZSkgPT4gcy51c2VySWQgPT09IHVzZXJJZCAmJiBzLnN0YXR1cyA9PT0gXCJzY2hlZHVsZWRcIilcbiAgICAuc29ydChcbiAgICAgIChhOiBQYXltZW50U2NoZWR1bGUsIGI6IFBheW1lbnRTY2hlZHVsZSkgPT5cbiAgICAgICAgbmV3IERhdGUoYS5zY2hlZHVsZWREYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLnNjaGVkdWxlZERhdGUpLmdldFRpbWUoKSxcbiAgICApXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZW5kaW5nUGF5bWVudHModXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPFdhbGxldFRyYW5zYWN0aW9uW10+IHtcbiAgcmV0dXJuIGdldFRyYW5zYWN0aW9ucyhgd2FsbGV0XyR7dXNlcklkfWAsIHsgc3RhdHVzOiBcInBlbmRpbmdcIiB9KVxufVxuXG5pbXBvcnQgeyBjcmVhdGVOb3RpZmljYXRpb24gfSBmcm9tIFwiLi9ub3RpZmljYXRpb25zXCJcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZFdhbGxldFRyYW5zYWN0aW9uKGRhdGE6IHtcbiAgdXNlcklkOiBzdHJpbmdcbiAgdHlwZTogXCJkZXBvc2l0XCIgfCBcIndpdGhkcmF3YWxcIiB8IFwicGF5bWVudFwiIHwgXCJlYXJuaW5nXCIgfCBcInJlZnVuZFwiXG4gIGFtb3VudDogbnVtYmVyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgcmVmZXJlbmNlSWQ/OiBzdHJpbmdcbiAgcmVmZXJlbmNlVHlwZT86IHN0cmluZ1xuICBiYWxhbmNlVHlwZT86IFwiZGVwb3NpdFwiIHwgXCJlYXJuaW5nc1wiXG59KTogUHJvbWlzZTxXYWxsZXRUcmFuc2FjdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogU3RhcnRpbmcgdHJhbnNhY3Rpb24gZm9yIHVzZXI6XCIsIGRhdGEudXNlcklkKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IFRyYW5zYWN0aW9uIHR5cGU6XCIsIGRhdGEudHlwZSwgXCJBbW91bnQ6XCIsIGRhdGEuYW1vdW50KVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IERlc2NyaXB0aW9uOlwiLCBkYXRhLmRlc2NyaXB0aW9uKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IFJlZmVyZW5jZSBJRDpcIiwgZGF0YS5yZWZlcmVuY2VJZClcblxuICBpZiAoZGF0YS5yZWZlcmVuY2VJZCkge1xuICAgIGNvbnN0IGV4aXN0aW5nVHJhbnNhY3Rpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIndhbGxldF90cmFuc2FjdGlvbnNcIikgfHwgXCJbXVwiKVxuICAgIGNvbnN0IGR1cGxpY2F0ZVRyYW5zYWN0aW9uID0gZXhpc3RpbmdUcmFuc2FjdGlvbnMuZmluZChcbiAgICAgICh0OiBXYWxsZXRUcmFuc2FjdGlvbikgPT5cbiAgICAgICAgdC5yZWZlcmVuY2VJZCA9PT0gZGF0YS5yZWZlcmVuY2VJZCAmJiB0LnJlZmVyZW5jZVR5cGUgPT09IGRhdGEucmVmZXJlbmNlVHlwZSAmJiB0LnN0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIixcbiAgICApXG5cbiAgICBpZiAoZHVwbGljYXRlVHJhbnNhY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbdjBdIOKaoO+4jyBXQUxMRVQ6IER1cGxpY2F0ZSB0cmFuc2FjdGlvbiBwcmV2ZW50ZWQgZm9yIHJlZmVyZW5jZUlkOiAke2RhdGEucmVmZXJlbmNlSWR9YClcbiAgICAgIGNvbnNvbGUubG9nKGBbdjBdIOKaoO+4jyBXQUxMRVQ6IEV4aXN0aW5nIHRyYW5zYWN0aW9uIElEOiAke2R1cGxpY2F0ZVRyYW5zYWN0aW9uLmlkfWApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHdpdGggcmVmZXJlbmNlIElEICR7ZGF0YS5yZWZlcmVuY2VJZH0gYWxyZWFkeSBleGlzdHNgKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhbGxldCA9IGF3YWl0IGdldFdhbGxldChkYXRhLnVzZXJJZClcbiAgY29uc3QgYmFsYW5jZVR5cGUgPSBkYXRhLmJhbGFuY2VUeXBlIHx8IChkYXRhLnR5cGUgPT09IFwiZWFybmluZ1wiID8gXCJlYXJuaW5nc1wiIDogXCJkZXBvc2l0XCIpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgV0FMTEVUOiBDdXJyZW50IHdhbGxldCBzdGF0ZSBiZWZvcmUgdHJhbnNhY3Rpb246XCIpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogLSBFYXJuaW5ncyBiYWxhbmNlOlwiLCB3YWxsZXQuZWFybmluZ3NCYWxhbmNlKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IC0gRGVwb3NpdCBiYWxhbmNlOlwiLCB3YWxsZXQuZGVwb3NpdEJhbGFuY2UpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogLSBUb3RhbCBlYXJuZWQ6XCIsIHdhbGxldC50b3RhbEVhcm5lZClcblxuICBjb25zdCBuZXdUcmFuc2FjdGlvbjogV2FsbGV0VHJhbnNhY3Rpb24gPSB7XG4gICAgaWQ6IGB0eG5fJHtnZW5lcmF0ZVVuaXF1ZUlkKCl9YCxcbiAgICB3YWxsZXRJZDogd2FsbGV0LmlkLFxuICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICBhbW91bnQ6IGRhdGEuYW1vdW50LFxuICAgIGZlZUFtb3VudDogMCxcbiAgICBuZXRBbW91bnQ6IGRhdGEuYW1vdW50LFxuICAgIGJhbGFuY2VUeXBlLFxuICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uLFxuICAgIHJlZmVyZW5jZUlkOiBkYXRhLnJlZmVyZW5jZUlkLFxuICAgIHJlZmVyZW5jZVR5cGU6IGRhdGEucmVmZXJlbmNlVHlwZSxcbiAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cblxuICAvLyBVcGRhdGUgd2FsbGV0IGJhbGFuY2UgYmFzZWQgb24gdHJhbnNhY3Rpb24gdHlwZSBhbmQgYmFsYW5jZSB0eXBlXG4gIGNvbnN0IHdhbGxldHMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0c1wiKSB8fCBcInt9XCIpXG5cbiAgaWYgKGRhdGEudHlwZSA9PT0gXCJlYXJuaW5nXCIpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IEFkZGluZ1wiLCBkYXRhLmFtb3VudCwgXCJ0byBlYXJuaW5ncyBiYWxhbmNlXCIpXG4gICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlICs9IGRhdGEuYW1vdW50XG4gICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0udG90YWxFYXJuZWQgKz0gZGF0YS5hbW91bnRcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IE5ldyBlYXJuaW5ncyBiYWxhbmNlOlwiLCB3YWxsZXRzW2RhdGEudXNlcklkXS5lYXJuaW5nc0JhbGFuY2UpXG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgV0FMTEVUOiBOZXcgdG90YWwgZWFybmVkOlwiLCB3YWxsZXRzW2RhdGEudXNlcklkXS50b3RhbEVhcm5lZClcbiAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFwiZGVwb3NpdFwiKSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgV0FMTEVUOiBBZGRpbmdcIiwgZGF0YS5hbW91bnQsIFwidG8gZGVwb3NpdCBiYWxhbmNlXCIpXG4gICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZGVwb3NpdEJhbGFuY2UgKz0gZGF0YS5hbW91bnRcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IE5ldyBkZXBvc2l0IGJhbGFuY2U6XCIsIHdhbGxldHNbZGF0YS51c2VySWRdLmRlcG9zaXRCYWxhbmNlKVxuICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gXCJ3aXRoZHJhd2FsXCIpIHtcbiAgICBjb25zdCB3aXRoZHJhd0Ftb3VudCA9IE1hdGguYWJzKGRhdGEuYW1vdW50KVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogU3VidHJhY3RpbmdcIiwgd2l0aGRyYXdBbW91bnQsIFwiZnJvbSBlYXJuaW5ncyBiYWxhbmNlXCIpXG4gICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlIC09IHdpdGhkcmF3QW1vdW50XG4gICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0udG90YWxTcGVudCArPSB3aXRoZHJhd0Ftb3VudFxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogTmV3IGVhcm5pbmdzIGJhbGFuY2U6XCIsIHdhbGxldHNbZGF0YS51c2VySWRdLmVhcm5pbmdzQmFsYW5jZSlcbiAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFwicGF5bWVudFwiKSB7XG4gICAgY29uc3QgcGF5bWVudEFtb3VudCA9IE1hdGguYWJzKGRhdGEuYW1vdW50KVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogU3VidHJhY3RpbmdcIiwgcGF5bWVudEFtb3VudCwgXCJmcm9tIGRlcG9zaXQgYmFsYW5jZSBmb3IgcGF5bWVudFwiKVxuICAgIHdhbGxldHNbZGF0YS51c2VySWRdLmRlcG9zaXRCYWxhbmNlIC09IHBheW1lbnRBbW91bnRcbiAgICB3YWxsZXRzW2RhdGEudXNlcklkXS50b3RhbFNwZW50ICs9IHBheW1lbnRBbW91bnRcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBXQUxMRVQ6IE5ldyBkZXBvc2l0IGJhbGFuY2U6XCIsIHdhbGxldHNbZGF0YS51c2VySWRdLmRlcG9zaXRCYWxhbmNlKVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogTmV3IHRvdGFsIHNwZW50OlwiLCB3YWxsZXRzW2RhdGEudXNlcklkXS50b3RhbFNwZW50KVxuICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gXCJyZWZ1bmRcIikge1xuICAgIGNvbnN0IHJlZnVuZEFtb3VudCA9IE1hdGguYWJzKGRhdGEuYW1vdW50KVxuICAgIGlmIChiYWxhbmNlVHlwZSA9PT0gXCJkZXBvc2l0XCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogQWRkaW5nXCIsIHJlZnVuZEFtb3VudCwgXCJyZWZ1bmQgdG8gZGVwb3NpdCBiYWxhbmNlXCIpXG4gICAgICB3YWxsZXRzW2RhdGEudXNlcklkXS5kZXBvc2l0QmFsYW5jZSArPSByZWZ1bmRBbW91bnRcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogTmV3IGRlcG9zaXQgYmFsYW5jZTpcIiwgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZGVwb3NpdEJhbGFuY2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogQWRkaW5nXCIsIHJlZnVuZEFtb3VudCwgXCJyZWZ1bmQgdG8gZWFybmluZ3MgYmFsYW5jZVwiKVxuICAgICAgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlICs9IHJlZnVuZEFtb3VudFxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgV0FMTEVUOiBOZXcgZWFybmluZ3MgYmFsYW5jZTpcIiwgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlKVxuICAgIH1cbiAgfVxuXG4gIHdhbGxldHNbZGF0YS51c2VySWRdLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIndhbGxldHNcIiwgSlNPTi5zdHJpbmdpZnkod2FsbGV0cykpXG5cbiAgLy8gU2F2ZSB0cmFuc2FjdGlvblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid2FsbGV0X3RyYW5zYWN0aW9uc1wiKSB8fCBcIltdXCIpXG4gIHRyYW5zYWN0aW9ucy5wdXNoKG5ld1RyYW5zYWN0aW9uKVxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIndhbGxldF90cmFuc2FjdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb25zKSlcblxuICB0cnkge1xuICAgIGNvbnN0IG5vdGlmaWNhdGlvblRpdGxlID0gZ2V0VHJhbnNhY3Rpb25Ob3RpZmljYXRpb25UaXRsZShkYXRhLnR5cGUsIGRhdGEuYW1vdW50KVxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbkRlc2NyaXB0aW9uID0gZGF0YS5kZXNjcmlwdGlvblxuXG4gICAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXG4gICAgICB0eXBlOiBcInBheW1lbnRcIixcbiAgICAgIHRpdGxlOiBub3RpZmljYXRpb25UaXRsZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBub3RpZmljYXRpb25EZXNjcmlwdGlvbixcbiAgICAgIGFjdGlvblVybDogXCIvZGFzaGJvYXJkL3dhbGxldFwiLFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UlCBOT1RJRklDQVRJT046IENyZWF0ZWQgdHJhbnNhY3Rpb24gbm90aWZpY2F0aW9uIGZvciB1c2VyOlwiLCBkYXRhLnVzZXJJZClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDinYwgTk9USUZJQ0FUSU9OOiBGYWlsZWQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpXG4gIH1cblxuICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIFdBTExFVDogVHJhbnNhY3Rpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFcIilcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgV0FMTEVUOiBUcmFuc2FjdGlvbiBJRDpcIiwgbmV3VHJhbnNhY3Rpb24uaWQpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIFdBTExFVDogRmluYWwgZWFybmluZ3MgYmFsYW5jZTpcIiwgd2FsbGV0c1tkYXRhLnVzZXJJZF0uZWFybmluZ3NCYWxhbmNlKVxuXG4gIHJldHVybiBuZXdUcmFuc2FjdGlvblxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbk5vdGlmaWNhdGlvblRpdGxlKHR5cGU6IHN0cmluZywgYW1vdW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBhYnNBbW91bnQgPSBNYXRoLmFicyhhbW91bnQpXG4gIGNvbnN0IGZvcm1hdHRlZEFtb3VudCA9IGAkJHthYnNBbW91bnQudG9GaXhlZCgyKX1gXG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImVhcm5pbmdcIjpcbiAgICAgIHJldHVybiBg8J+SsCBFYXJuaW5ncyBBZGRlZDogJHtmb3JtYXR0ZWRBbW91bnR9YFxuICAgIGNhc2UgXCJkZXBvc2l0XCI6XG4gICAgICByZXR1cm4gYPCfkrMgRGVwb3NpdCBTdWNjZXNzZnVsOiAke2Zvcm1hdHRlZEFtb3VudH1gXG4gICAgY2FzZSBcIndpdGhkcmF3YWxcIjpcbiAgICAgIHJldHVybiBg8J+PpiBXaXRoZHJhd2FsIFByb2Nlc3NlZDogJHtmb3JtYXR0ZWRBbW91bnR9YFxuICAgIGNhc2UgXCJwYXltZW50XCI6XG4gICAgICByZXR1cm4gYPCfkrggUGF5bWVudCBNYWRlOiAke2Zvcm1hdHRlZEFtb3VudH1gXG4gICAgY2FzZSBcInJlZnVuZFwiOlxuICAgICAgcmV0dXJuIGDwn5SEIFJlZnVuZCBSZWNlaXZlZDogJHtmb3JtYXR0ZWRBbW91bnR9YFxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYPCfkrAgVHJhbnNhY3Rpb246ICR7Zm9ybWF0dGVkQW1vdW50fWBcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUaXBCYWxhbmNlKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdGlwQW1vdW50OiBudW1iZXIsXG4pOiBQcm9taXNlPHsgdmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCBnZXRXYWxsZXQodXNlcklkKVxuXG4gICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgc3VmZmljaWVudCBkZXBvc2l0IGJhbGFuY2UgZm9yIHRpcFxuICAgIGlmICh3YWxsZXQuZGVwb3NpdEJhbGFuY2UgPCB0aXBBbW91bnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGBJbnN1ZmZpY2llbnQgZGVwb3NpdCBiYWxhbmNlLiBSZXF1aXJlZDogJCR7dGlwQW1vdW50LnRvRml4ZWQoMil9LCBBdmFpbGFibGU6ICQke3dhbGxldC5kZXBvc2l0QmFsYW5jZS50b0ZpeGVkKDIpfWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0IHRpcCBzZXR0aW5ncyB0byBjaGVjayBsaW1pdHNcbiAgICBjb25zdCB0aXBTZXR0aW5ncyA9IGF3YWl0IGdldEFkbWluRmVlU2V0dGluZ3MoXCJ0aXBcIilcblxuICAgIGlmICh0aXBTZXR0aW5ncy5pc0FjdGl2ZSkge1xuICAgICAgLy8gQ2hlY2sgbWluaW11bSB0aXBcbiAgICAgIGlmICh0aXBBbW91bnQgPCB0aXBTZXR0aW5ncy5taW5pbXVtRmVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgTWluaW11bSB0aXAgYW1vdW50IGlzICQke3RpcFNldHRpbmdzLm1pbmltdW1GZWUudG9GaXhlZCgyKX1gLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIG1heGltdW0gdGlwXG4gICAgICBpZiAodGlwU2V0dGluZ3MubWF4aW11bUZlZSAmJiB0aXBBbW91bnQgPiB0aXBTZXR0aW5ncy5tYXhpbXVtRmVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgTWF4aW11bSB0aXAgYW1vdW50IGlzICQke3RpcFNldHRpbmdzLm1heGltdW1GZWUudG9GaXhlZCgyKX1gLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm9yIHZhbGlkYXRpbmcgdGlwIGJhbGFuY2U6XCIsIGVycm9yKVxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZmFsc2UsXG4gICAgICBlcnJvcjogXCJGYWlsZWQgdG8gdmFsaWRhdGUgdGlwIGJhbGFuY2VcIixcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NUaXBQYXltZW50KGRhdGE6IHtcbiAgZW1wbG95ZXJJZDogc3RyaW5nXG4gIHdvcmtlcklkOiBzdHJpbmdcbiAgdGlwQW1vdW50OiBudW1iZXJcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICByZWZlcmVuY2VJZDogc3RyaW5nXG59KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyB0cmFuc2FjdGlvbnM/OiBXYWxsZXRUcmFuc2FjdGlvbltdIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+OgSBUSVA6IFByb2Nlc3NpbmcgdGlwIHBheW1lbnQ6XCIsIGRhdGEudGlwQW1vdW50LCBcImZyb21cIiwgZGF0YS5lbXBsb3llcklkLCBcInRvXCIsIGRhdGEud29ya2VySWQpXG5cbiAgICAvLyBWYWxpZGF0ZSB0aXAgYmFsYW5jZSBmaXJzdFxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB2YWxpZGF0ZVRpcEJhbGFuY2UoZGF0YS5lbXBsb3llcklkLCBkYXRhLnRpcEFtb3VudClcbiAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogdmFsaWRhdGlvbi5lcnJvciB9XG4gICAgfVxuXG4gICAgY29uc3QgdGlwU2V0dGluZ3MgPSBhd2FpdCBnZXRBZG1pbkZlZVNldHRpbmdzKFwidGlwXCIpXG4gICAgbGV0IGZlZUFtb3VudCA9IDBcblxuICAgIGlmICh0aXBTZXR0aW5ncy5pc0FjdGl2ZSkge1xuICAgICAgZmVlQW1vdW50ID0gY2FsY3VsYXRlRmVlKGRhdGEudGlwQW1vdW50LCB0aXBTZXR0aW5ncylcbiAgICB9XG5cbiAgICBjb25zdCBuZXRUaXBBbW91bnQgPSBkYXRhLnRpcEFtb3VudCAtIGZlZUFtb3VudFxuXG4gICAgLy8gRGVkdWN0IHRpcCBhbW91bnQgZnJvbSBlbXBsb3llcidzIGRlcG9zaXQgYmFsYW5jZVxuICAgIGNvbnN0IGVtcGxveWVyVHJhbnNhY3Rpb24gPSBhd2FpdCBhZGRXYWxsZXRUcmFuc2FjdGlvbih7XG4gICAgICB1c2VySWQ6IGRhdGEuZW1wbG95ZXJJZCxcbiAgICAgIHR5cGU6IFwicGF5bWVudFwiLFxuICAgICAgYW1vdW50OiAtZGF0YS50aXBBbW91bnQsXG4gICAgICBkZXNjcmlwdGlvbjogYFRpcCBwYXltZW50OiAke2RhdGEuZGVzY3JpcHRpb259JHtmZWVBbW91bnQgPiAwID8gYCAoRmVlOiAkJHtmZWVBbW91bnQudG9GaXhlZCgyKX0pYCA6IFwiXCJ9YCxcbiAgICAgIHJlZmVyZW5jZUlkOiBkYXRhLnJlZmVyZW5jZUlkLFxuICAgICAgcmVmZXJlbmNlVHlwZTogXCJ0aXBfcGF5bWVudFwiLFxuICAgICAgYmFsYW5jZVR5cGU6IFwiZGVwb3NpdFwiLFxuICAgIH0pXG5cbiAgICAvLyBBZGQgdGlwIHRvIHdvcmtlcidzIGVhcm5pbmdzIGJhbGFuY2VcbiAgICBjb25zdCB3b3JrZXJUcmFuc2FjdGlvbiA9IGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKHtcbiAgICAgIHVzZXJJZDogZGF0YS53b3JrZXJJZCxcbiAgICAgIHR5cGU6IFwiZWFybmluZ1wiLFxuICAgICAgYW1vdW50OiBuZXRUaXBBbW91bnQsXG4gICAgICBkZXNjcmlwdGlvbjogYFRpcCByZWNlaXZlZDogJHtkYXRhLmRlc2NyaXB0aW9ufWAsXG4gICAgICByZWZlcmVuY2VJZDogZGF0YS5yZWZlcmVuY2VJZCxcbiAgICAgIHJlZmVyZW5jZVR5cGU6IFwidGlwXCIsXG4gICAgICBiYWxhbmNlVHlwZTogXCJlYXJuaW5nc1wiLFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIFRJUDogVGlwIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHkhXCIpXG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgVElQOiBFbXBsb3llciBjaGFyZ2VkOlwiLCBkYXRhLnRpcEFtb3VudCwgXCJXb3JrZXIgcmVjZWl2ZWQ6XCIsIG5ldFRpcEFtb3VudCwgXCJGZWU6XCIsIGZlZUFtb3VudClcblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdHJhbnNhY3Rpb25zOiBbZW1wbG95ZXJUcmFuc2FjdGlvbiwgd29ya2VyVHJhbnNhY3Rpb25dLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDinYwgVElQOiBGYWlsZWQgdG8gcHJvY2VzcyB0aXAgcGF5bWVudDpcIiwgZXJyb3IpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gcHJvY2VzcyB0aXAgcGF5bWVudFwiLFxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImdldFdhbGxldCIsInVzZXJJZCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIndhbGxldHMiLCJKU09OIiwicGFyc2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwibmV3V2FsbGV0IiwiaWQiLCJiYWxhbmNlIiwiZGVwb3NpdEJhbGFuY2UiLCJlYXJuaW5nc0JhbGFuY2UiLCJwZW5kaW5nQmFsYW5jZSIsInRvdGFsRWFybmVkIiwidG90YWxTcGVudCIsInVwY29taW5nUGF5bWVudHMiLCJwZW5kaW5nUGF5bWVudHMiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0VHJhbnNhY3Rpb25zIiwid2FsbGV0SWQiLCJmaWx0ZXJzIiwidHJhbnNhY3Rpb25zIiwiZmlsdGVyZWRUcmFuc2FjdGlvbnMiLCJmaWx0ZXIiLCJ0IiwidHlwZSIsInN0YXR1cyIsImxpbWl0Iiwic2xpY2UiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZ2V0V2FsbGV0VHJhbnNhY3Rpb25zIiwid2FsbGV0IiwiZ2V0UGF5bWVudE1ldGhvZHMiLCJwYXltZW50TWV0aG9kcyIsImdlbmVyYXRlVW5pcXVlSWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiTWF0aCIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiY3JlYXRlRGVwb3NpdCIsImRhdGEiLCJmZWVTZXR0aW5ncyIsImdldEFkbWluRmVlU2V0dGluZ3MiLCJmZWVBbW91bnQiLCJjYWxjdWxhdGVGZWUiLCJhbW91bnQiLCJuZXRBbW91bnQiLCJuZXdUcmFuc2FjdGlvbiIsImJhbGFuY2VUeXBlIiwiZGVzY3JpcHRpb24iLCJ0b0ZpeGVkIiwicHVzaCIsInJlY29yZEZlZUNvbGxlY3Rpb24iLCJjcmVhdGVXaXRoZHJhd2FsIiwiRXJyb3IiLCJhZGRQYXltZW50TWV0aG9kIiwibWV0aG9kIiwibmV3TWV0aG9kIiwiYWRkRWFybmluZ3MiLCJyZWZlcmVuY2VJZCIsInJlZmVyZW5jZVR5cGUiLCJmZWVUeXBlIiwiZGVmYXVsdFNldHRpbmdzIiwiZmVlUGVyY2VudGFnZSIsImZlZUZpeGVkIiwibWluaW11bUZlZSIsIm1heGltdW1GZWUiLCJ1bmRlZmluZWQiLCJpc0FjdGl2ZSIsInVwZGF0ZUFkbWluRmVlU2V0dGluZ3MiLCJzZXR0aW5ncyIsImZlZSIsInJvdW5kIiwidHJhbnNhY3Rpb25JZCIsIm9yaWdpbmFsQW1vdW50IiwiZmVlQ29sbGVjdGlvbnMiLCJmZWVDb2xsZWN0aW9uIiwiY29sbGVjdGVkQXQiLCJnZXRVcGNvbWluZ1BheW1lbnRzIiwic2NoZWR1bGVzIiwicyIsInNjaGVkdWxlZERhdGUiLCJnZXRQZW5kaW5nUGF5bWVudHMiLCJjcmVhdGVOb3RpZmljYXRpb24iLCJhZGRXYWxsZXRUcmFuc2FjdGlvbiIsImNvbnNvbGUiLCJsb2ciLCJleGlzdGluZ1RyYW5zYWN0aW9ucyIsImR1cGxpY2F0ZVRyYW5zYWN0aW9uIiwiZmluZCIsIndpdGhkcmF3QW1vdW50IiwiYWJzIiwicGF5bWVudEFtb3VudCIsInJlZnVuZEFtb3VudCIsIm5vdGlmaWNhdGlvblRpdGxlIiwiZ2V0VHJhbnNhY3Rpb25Ob3RpZmljYXRpb25UaXRsZSIsIm5vdGlmaWNhdGlvbkRlc2NyaXB0aW9uIiwidGl0bGUiLCJhY3Rpb25VcmwiLCJlcnJvciIsImFic0Ftb3VudCIsImZvcm1hdHRlZEFtb3VudCIsInZhbGlkYXRlVGlwQmFsYW5jZSIsInRpcEFtb3VudCIsInZhbGlkIiwidGlwU2V0dGluZ3MiLCJwcm9jZXNzVGlwUGF5bWVudCIsImVtcGxveWVySWQiLCJ3b3JrZXJJZCIsInZhbGlkYXRpb24iLCJzdWNjZXNzIiwibmV0VGlwQW1vdW50IiwiZW1wbG95ZXJUcmFuc2FjdGlvbiIsIndvcmtlclRyYW5zYWN0aW9uIiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/wallet.ts\n"));

/***/ })

}]);