"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_notifications_ts"],{

/***/ "(app-pages-browser)/./lib/notifications.ts":
/*!******************************!*\
  !*** ./lib/notifications.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNotification: () => (/* binding */ createNotification),\n/* harmony export */   getRecentActivity: () => (/* binding */ getRecentActivity),\n/* harmony export */   getUnreadNotificationCount: () => (/* binding */ getUnreadNotificationCount),\n/* harmony export */   getUserNotifications: () => (/* binding */ getUserNotifications),\n/* harmony export */   markAllNotificationsAsRead: () => (/* binding */ markAllNotificationsAsRead),\n/* harmony export */   markNotificationAsRead: () => (/* binding */ markNotificationAsRead)\n/* harmony export */ });\n// Notification system for real-time user updates\nconst NOTIFICATIONS_STORAGE_KEY = \"marketplace-notifications\";\nconst getStoredNotifications = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(NOTIFICATIONS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveNotifications = (notifications)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(NOTIFICATIONS_STORAGE_KEY, JSON.stringify(notifications));\n    } catch (error) {\n        console.error(\"Failed to save notifications:\", error);\n    }\n};\nasync function createNotification(data) {\n    const newNotification = {\n        id: \"notif_\".concat(Date.now()),\n        userId: data.userId,\n        type: data.type,\n        title: data.title,\n        description: data.description,\n        timestamp: new Date().toISOString(),\n        read: false,\n        actionUrl: data.actionUrl\n    };\n    const notifications = getStoredNotifications();\n    notifications.push(newNotification);\n    saveNotifications(notifications);\n    return newNotification;\n}\nasync function getUserNotifications(userId) {\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId).sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n}\nasync function markNotificationAsRead(notificationId) {\n    const notifications = getStoredNotifications();\n    const notificationIndex = notifications.findIndex((n)=>n.id === notificationId);\n    if (notificationIndex !== -1) {\n        notifications[notificationIndex].read = true;\n        saveNotifications(notifications);\n    }\n}\nasync function markAllNotificationsAsRead(userId) {\n    const notifications = getStoredNotifications();\n    const updatedNotifications = notifications.map((n)=>n.userId === userId ? {\n            ...n,\n            read: true\n        } : n);\n    saveNotifications(updatedNotifications);\n}\nasync function getRecentActivity(userId) {\n    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId).sort((a, b)=>new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).slice(0, limit);\n}\nasync function getUnreadNotificationCount(userId) {\n    const notifications = getStoredNotifications();\n    return notifications.filter((n)=>n.userId === userId && !n.read).length;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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c291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2xpYi9ub3RpZmljYXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE5vdGlmaWNhdGlvbiBzeXN0ZW0gZm9yIHJlYWwtdGltZSB1c2VyIHVwZGF0ZXNcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uIHtcbiAgaWQ6IHN0cmluZ1xuICB1c2VySWQ6IHN0cmluZ1xuICB0eXBlOiBcImpvYlwiIHwgXCJtZXNzYWdlXCIgfCBcInBheW1lbnRcIiB8IFwic3lzdGVtXCJcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIHJlYWQ6IGJvb2xlYW5cbiAgYWN0aW9uVXJsPzogc3RyaW5nXG59XG5cbmNvbnN0IE5PVElGSUNBVElPTlNfU1RPUkFHRV9LRVkgPSBcIm1hcmtldHBsYWNlLW5vdGlmaWNhdGlvbnNcIlxuXG5jb25zdCBnZXRTdG9yZWROb3RpZmljYXRpb25zID0gKCk6IE5vdGlmaWNhdGlvbltdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKE5PVElGSUNBVElPTlNfU1RPUkFHRV9LRVkpXG4gICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmNvbnN0IHNhdmVOb3RpZmljYXRpb25zID0gKG5vdGlmaWNhdGlvbnM6IE5vdGlmaWNhdGlvbltdKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShOT1RJRklDQVRJT05TX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShub3RpZmljYXRpb25zKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbm90aWZpY2F0aW9uczpcIiwgZXJyb3IpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvbihkYXRhOiB7XG4gIHVzZXJJZDogc3RyaW5nXG4gIHR5cGU6IFwiam9iXCIgfCBcIm1lc3NhZ2VcIiB8IFwicGF5bWVudFwiIHwgXCJzeXN0ZW1cIlxuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgYWN0aW9uVXJsPzogc3RyaW5nXG59KTogUHJvbWlzZTxOb3RpZmljYXRpb24+IHtcbiAgY29uc3QgbmV3Tm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24gPSB7XG4gICAgaWQ6IGBub3RpZl8ke0RhdGUubm93KCl9YCxcbiAgICB1c2VySWQ6IGRhdGEudXNlcklkLFxuICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICByZWFkOiBmYWxzZSxcbiAgICBhY3Rpb25Vcmw6IGRhdGEuYWN0aW9uVXJsLFxuICB9XG5cbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICBub3RpZmljYXRpb25zLnB1c2gobmV3Tm90aWZpY2F0aW9uKVxuICBzYXZlTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb25zKVxuXG4gIHJldHVybiBuZXdOb3RpZmljYXRpb25cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJOb3RpZmljYXRpb25zKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxOb3RpZmljYXRpb25bXT4ge1xuICBjb25zdCBub3RpZmljYXRpb25zID0gZ2V0U3RvcmVkTm90aWZpY2F0aW9ucygpXG4gIHJldHVybiBub3RpZmljYXRpb25zXG4gICAgLmZpbHRlcigobikgPT4gbi51c2VySWQgPT09IHVzZXJJZClcbiAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi50aW1lc3RhbXApLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEudGltZXN0YW1wKS5nZXRUaW1lKCkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrTm90aWZpY2F0aW9uQXNSZWFkKG5vdGlmaWNhdGlvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICBjb25zdCBub3RpZmljYXRpb25JbmRleCA9IG5vdGlmaWNhdGlvbnMuZmluZEluZGV4KChuKSA9PiBuLmlkID09PSBub3RpZmljYXRpb25JZClcblxuICBpZiAobm90aWZpY2F0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgbm90aWZpY2F0aW9uc1tub3RpZmljYXRpb25JbmRleF0ucmVhZCA9IHRydWVcbiAgICBzYXZlTm90aWZpY2F0aW9ucyhub3RpZmljYXRpb25zKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYXJrQWxsTm90aWZpY2F0aW9uc0FzUmVhZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBub3RpZmljYXRpb25zID0gZ2V0U3RvcmVkTm90aWZpY2F0aW9ucygpXG4gIGNvbnN0IHVwZGF0ZWROb3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9ucy5tYXAoKG4pID0+IChuLnVzZXJJZCA9PT0gdXNlcklkID8geyAuLi5uLCByZWFkOiB0cnVlIH0gOiBuKSlcbiAgc2F2ZU5vdGlmaWNhdGlvbnModXBkYXRlZE5vdGlmaWNhdGlvbnMpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZWNlbnRBY3Rpdml0eSh1c2VySWQ6IHN0cmluZywgbGltaXQgPSAxMCk6IFByb21pc2U8Tm90aWZpY2F0aW9uW10+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICByZXR1cm4gbm90aWZpY2F0aW9uc1xuICAgIC5maWx0ZXIoKG4pID0+IG4udXNlcklkID09PSB1c2VySWQpXG4gICAgLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIudGltZXN0YW1wKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpKVxuICAgIC5zbGljZSgwLCBsaW1pdClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVucmVhZE5vdGlmaWNhdGlvbkNvdW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IGdldFN0b3JlZE5vdGlmaWNhdGlvbnMoKVxuICByZXR1cm4gbm90aWZpY2F0aW9ucy5maWx0ZXIoKG4pID0+IG4udXNlcklkID09PSB1c2VySWQgJiYgIW4ucmVhZCkubGVuZ3RoXG59XG4iXSwibmFtZXMiOlsiTk9USUZJQ0FUSU9OU19TVE9SQUdFX0tFWSIsImdldFN0b3JlZE5vdGlmaWNhdGlvbnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2F2ZU5vdGlmaWNhdGlvbnMiLCJub3RpZmljYXRpb25zIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsImRhdGEiLCJuZXdOb3RpZmljYXRpb24iLCJpZCIsIkRhdGUiLCJub3ciLCJ1c2VySWQiLCJ0eXBlIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwicmVhZCIsImFjdGlvblVybCIsInB1c2giLCJnZXRVc2VyTm90aWZpY2F0aW9ucyIsImZpbHRlciIsIm4iLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsIm5vdGlmaWNhdGlvbklkIiwibm90aWZpY2F0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJtYXJrQWxsTm90aWZpY2F0aW9uc0FzUmVhZCIsInVwZGF0ZWROb3RpZmljYXRpb25zIiwibWFwIiwiZ2V0UmVjZW50QWN0aXZpdHkiLCJsaW1pdCIsInNsaWNlIiwiZ2V0VW5yZWFkTm90aWZpY2F0aW9uQ291bnQiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/notifications.ts\n"));

/***/ })

}]);