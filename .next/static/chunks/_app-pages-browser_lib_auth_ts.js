"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_auth_ts"],{

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activateUser: () => (/* binding */ activateUser),\n/* harmony export */   clearStoredUser: () => (/* binding */ clearStoredUser),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getNextUserId: () => (/* binding */ getNextUserId),\n/* harmony export */   getStoredUser: () => (/* binding */ getStoredUser),\n/* harmony export */   getUser: () => (/* binding */ getUser),\n/* harmony export */   initializeDefaultUsers: () => (/* binding */ initializeDefaultUsers),\n/* harmony export */   saveUserToDatabase: () => (/* binding */ saveUserToDatabase),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   signUp: () => (/* binding */ signUp),\n/* harmony export */   storeUser: () => (/* binding */ storeUser),\n/* harmony export */   suspendUserWithReason: () => (/* binding */ suspendUserWithReason),\n/* harmony export */   toggleUserSuspension: () => (/* binding */ toggleUserSuspension),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n// Authentication utilities and types\nfunction getAllUsers() {\n    if (false) {}\n    const stored = localStorage.getItem(\"users_database\");\n    return stored ? JSON.parse(stored) : [];\n}\nfunction saveUserToDatabase(user) {\n    if (false) {}\n    const users = getAllUsers();\n    const existingIndex = users.findIndex((u)=>u.email === user.email);\n    if (existingIndex >= 0) {\n        users[existingIndex] = user;\n    } else {\n        users.push(user);\n    }\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n}\nfunction getNextUserId() {\n    const users = getAllUsers();\n    const maxId = users.reduce((max, user)=>{\n        const numId = Number.parseInt(user.id);\n        return isNaN(numId) ? max : Math.max(max, numId);\n    }, 0);\n    return String(maxId + 1).padStart(2, \"0\");\n}\nfunction initializeDefaultUsers() {\n    const users = getAllUsers();\n    if (users.length === 0) {\n        const defaultUsers = [\n            {\n                id: \"01\",\n                email: \"admin@marketplace.com\",\n                firstName: \"Admin\",\n                lastName: \"User\",\n                username: \"admin\",\n                userType: \"admin\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"02\",\n                email: \"worker1@marketplace.com\",\n                firstName: \"John\",\n                lastName: \"Worker\",\n                username: \"johnworker\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"03\",\n                email: \"employer1@marketplace.com\",\n                firstName: \"Jane\",\n                lastName: \"Employer\",\n                username: \"janeemployer\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 100,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            }\n        ];\n        defaultUsers.forEach((user)=>saveUserToDatabase(user));\n        console.log(\"[v0] âœ… Initialized default users:\", defaultUsers.map((u)=>\"\".concat(u.firstName, \" \").concat(u.lastName, \" (ID: \").concat(u.id, \")\")));\n    }\n}\n// Mock authentication functions (replace with real API calls when database is connected)\nasync function signIn(email, password) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.email === email);\n    if (!user) {\n        throw new Error(\"Invalid email or password\");\n    }\n    if (user.userType === \"suspended\") {\n        const reason = user.suspensionReason || \"No reason provided\";\n        throw new Error(\"Your account has been suspended. Reason: \".concat(reason));\n    }\n    if (email === \"admin@marketplace.com\" && password === \"admin123\") {\n        console.log(\"[v0] Admin login successful for:\", user.email);\n        return user;\n    }\n    if (password === \"password123\" || password.length >= 8) {\n        console.log(\"[v0] User login successful for:\", user.email);\n        return user;\n    }\n    throw new Error(\"Invalid email or password\");\n}\nasync function signUp(data) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (!isValidEmail(data.email)) {\n        throw new Error(\"Please enter a valid email address\");\n    }\n    if (data.password.length < 8) {\n        throw new Error(\"Password must be at least 8 characters long\");\n    }\n    if (!isValidPassword(data.password)) {\n        throw new Error(\"Password must contain at least one uppercase letter, one lowercase letter, and one number\");\n    }\n    if (data.username.length < 3) {\n        throw new Error(\"Username must be at least 3 characters long\");\n    }\n    if (!/^[a-zA-Z0-9_]+$/.test(data.username)) {\n        throw new Error(\"Username can only contain letters, numbers, and underscores\");\n    }\n    const users = getAllUsers();\n    const existingUser = users.find((u)=>u.email === data.email || u.username === data.username);\n    if (existingUser) {\n        if (existingUser.email === data.email) {\n            throw new Error(\"An account with this email already exists\");\n        } else {\n            throw new Error(\"This username is already taken\");\n        }\n    }\n    const newUser = {\n        id: getNextUserId(),\n        email: data.email,\n        firstName: data.firstName,\n        lastName: data.lastName,\n        username: data.username,\n        userType: \"user\",\n        isVerified: false,\n        deposit: 0,\n        earning: 0,\n        country: \"United States\",\n        createdAt: new Date().toISOString()\n    };\n    saveUserToDatabase(newUser);\n    return newUser;\n}\nasync function signOut() {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n}\nfunction getStoredUser() {\n    if (false) {}\n    const stored = localStorage.getItem(\"user\");\n    return stored ? JSON.parse(stored) : null;\n}\nfunction storeUser(user) {\n    if (false) {}\n    localStorage.setItem(\"user\", JSON.stringify(user));\n}\nfunction clearStoredUser() {\n    if (false) {}\n    localStorage.removeItem(\"user\");\n}\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\nfunction isValidPassword(password) {\n    // At least 8 characters, one uppercase, one lowercase, one number\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\n    return passwordRegex.test(password);\n}\nfunction updateUser(userId, updates) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        ...updates\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction toggleUserSuspension(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const user = users[userIndex];\n    // Toggle between user and suspended status (using a custom field)\n    const updatedUser = {\n        ...user,\n        isSuspended: !user.isSuspended\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction suspendUserWithReason(userId, reason, suspendedBy) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"suspended\",\n        suspensionReason: reason,\n        suspendedAt: new Date().toISOString(),\n        suspendedBy: suspendedBy\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction activateUser(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"user\",\n        suspensionReason: undefined,\n        suspendedAt: undefined,\n        suspendedBy: undefined\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nasync function getUser() {\n    // In a real implementation, this would validate JWT tokens or session cookies\n    // For now, we'll simulate getting the current user from localStorage on the client\n    // or return null on the server (since we don't have real session management)\n    if (false) {}\n    // Client-side: Get user from localStorage\n    return getStoredUser();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bEI7SUFFQSxNQUFNcUIsY0FBYztRQUNsQixHQUFHakUsS0FBSyxDQUFDZ0UsVUFBVTtRQUNuQnRDLFVBQVU7UUFDVm9CLGtCQUFrQkQ7UUFDbEJ5QixhQUFhLElBQUl0QyxPQUFPQyxXQUFXO1FBQ25Db0MsYUFBYUE7SUFDZjtJQUVBckUsS0FBSyxDQUFDZ0UsVUFBVSxHQUFHQztJQUNuQnZFLGFBQWFZLE9BQU8sQ0FBQyxrQkFBa0JWLEtBQUtXLFNBQVMsQ0FBQ1A7SUFFdEQsT0FBT2lFO0FBQ1Q7QUFFTyxTQUFTTSxhQUFhVCxNQUFjO0lBQ3pDLE1BQU05RCxRQUFRUjtJQUNkLE1BQU13RSxZQUFZaEUsTUFBTUUsU0FBUyxDQUFDLENBQUNDLElBQU1BLEVBQUVZLEVBQUUsS0FBSytDO0lBRWxELElBQUlFLGNBQWMsQ0FBQyxHQUFHO1FBQ3BCLE1BQU0sSUFBSXBCLE1BQU07SUFDbEI7SUFFQSxNQUFNcUIsY0FBYztRQUNsQixHQUFHakUsS0FBSyxDQUFDZ0UsVUFBVTtRQUNuQnRDLFVBQVU7UUFDVm9CLGtCQUFrQjBCO1FBQ2xCRixhQUFhRTtRQUNiSCxhQUFhRztJQUNmO0lBRUF4RSxLQUFLLENBQUNnRSxVQUFVLEdBQUdDO0lBQ25CdkUsYUFBYVksT0FBTyxDQUFDLGtCQUFrQlYsS0FBS1csU0FBUyxDQUFDUDtJQUV0RCxPQUFPaUU7QUFDVDtBQUVPLGVBQWVRO0lBQ3BCLDhFQUE4RTtJQUM5RSxtRkFBbUY7SUFDbkYsNkVBQTZFO0lBRTdFLElBQUksS0FBNkIsRUFBRSxFQWdCbEM7SUFFRCwwQ0FBMEM7SUFDMUMsT0FBT2xCO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3QvbGliL2F1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXV0aGVudGljYXRpb24gdXRpbGl0aWVzIGFuZCB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZpcnN0TmFtZTogc3RyaW5nXG4gIGxhc3ROYW1lOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBhdmF0YXI/OiBzdHJpbmdcbiAgdXNlclR5cGU6IFwidXNlclwiIHwgXCJhZG1pblwiIHwgXCJzdXNwZW5kZWRcIlxuICBpc1ZlcmlmaWVkOiBib29sZWFuXG4gIGRlcG9zaXQ6IG51bWJlclxuICBlYXJuaW5nOiBudW1iZXJcbiAgY291bnRyeTogc3RyaW5nXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIGlzU3VzcGVuZGVkPzogYm9vbGVhblxuICBzdXNwZW5zaW9uUmVhc29uPzogc3RyaW5nXG4gIHN1c3BlbmRlZEF0Pzogc3RyaW5nXG4gIHN1c3BlbmRlZEJ5Pzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgdXNlcjogVXNlciB8IG51bGxcbiAgaXNMb2FkaW5nOiBib29sZWFuXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVXNlcnMoKTogVXNlcltdIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuXG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIilcbiAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlVXNlclRvRGF0YWJhc2UodXNlcjogVXNlcik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IGV4aXN0aW5nSW5kZXggPSB1c2Vycy5maW5kSW5kZXgoKHUpID0+IHUuZW1haWwgPT09IHVzZXIuZW1haWwpXG5cbiAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuICAgIHVzZXJzW2V4aXN0aW5nSW5kZXhdID0gdXNlclxuICB9IGVsc2Uge1xuICAgIHVzZXJzLnB1c2godXNlcilcbiAgfVxuXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIiwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dFVzZXJJZCgpOiBzdHJpbmcge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgbWF4SWQgPSB1c2Vycy5yZWR1Y2UoKG1heCwgdXNlcikgPT4ge1xuICAgIGNvbnN0IG51bUlkID0gTnVtYmVyLnBhcnNlSW50KHVzZXIuaWQpXG4gICAgcmV0dXJuIGlzTmFOKG51bUlkKSA/IG1heCA6IE1hdGgubWF4KG1heCwgbnVtSWQpXG4gIH0sIDApXG5cbiAgcmV0dXJuIFN0cmluZyhtYXhJZCArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZURlZmF1bHRVc2VycygpOiB2b2lkIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG5cbiAgaWYgKHVzZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IGRlZmF1bHRVc2VyczogVXNlcltdID0gW1xuICAgICAge1xuICAgICAgICBpZDogXCIwMVwiLFxuICAgICAgICBlbWFpbDogXCJhZG1pbkBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgICAgZmlyc3ROYW1lOiBcIkFkbWluXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgdXNlcm5hbWU6IFwiYWRtaW5cIixcbiAgICAgICAgdXNlclR5cGU6IFwiYWRtaW5cIixcbiAgICAgICAgaXNWZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgZGVwb3NpdDogMCxcbiAgICAgICAgZWFybmluZzogMCxcbiAgICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiMDJcIixcbiAgICAgICAgZW1haWw6IFwid29ya2VyMUBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgICAgZmlyc3ROYW1lOiBcIkpvaG5cIixcbiAgICAgICAgbGFzdE5hbWU6IFwiV29ya2VyXCIsXG4gICAgICAgIHVzZXJuYW1lOiBcImpvaG53b3JrZXJcIixcbiAgICAgICAgdXNlclR5cGU6IFwidXNlclwiLFxuICAgICAgICBpc1ZlcmlmaWVkOiB0cnVlLFxuICAgICAgICBkZXBvc2l0OiAwLFxuICAgICAgICBlYXJuaW5nOiAwLFxuICAgICAgICBjb3VudHJ5OiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCIwM1wiLFxuICAgICAgICBlbWFpbDogXCJlbXBsb3llcjFAbWFya2V0cGxhY2UuY29tXCIsXG4gICAgICAgIGZpcnN0TmFtZTogXCJKYW5lXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIkVtcGxveWVyXCIsXG4gICAgICAgIHVzZXJuYW1lOiBcImphbmVlbXBsb3llclwiLFxuICAgICAgICB1c2VyVHlwZTogXCJ1c2VyXCIsXG4gICAgICAgIGlzVmVyaWZpZWQ6IHRydWUsXG4gICAgICAgIGRlcG9zaXQ6IDEwMCxcbiAgICAgICAgZWFybmluZzogMCxcbiAgICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBkZWZhdWx0VXNlcnMuZm9yRWFjaCgodXNlcikgPT4gc2F2ZVVzZXJUb0RhdGFiYXNlKHVzZXIpKVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJbdjBdIOKchSBJbml0aWFsaXplZCBkZWZhdWx0IHVzZXJzOlwiLFxuICAgICAgZGVmYXVsdFVzZXJzLm1hcCgodSkgPT4gYCR7dS5maXJzdE5hbWV9ICR7dS5sYXN0TmFtZX0gKElEOiAke3UuaWR9KWApLFxuICAgIClcbiAgfVxufVxuXG4vLyBNb2NrIGF1dGhlbnRpY2F0aW9uIGZ1bmN0aW9ucyAocmVwbGFjZSB3aXRoIHJlYWwgQVBJIGNhbGxzIHdoZW4gZGF0YWJhc2UgaXMgY29ubmVjdGVkKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBjYWxsXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuXG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB1c2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5lbWFpbCA9PT0gZW1haWwpXG5cbiAgaWYgKCF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZFwiKVxuICB9XG5cbiAgaWYgKHVzZXIudXNlclR5cGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICBjb25zdCByZWFzb24gPSB1c2VyLnN1c3BlbnNpb25SZWFzb24gfHwgXCJObyByZWFzb24gcHJvdmlkZWRcIlxuICAgIHRocm93IG5ldyBFcnJvcihgWW91ciBhY2NvdW50IGhhcyBiZWVuIHN1c3BlbmRlZC4gUmVhc29uOiAke3JlYXNvbn1gKVxuICB9XG5cbiAgaWYgKGVtYWlsID09PSBcImFkbWluQG1hcmtldHBsYWNlLmNvbVwiICYmIHBhc3N3b3JkID09PSBcImFkbWluMTIzXCIpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gQWRtaW4gbG9naW4gc3VjY2Vzc2Z1bCBmb3I6XCIsIHVzZXIuZW1haWwpXG4gICAgcmV0dXJuIHVzZXJcbiAgfVxuXG4gIGlmIChwYXNzd29yZCA9PT0gXCJwYXNzd29yZDEyM1wiIHx8IHBhc3N3b3JkLmxlbmd0aCA+PSA4KSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIFVzZXIgbG9naW4gc3VjY2Vzc2Z1bCBmb3I6XCIsIHVzZXIuZW1haWwpXG4gICAgcmV0dXJuIHVzZXJcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW1haWwgb3IgcGFzc3dvcmRcIilcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25VcChkYXRhOiB7XG4gIGVtYWlsOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBmaXJzdE5hbWU6IHN0cmluZ1xuICBsYXN0TmFtZTogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbn0pOiBQcm9taXNlPFVzZXI+IHtcbiAgLy8gU2ltdWxhdGUgQVBJIGNhbGxcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG5cbiAgaWYgKCFpc1ZhbGlkRW1haWwoZGF0YS5lbWFpbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIpXG4gIH1cblxuICBpZiAoZGF0YS5wYXNzd29yZC5sZW5ndGggPCA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMgbG9uZ1wiKVxuICB9XG5cbiAgaWYgKCFpc1ZhbGlkUGFzc3dvcmQoZGF0YS5wYXNzd29yZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHVwcGVyY2FzZSBsZXR0ZXIsIG9uZSBsb3dlcmNhc2UgbGV0dGVyLCBhbmQgb25lIG51bWJlclwiKVxuICB9XG5cbiAgaWYgKGRhdGEudXNlcm5hbWUubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXJuYW1lIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGxvbmdcIilcbiAgfVxuXG4gIGlmICghL15bYS16QS1aMC05X10rJC8udGVzdChkYXRhLnVzZXJuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXJuYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYW5kIHVuZGVyc2NvcmVzXCIpXG4gIH1cblxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgZXhpc3RpbmdVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5lbWFpbCA9PT0gZGF0YS5lbWFpbCB8fCB1LnVzZXJuYW1lID09PSBkYXRhLnVzZXJuYW1lKVxuXG4gIGlmIChleGlzdGluZ1VzZXIpIHtcbiAgICBpZiAoZXhpc3RpbmdVc2VyLmVtYWlsID09PSBkYXRhLmVtYWlsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBhY2NvdW50IHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0c1wiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHVzZXJuYW1lIGlzIGFscmVhZHkgdGFrZW5cIilcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdVc2VyOiBVc2VyID0ge1xuICAgIGlkOiBnZXROZXh0VXNlcklkKCksXG4gICAgZW1haWw6IGRhdGEuZW1haWwsXG4gICAgZmlyc3ROYW1lOiBkYXRhLmZpcnN0TmFtZSxcbiAgICBsYXN0TmFtZTogZGF0YS5sYXN0TmFtZSxcbiAgICB1c2VybmFtZTogZGF0YS51c2VybmFtZSxcbiAgICB1c2VyVHlwZTogXCJ1c2VyXCIsXG4gICAgaXNWZXJpZmllZDogZmFsc2UsXG4gICAgZGVwb3NpdDogMCxcbiAgICBlYXJuaW5nOiAwLFxuICAgIGNvdW50cnk6IFwiVW5pdGVkIFN0YXRlc1wiLCAvLyBEZWZhdWx0IHRvIFVTIGluc3RlYWQgb2YgaGFyZGNvZGVkIEJhbmdsYWRlc2hcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIHNhdmVVc2VyVG9EYXRhYmFzZShuZXdVc2VyKVxuXG4gIHJldHVybiBuZXdVc2VyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KCk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBTaW11bGF0ZSBBUEkgY2FsbFxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVkVXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlclwiKVxuICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVVc2VyKHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJcIiwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclN0b3JlZFVzZXIoKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ1c2VyXCIpXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbWFpbChlbWFpbDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskL1xuICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBBdCBsZWFzdCA4IGNoYXJhY3RlcnMsIG9uZSB1cHBlcmNhc2UsIG9uZSBsb3dlcmNhc2UsIG9uZSBudW1iZXJcbiAgY29uc3QgcGFzc3dvcmRSZWdleCA9IC9eKD89LipbYS16XSkoPz0uKltBLVpdKSg/PS4qXFxkKS57OCx9JC9cbiAgcmV0dXJuIHBhc3N3b3JkUmVnZXgudGVzdChwYXNzd29yZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVzZXIodXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VXNlcj4pOiBVc2VyIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXJJbmRleCA9IHVzZXJzLmZpbmRJbmRleCgodSkgPT4gdS5pZCA9PT0gdXNlcklkKVxuXG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0geyAuLi51c2Vyc1t1c2VySW5kZXhdLCAuLi51cGRhdGVzIH1cbiAgdXNlcnNbdXNlckluZGV4XSA9IHVwZGF0ZWRVc2VyXG5cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVVc2VyU3VzcGVuc2lvbih1c2VySWQ6IHN0cmluZyk6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXNlciA9IHVzZXJzW3VzZXJJbmRleF1cbiAgLy8gVG9nZ2xlIGJldHdlZW4gdXNlciBhbmQgc3VzcGVuZGVkIHN0YXR1cyAodXNpbmcgYSBjdXN0b20gZmllbGQpXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0ge1xuICAgIC4uLnVzZXIsXG4gICAgaXNTdXNwZW5kZWQ6ICF1c2VyLmlzU3VzcGVuZGVkLFxuICB9XG5cbiAgdXNlcnNbdXNlckluZGV4XSA9IHVwZGF0ZWRVc2VyXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIiwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKVxuXG4gIHJldHVybiB1cGRhdGVkVXNlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZFVzZXJXaXRoUmVhc29uKHVzZXJJZDogc3RyaW5nLCByZWFzb246IHN0cmluZywgc3VzcGVuZGVkQnk6IHN0cmluZyk6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZFVzZXIgPSB7XG4gICAgLi4udXNlcnNbdXNlckluZGV4XSxcbiAgICB1c2VyVHlwZTogXCJzdXNwZW5kZWRcIiBhcyBjb25zdCxcbiAgICBzdXNwZW5zaW9uUmVhc29uOiByZWFzb24sXG4gICAgc3VzcGVuZGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBzdXNwZW5kZWRCeTogc3VzcGVuZGVkQnksXG4gIH1cblxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZVVzZXIodXNlcklkOiBzdHJpbmcpOiBVc2VyIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXJJbmRleCA9IHVzZXJzLmZpbmRJbmRleCgodSkgPT4gdS5pZCA9PT0gdXNlcklkKVxuXG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0ge1xuICAgIC4uLnVzZXJzW3VzZXJJbmRleF0sXG4gICAgdXNlclR5cGU6IFwidXNlclwiIGFzIGNvbnN0LFxuICAgIHN1c3BlbnNpb25SZWFzb246IHVuZGVmaW5lZCxcbiAgICBzdXNwZW5kZWRBdDogdW5kZWZpbmVkLFxuICAgIHN1c3BlbmRlZEJ5OiB1bmRlZmluZWQsXG4gIH1cblxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyKCk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHZhbGlkYXRlIEpXVCB0b2tlbnMgb3Igc2Vzc2lvbiBjb29raWVzXG4gIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIGdldHRpbmcgdGhlIGN1cnJlbnQgdXNlciBmcm9tIGxvY2FsU3RvcmFnZSBvbiB0aGUgY2xpZW50XG4gIC8vIG9yIHJldHVybiBudWxsIG9uIHRoZSBzZXJ2ZXIgKHNpbmNlIHdlIGRvbid0IGhhdmUgcmVhbCBzZXNzaW9uIG1hbmFnZW1lbnQpXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBTZXJ2ZXItc2lkZTogSW4gYSByZWFsIGFwcCwgeW91J2QgdmFsaWRhdGUgc2Vzc2lvbiB0b2tlbnMgaGVyZVxuICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCByZXR1cm4gYSBtb2NrIGFkbWluIHVzZXIgZm9yIEFQSSBjYWxsc1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCIwMVwiLFxuICAgICAgZW1haWw6IFwiYWRtaW5AbWFya2V0cGxhY2UuY29tXCIsXG4gICAgICBmaXJzdE5hbWU6IFwiQWRtaW5cIixcbiAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgIHVzZXJuYW1lOiBcImFkbWluXCIsXG4gICAgICB1c2VyVHlwZTogXCJhZG1pblwiLFxuICAgICAgaXNWZXJpZmllZDogdHJ1ZSxcbiAgICAgIGRlcG9zaXQ6IDAsXG4gICAgICBlYXJuaW5nOiAwLFxuICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9XG4gIH1cblxuICAvLyBDbGllbnQtc2lkZTogR2V0IHVzZXIgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgcmV0dXJuIGdldFN0b3JlZFVzZXIoKVxufVxuIl0sIm5hbWVzIjpbImdldEFsbFVzZXJzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsInNhdmVVc2VyVG9EYXRhYmFzZSIsInVzZXIiLCJ1c2VycyIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJ1IiwiZW1haWwiLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImdldE5leHRVc2VySWQiLCJtYXhJZCIsInJlZHVjZSIsIm1heCIsIm51bUlkIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJpZCIsImlzTmFOIiwiTWF0aCIsIlN0cmluZyIsInBhZFN0YXJ0IiwiaW5pdGlhbGl6ZURlZmF1bHRVc2VycyIsImxlbmd0aCIsImRlZmF1bHRVc2VycyIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwidXNlcm5hbWUiLCJ1c2VyVHlwZSIsImlzVmVyaWZpZWQiLCJkZXBvc2l0IiwiZWFybmluZyIsImNvdW50cnkiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmb3JFYWNoIiwiY29uc29sZSIsImxvZyIsIm1hcCIsInNpZ25JbiIsInBhc3N3b3JkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmluZCIsIkVycm9yIiwicmVhc29uIiwic3VzcGVuc2lvblJlYXNvbiIsInNpZ25VcCIsImRhdGEiLCJpc1ZhbGlkRW1haWwiLCJpc1ZhbGlkUGFzc3dvcmQiLCJ0ZXN0IiwiZXhpc3RpbmdVc2VyIiwibmV3VXNlciIsInNpZ25PdXQiLCJnZXRTdG9yZWRVc2VyIiwic3RvcmVVc2VyIiwiY2xlYXJTdG9yZWRVc2VyIiwicmVtb3ZlSXRlbSIsImVtYWlsUmVnZXgiLCJwYXNzd29yZFJlZ2V4IiwidXBkYXRlVXNlciIsInVzZXJJZCIsInVwZGF0ZXMiLCJ1c2VySW5kZXgiLCJ1cGRhdGVkVXNlciIsInRvZ2dsZVVzZXJTdXNwZW5zaW9uIiwiaXNTdXNwZW5kZWQiLCJzdXNwZW5kVXNlcldpdGhSZWFzb24iLCJzdXNwZW5kZWRCeSIsInN1c3BlbmRlZEF0IiwiYWN0aXZhdGVVc2VyIiwidW5kZWZpbmVkIiwiZ2V0VXNlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ })

}]);