"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_jobs_ts-_30ef1"],{

/***/ "(app-pages-browser)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activateUser: () => (/* binding */ activateUser),\n/* harmony export */   clearStoredUser: () => (/* binding */ clearStoredUser),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getNextUserId: () => (/* binding */ getNextUserId),\n/* harmony export */   getStoredUser: () => (/* binding */ getStoredUser),\n/* harmony export */   getUser: () => (/* binding */ getUser),\n/* harmony export */   initializeDefaultUsers: () => (/* binding */ initializeDefaultUsers),\n/* harmony export */   saveUserToDatabase: () => (/* binding */ saveUserToDatabase),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   signUp: () => (/* binding */ signUp),\n/* harmony export */   storeUser: () => (/* binding */ storeUser),\n/* harmony export */   suspendUserWithReason: () => (/* binding */ suspendUserWithReason),\n/* harmony export */   toggleUserSuspension: () => (/* binding */ toggleUserSuspension),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n// Authentication utilities and types\nfunction getAllUsers() {\n    if (false) {}\n    const stored = localStorage.getItem(\"users_database\");\n    return stored ? JSON.parse(stored) : [];\n}\nfunction saveUserToDatabase(user) {\n    if (false) {}\n    const users = getAllUsers();\n    const existingIndex = users.findIndex((u)=>u.email === user.email);\n    if (existingIndex >= 0) {\n        users[existingIndex] = user;\n    } else {\n        users.push(user);\n    }\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n}\nfunction getNextUserId() {\n    const users = getAllUsers();\n    const maxId = users.reduce((max, user)=>{\n        const numId = Number.parseInt(user.id);\n        return isNaN(numId) ? max : Math.max(max, numId);\n    }, 0);\n    return String(maxId + 1).padStart(2, \"0\");\n}\nfunction initializeDefaultUsers() {\n    const users = getAllUsers();\n    if (users.length === 0) {\n        const defaultUsers = [\n            {\n                id: \"01\",\n                email: \"admin@marketplace.com\",\n                firstName: \"Admin\",\n                lastName: \"User\",\n                username: \"admin\",\n                userType: \"admin\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"02\",\n                email: \"worker1@marketplace.com\",\n                firstName: \"John\",\n                lastName: \"Worker\",\n                username: \"johnworker\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"03\",\n                email: \"employer1@marketplace.com\",\n                firstName: \"Jane\",\n                lastName: \"Employer\",\n                username: \"janeemployer\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 100,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            }\n        ];\n        defaultUsers.forEach((user)=>saveUserToDatabase(user));\n        console.log(\"[v0] ✅ Initialized default users:\", defaultUsers.map((u)=>\"\".concat(u.firstName, \" \").concat(u.lastName, \" (ID: \").concat(u.id, \")\")));\n    }\n}\n// Mock authentication functions (replace with real API calls when database is connected)\nasync function signIn(email, password) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.email === email);\n    if (!user) {\n        throw new Error(\"Invalid email or password\");\n    }\n    if (user.userType === \"suspended\") {\n        const reason = user.suspensionReason || \"No reason provided\";\n        throw new Error(\"Your account has been suspended. Reason: \".concat(reason));\n    }\n    if (email === \"admin@marketplace.com\" && password === \"admin123\") {\n        console.log(\"[v0] Admin login successful for:\", user.email);\n        return user;\n    }\n    if (password === \"password123\" || password.length >= 8) {\n        console.log(\"[v0] User login successful for:\", user.email);\n        return user;\n    }\n    throw new Error(\"Invalid email or password\");\n}\nasync function signUp(data) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (!isValidEmail(data.email)) {\n        throw new Error(\"Please enter a valid email address\");\n    }\n    if (data.password.length < 8) {\n        throw new Error(\"Password must be at least 8 characters long\");\n    }\n    if (!isValidPassword(data.password)) {\n        throw new Error(\"Password must contain at least one uppercase letter, one lowercase letter, and one number\");\n    }\n    if (data.username.length < 3) {\n        throw new Error(\"Username must be at least 3 characters long\");\n    }\n    if (!/^[a-zA-Z0-9_]+$/.test(data.username)) {\n        throw new Error(\"Username can only contain letters, numbers, and underscores\");\n    }\n    const users = getAllUsers();\n    const existingUser = users.find((u)=>u.email === data.email || u.username === data.username);\n    if (existingUser) {\n        if (existingUser.email === data.email) {\n            throw new Error(\"An account with this email already exists\");\n        } else {\n            throw new Error(\"This username is already taken\");\n        }\n    }\n    const newUser = {\n        id: getNextUserId(),\n        email: data.email,\n        firstName: data.firstName,\n        lastName: data.lastName,\n        username: data.username,\n        userType: \"user\",\n        isVerified: false,\n        deposit: 0,\n        earning: 0,\n        country: \"United States\",\n        createdAt: new Date().toISOString()\n    };\n    saveUserToDatabase(newUser);\n    return newUser;\n}\nasync function signOut() {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n}\nfunction getStoredUser() {\n    if (false) {}\n    const stored = localStorage.getItem(\"user\");\n    return stored ? JSON.parse(stored) : null;\n}\nfunction storeUser(user) {\n    if (false) {}\n    localStorage.setItem(\"user\", JSON.stringify(user));\n}\nfunction clearStoredUser() {\n    if (false) {}\n    localStorage.removeItem(\"user\");\n}\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\nfunction isValidPassword(password) {\n    // At least 8 characters, one uppercase, one lowercase, one number\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\n    return passwordRegex.test(password);\n}\nfunction updateUser(userId, updates) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        ...updates\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction toggleUserSuspension(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const user = users[userIndex];\n    // Toggle between user and suspended status (using a custom field)\n    const updatedUser = {\n        ...user,\n        isSuspended: !user.isSuspended\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction suspendUserWithReason(userId, reason, suspendedBy) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"suspended\",\n        suspensionReason: reason,\n        suspendedAt: new Date().toISOString(),\n        suspendedBy: suspendedBy\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction activateUser(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"user\",\n        suspensionReason: undefined,\n        suspendedAt: undefined,\n        suspendedBy: undefined\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nasync function getUser() {\n    // In a real implementation, this would validate JWT tokens or session cookies\n    // For now, we'll simulate getting the current user from localStorage on the client\n    // or return null on the server (since we don't have real session management)\n    if (false) {}\n    // Client-side: Get user from localStorage\n    return getStoredUser();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bEI7SUFFQSxNQUFNcUIsY0FBYztRQUNsQixHQUFHakUsS0FBSyxDQUFDZ0UsVUFBVTtRQUNuQnRDLFVBQVU7UUFDVm9CLGtCQUFrQkQ7UUFDbEJ5QixhQUFhLElBQUl0QyxPQUFPQyxXQUFXO1FBQ25Db0MsYUFBYUE7SUFDZjtJQUVBckUsS0FBSyxDQUFDZ0UsVUFBVSxHQUFHQztJQUNuQnZFLGFBQWFZLE9BQU8sQ0FBQyxrQkFBa0JWLEtBQUtXLFNBQVMsQ0FBQ1A7SUFFdEQsT0FBT2lFO0FBQ1Q7QUFFTyxTQUFTTSxhQUFhVCxNQUFjO0lBQ3pDLE1BQU05RCxRQUFRUjtJQUNkLE1BQU13RSxZQUFZaEUsTUFBTUUsU0FBUyxDQUFDLENBQUNDLElBQU1BLEVBQUVZLEVBQUUsS0FBSytDO0lBRWxELElBQUlFLGNBQWMsQ0FBQyxHQUFHO1FBQ3BCLE1BQU0sSUFBSXBCLE1BQU07SUFDbEI7SUFFQSxNQUFNcUIsY0FBYztRQUNsQixHQUFHakUsS0FBSyxDQUFDZ0UsVUFBVTtRQUNuQnRDLFVBQVU7UUFDVm9CLGtCQUFrQjBCO1FBQ2xCRixhQUFhRTtRQUNiSCxhQUFhRztJQUNmO0lBRUF4RSxLQUFLLENBQUNnRSxVQUFVLEdBQUdDO0lBQ25CdkUsYUFBYVksT0FBTyxDQUFDLGtCQUFrQlYsS0FBS1csU0FBUyxDQUFDUDtJQUV0RCxPQUFPaUU7QUFDVDtBQUVPLGVBQWVRO0lBQ3BCLDhFQUE4RTtJQUM5RSxtRkFBbUY7SUFDbkYsNkVBQTZFO0lBRTdFLElBQUksS0FBNkIsRUFBRSxFQWdCbEM7SUFFRCwwQ0FBMEM7SUFDMUMsT0FBT2xCO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3QvbGliL2F1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQXV0aGVudGljYXRpb24gdXRpbGl0aWVzIGFuZCB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZpcnN0TmFtZTogc3RyaW5nXG4gIGxhc3ROYW1lOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBhdmF0YXI/OiBzdHJpbmdcbiAgdXNlclR5cGU6IFwidXNlclwiIHwgXCJhZG1pblwiIHwgXCJzdXNwZW5kZWRcIlxuICBpc1ZlcmlmaWVkOiBib29sZWFuXG4gIGRlcG9zaXQ6IG51bWJlclxuICBlYXJuaW5nOiBudW1iZXJcbiAgY291bnRyeTogc3RyaW5nXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIGlzU3VzcGVuZGVkPzogYm9vbGVhblxuICBzdXNwZW5zaW9uUmVhc29uPzogc3RyaW5nXG4gIHN1c3BlbmRlZEF0Pzogc3RyaW5nXG4gIHN1c3BlbmRlZEJ5Pzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFN0YXRlIHtcbiAgdXNlcjogVXNlciB8IG51bGxcbiAgaXNMb2FkaW5nOiBib29sZWFuXG4gIGlzQXV0aGVudGljYXRlZDogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVXNlcnMoKTogVXNlcltdIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuXG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIilcbiAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlVXNlclRvRGF0YWJhc2UodXNlcjogVXNlcik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IGV4aXN0aW5nSW5kZXggPSB1c2Vycy5maW5kSW5kZXgoKHUpID0+IHUuZW1haWwgPT09IHVzZXIuZW1haWwpXG5cbiAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkge1xuICAgIHVzZXJzW2V4aXN0aW5nSW5kZXhdID0gdXNlclxuICB9IGVsc2Uge1xuICAgIHVzZXJzLnB1c2godXNlcilcbiAgfVxuXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIiwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dFVzZXJJZCgpOiBzdHJpbmcge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgbWF4SWQgPSB1c2Vycy5yZWR1Y2UoKG1heCwgdXNlcikgPT4ge1xuICAgIGNvbnN0IG51bUlkID0gTnVtYmVyLnBhcnNlSW50KHVzZXIuaWQpXG4gICAgcmV0dXJuIGlzTmFOKG51bUlkKSA/IG1heCA6IE1hdGgubWF4KG1heCwgbnVtSWQpXG4gIH0sIDApXG5cbiAgcmV0dXJuIFN0cmluZyhtYXhJZCArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZURlZmF1bHRVc2VycygpOiB2b2lkIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG5cbiAgaWYgKHVzZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IGRlZmF1bHRVc2VyczogVXNlcltdID0gW1xuICAgICAge1xuICAgICAgICBpZDogXCIwMVwiLFxuICAgICAgICBlbWFpbDogXCJhZG1pbkBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgICAgZmlyc3ROYW1lOiBcIkFkbWluXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgICAgdXNlcm5hbWU6IFwiYWRtaW5cIixcbiAgICAgICAgdXNlclR5cGU6IFwiYWRtaW5cIixcbiAgICAgICAgaXNWZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgZGVwb3NpdDogMCxcbiAgICAgICAgZWFybmluZzogMCxcbiAgICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwiMDJcIixcbiAgICAgICAgZW1haWw6IFwid29ya2VyMUBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgICAgZmlyc3ROYW1lOiBcIkpvaG5cIixcbiAgICAgICAgbGFzdE5hbWU6IFwiV29ya2VyXCIsXG4gICAgICAgIHVzZXJuYW1lOiBcImpvaG53b3JrZXJcIixcbiAgICAgICAgdXNlclR5cGU6IFwidXNlclwiLFxuICAgICAgICBpc1ZlcmlmaWVkOiB0cnVlLFxuICAgICAgICBkZXBvc2l0OiAwLFxuICAgICAgICBlYXJuaW5nOiAwLFxuICAgICAgICBjb3VudHJ5OiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCIwM1wiLFxuICAgICAgICBlbWFpbDogXCJlbXBsb3llcjFAbWFya2V0cGxhY2UuY29tXCIsXG4gICAgICAgIGZpcnN0TmFtZTogXCJKYW5lXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIkVtcGxveWVyXCIsXG4gICAgICAgIHVzZXJuYW1lOiBcImphbmVlbXBsb3llclwiLFxuICAgICAgICB1c2VyVHlwZTogXCJ1c2VyXCIsXG4gICAgICAgIGlzVmVyaWZpZWQ6IHRydWUsXG4gICAgICAgIGRlcG9zaXQ6IDEwMCxcbiAgICAgICAgZWFybmluZzogMCxcbiAgICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfSxcbiAgICBdXG5cbiAgICBkZWZhdWx0VXNlcnMuZm9yRWFjaCgodXNlcikgPT4gc2F2ZVVzZXJUb0RhdGFiYXNlKHVzZXIpKVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJbdjBdIOKchSBJbml0aWFsaXplZCBkZWZhdWx0IHVzZXJzOlwiLFxuICAgICAgZGVmYXVsdFVzZXJzLm1hcCgodSkgPT4gYCR7dS5maXJzdE5hbWV9ICR7dS5sYXN0TmFtZX0gKElEOiAke3UuaWR9KWApLFxuICAgIClcbiAgfVxufVxuXG4vLyBNb2NrIGF1dGhlbnRpY2F0aW9uIGZ1bmN0aW9ucyAocmVwbGFjZSB3aXRoIHJlYWwgQVBJIGNhbGxzIHdoZW4gZGF0YWJhc2UgaXMgY29ubmVjdGVkKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbihlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBjYWxsXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKVxuXG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB1c2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5lbWFpbCA9PT0gZW1haWwpXG5cbiAgaWYgKCF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZFwiKVxuICB9XG5cbiAgaWYgKHVzZXIudXNlclR5cGUgPT09IFwic3VzcGVuZGVkXCIpIHtcbiAgICBjb25zdCByZWFzb24gPSB1c2VyLnN1c3BlbnNpb25SZWFzb24gfHwgXCJObyByZWFzb24gcHJvdmlkZWRcIlxuICAgIHRocm93IG5ldyBFcnJvcihgWW91ciBhY2NvdW50IGhhcyBiZWVuIHN1c3BlbmRlZC4gUmVhc29uOiAke3JlYXNvbn1gKVxuICB9XG5cbiAgaWYgKGVtYWlsID09PSBcImFkbWluQG1hcmtldHBsYWNlLmNvbVwiICYmIHBhc3N3b3JkID09PSBcImFkbWluMTIzXCIpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gQWRtaW4gbG9naW4gc3VjY2Vzc2Z1bCBmb3I6XCIsIHVzZXIuZW1haWwpXG4gICAgcmV0dXJuIHVzZXJcbiAgfVxuXG4gIGlmIChwYXNzd29yZCA9PT0gXCJwYXNzd29yZDEyM1wiIHx8IHBhc3N3b3JkLmxlbmd0aCA+PSA4KSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIFVzZXIgbG9naW4gc3VjY2Vzc2Z1bCBmb3I6XCIsIHVzZXIuZW1haWwpXG4gICAgcmV0dXJuIHVzZXJcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW1haWwgb3IgcGFzc3dvcmRcIilcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25VcChkYXRhOiB7XG4gIGVtYWlsOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICBmaXJzdE5hbWU6IHN0cmluZ1xuICBsYXN0TmFtZTogc3RyaW5nXG4gIHVzZXJuYW1lOiBzdHJpbmdcbn0pOiBQcm9taXNlPFVzZXI+IHtcbiAgLy8gU2ltdWxhdGUgQVBJIGNhbGxcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG5cbiAgaWYgKCFpc1ZhbGlkRW1haWwoZGF0YS5lbWFpbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIpXG4gIH1cblxuICBpZiAoZGF0YS5wYXNzd29yZC5sZW5ndGggPCA4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMgbG9uZ1wiKVxuICB9XG5cbiAgaWYgKCFpc1ZhbGlkUGFzc3dvcmQoZGF0YS5wYXNzd29yZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHVwcGVyY2FzZSBsZXR0ZXIsIG9uZSBsb3dlcmNhc2UgbGV0dGVyLCBhbmQgb25lIG51bWJlclwiKVxuICB9XG5cbiAgaWYgKGRhdGEudXNlcm5hbWUubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXJuYW1lIG11c3QgYmUgYXQgbGVhc3QgMyBjaGFyYWN0ZXJzIGxvbmdcIilcbiAgfVxuXG4gIGlmICghL15bYS16QS1aMC05X10rJC8udGVzdChkYXRhLnVzZXJuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXJuYW1lIGNhbiBvbmx5IGNvbnRhaW4gbGV0dGVycywgbnVtYmVycywgYW5kIHVuZGVyc2NvcmVzXCIpXG4gIH1cblxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgZXhpc3RpbmdVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5lbWFpbCA9PT0gZGF0YS5lbWFpbCB8fCB1LnVzZXJuYW1lID09PSBkYXRhLnVzZXJuYW1lKVxuXG4gIGlmIChleGlzdGluZ1VzZXIpIHtcbiAgICBpZiAoZXhpc3RpbmdVc2VyLmVtYWlsID09PSBkYXRhLmVtYWlsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBhY2NvdW50IHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0c1wiKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHVzZXJuYW1lIGlzIGFscmVhZHkgdGFrZW5cIilcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdVc2VyOiBVc2VyID0ge1xuICAgIGlkOiBnZXROZXh0VXNlcklkKCksXG4gICAgZW1haWw6IGRhdGEuZW1haWwsXG4gICAgZmlyc3ROYW1lOiBkYXRhLmZpcnN0TmFtZSxcbiAgICBsYXN0TmFtZTogZGF0YS5sYXN0TmFtZSxcbiAgICB1c2VybmFtZTogZGF0YS51c2VybmFtZSxcbiAgICB1c2VyVHlwZTogXCJ1c2VyXCIsXG4gICAgaXNWZXJpZmllZDogZmFsc2UsXG4gICAgZGVwb3NpdDogMCxcbiAgICBlYXJuaW5nOiAwLFxuICAgIGNvdW50cnk6IFwiVW5pdGVkIFN0YXRlc1wiLCAvLyBEZWZhdWx0IHRvIFVTIGluc3RlYWQgb2YgaGFyZGNvZGVkIEJhbmdsYWRlc2hcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIHNhdmVVc2VyVG9EYXRhYmFzZShuZXdVc2VyKVxuXG4gIHJldHVybiBuZXdVc2VyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaWduT3V0KCk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBTaW11bGF0ZSBBUEkgY2FsbFxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVkVXNlcigpOiBVc2VyIHwgbnVsbCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidXNlclwiKVxuICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcmVVc2VyKHVzZXI6IFVzZXIpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJcIiwgSlNPTi5zdHJpbmdpZnkodXNlcikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclN0b3JlZFVzZXIoKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJ1c2VyXCIpXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbWFpbChlbWFpbDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IGVtYWlsUmVnZXggPSAvXlteXFxzQF0rQFteXFxzQF0rXFwuW15cXHNAXSskL1xuICByZXR1cm4gZW1haWxSZWdleC50ZXN0KGVtYWlsKVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBBdCBsZWFzdCA4IGNoYXJhY3RlcnMsIG9uZSB1cHBlcmNhc2UsIG9uZSBsb3dlcmNhc2UsIG9uZSBudW1iZXJcbiAgY29uc3QgcGFzc3dvcmRSZWdleCA9IC9eKD89LipbYS16XSkoPz0uKltBLVpdKSg/PS4qXFxkKS57OCx9JC9cbiAgcmV0dXJuIHBhc3N3b3JkUmVnZXgudGVzdChwYXNzd29yZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVzZXIodXNlcklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8VXNlcj4pOiBVc2VyIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXJJbmRleCA9IHVzZXJzLmZpbmRJbmRleCgodSkgPT4gdS5pZCA9PT0gdXNlcklkKVxuXG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0geyAuLi51c2Vyc1t1c2VySW5kZXhdLCAuLi51cGRhdGVzIH1cbiAgdXNlcnNbdXNlckluZGV4XSA9IHVwZGF0ZWRVc2VyXG5cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVVc2VyU3VzcGVuc2lvbih1c2VySWQ6IHN0cmluZyk6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXNlciA9IHVzZXJzW3VzZXJJbmRleF1cbiAgLy8gVG9nZ2xlIGJldHdlZW4gdXNlciBhbmQgc3VzcGVuZGVkIHN0YXR1cyAodXNpbmcgYSBjdXN0b20gZmllbGQpXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0ge1xuICAgIC4uLnVzZXIsXG4gICAgaXNTdXNwZW5kZWQ6ICF1c2VyLmlzU3VzcGVuZGVkLFxuICB9XG5cbiAgdXNlcnNbdXNlckluZGV4XSA9IHVwZGF0ZWRVc2VyXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlcnNfZGF0YWJhc2VcIiwgSlNPTi5zdHJpbmdpZnkodXNlcnMpKVxuXG4gIHJldHVybiB1cGRhdGVkVXNlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZFVzZXJXaXRoUmVhc29uKHVzZXJJZDogc3RyaW5nLCByZWFzb246IHN0cmluZywgc3VzcGVuZGVkQnk6IHN0cmluZyk6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZFVzZXIgPSB7XG4gICAgLi4udXNlcnNbdXNlckluZGV4XSxcbiAgICB1c2VyVHlwZTogXCJzdXNwZW5kZWRcIiBhcyBjb25zdCxcbiAgICBzdXNwZW5zaW9uUmVhc29uOiByZWFzb24sXG4gICAgc3VzcGVuZGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBzdXNwZW5kZWRCeTogc3VzcGVuZGVkQnksXG4gIH1cblxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZVVzZXIodXNlcklkOiBzdHJpbmcpOiBVc2VyIHtcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXJJbmRleCA9IHVzZXJzLmZpbmRJbmRleCgodSkgPT4gdS5pZCA9PT0gdXNlcklkKVxuXG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRVc2VyID0ge1xuICAgIC4uLnVzZXJzW3VzZXJJbmRleF0sXG4gICAgdXNlclR5cGU6IFwidXNlclwiIGFzIGNvbnN0LFxuICAgIHN1c3BlbnNpb25SZWFzb246IHVuZGVmaW5lZCxcbiAgICBzdXNwZW5kZWRBdDogdW5kZWZpbmVkLFxuICAgIHN1c3BlbmRlZEJ5OiB1bmRlZmluZWQsXG4gIH1cblxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyKCk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHZhbGlkYXRlIEpXVCB0b2tlbnMgb3Igc2Vzc2lvbiBjb29raWVzXG4gIC8vIEZvciBub3csIHdlJ2xsIHNpbXVsYXRlIGdldHRpbmcgdGhlIGN1cnJlbnQgdXNlciBmcm9tIGxvY2FsU3RvcmFnZSBvbiB0aGUgY2xpZW50XG4gIC8vIG9yIHJldHVybiBudWxsIG9uIHRoZSBzZXJ2ZXIgKHNpbmNlIHdlIGRvbid0IGhhdmUgcmVhbCBzZXNzaW9uIG1hbmFnZW1lbnQpXG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBTZXJ2ZXItc2lkZTogSW4gYSByZWFsIGFwcCwgeW91J2QgdmFsaWRhdGUgc2Vzc2lvbiB0b2tlbnMgaGVyZVxuICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCByZXR1cm4gYSBtb2NrIGFkbWluIHVzZXIgZm9yIEFQSSBjYWxsc1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCIwMVwiLFxuICAgICAgZW1haWw6IFwiYWRtaW5AbWFya2V0cGxhY2UuY29tXCIsXG4gICAgICBmaXJzdE5hbWU6IFwiQWRtaW5cIixcbiAgICAgIGxhc3ROYW1lOiBcIlVzZXJcIixcbiAgICAgIHVzZXJuYW1lOiBcImFkbWluXCIsXG4gICAgICB1c2VyVHlwZTogXCJhZG1pblwiLFxuICAgICAgaXNWZXJpZmllZDogdHJ1ZSxcbiAgICAgIGRlcG9zaXQ6IDAsXG4gICAgICBlYXJuaW5nOiAwLFxuICAgICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9XG4gIH1cblxuICAvLyBDbGllbnQtc2lkZTogR2V0IHVzZXIgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgcmV0dXJuIGdldFN0b3JlZFVzZXIoKVxufVxuIl0sIm5hbWVzIjpbImdldEFsbFVzZXJzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsInNhdmVVc2VyVG9EYXRhYmFzZSIsInVzZXIiLCJ1c2VycyIsImV4aXN0aW5nSW5kZXgiLCJmaW5kSW5kZXgiLCJ1IiwiZW1haWwiLCJwdXNoIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImdldE5leHRVc2VySWQiLCJtYXhJZCIsInJlZHVjZSIsIm1heCIsIm51bUlkIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJpZCIsImlzTmFOIiwiTWF0aCIsIlN0cmluZyIsInBhZFN0YXJ0IiwiaW5pdGlhbGl6ZURlZmF1bHRVc2VycyIsImxlbmd0aCIsImRlZmF1bHRVc2VycyIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwidXNlcm5hbWUiLCJ1c2VyVHlwZSIsImlzVmVyaWZpZWQiLCJkZXBvc2l0IiwiZWFybmluZyIsImNvdW50cnkiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJmb3JFYWNoIiwiY29uc29sZSIsImxvZyIsIm1hcCIsInNpZ25JbiIsInBhc3N3b3JkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmluZCIsIkVycm9yIiwicmVhc29uIiwic3VzcGVuc2lvblJlYXNvbiIsInNpZ25VcCIsImRhdGEiLCJpc1ZhbGlkRW1haWwiLCJpc1ZhbGlkUGFzc3dvcmQiLCJ0ZXN0IiwiZXhpc3RpbmdVc2VyIiwibmV3VXNlciIsInNpZ25PdXQiLCJnZXRTdG9yZWRVc2VyIiwic3RvcmVVc2VyIiwiY2xlYXJTdG9yZWRVc2VyIiwicmVtb3ZlSXRlbSIsImVtYWlsUmVnZXgiLCJwYXNzd29yZFJlZ2V4IiwidXBkYXRlVXNlciIsInVzZXJJZCIsInVwZGF0ZXMiLCJ1c2VySW5kZXgiLCJ1cGRhdGVkVXNlciIsInRvZ2dsZVVzZXJTdXNwZW5zaW9uIiwiaXNTdXNwZW5kZWQiLCJzdXNwZW5kVXNlcldpdGhSZWFzb24iLCJzdXNwZW5kZWRCeSIsInN1c3BlbmRlZEF0IiwiYWN0aXZhdGVVc2VyIiwidW5kZWZpbmVkIiwiZ2V0VXNlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/auth.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/jobs.ts":
/*!*********************!*\
  !*** ./lib/jobs.ts ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JOB_STATUS: () => (/* binding */ JOB_STATUS),\n/* harmony export */   acceptJobApplication: () => (/* binding */ acceptJobApplication),\n/* harmony export */   applyToJob: () => (/* binding */ applyToJob),\n/* harmony export */   approveJob: () => (/* binding */ approveJob),\n/* harmony export */   canApplyToJob: () => (/* binding */ canApplyToJob),\n/* harmony export */   cancelJob: () => (/* binding */ cancelJob),\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getAllJobStatusHistory: () => (/* binding */ getAllJobStatusHistory),\n/* harmony export */   getAllJobs: () => (/* binding */ getAllJobs),\n/* harmony export */   getAllUserJobs: () => (/* binding */ getAllUserJobs),\n/* harmony export */   getApprovedJobs: () => (/* binding */ getApprovedJobs),\n/* harmony export */   getAvailableJobs: () => (/* binding */ getAvailableJobs),\n/* harmony export */   getJobApplicationById: () => (/* binding */ getJobApplicationById),\n/* harmony export */   getJobApplications: () => (/* binding */ getJobApplications),\n/* harmony export */   getJobById: () => (/* binding */ getJobById),\n/* harmony export */   getJobStatusColor: () => (/* binding */ getJobStatusColor),\n/* harmony export */   getJobStatusHistory: () => (/* binding */ getJobStatusHistory),\n/* harmony export */   getJobStatusLabel: () => (/* binding */ getJobStatusLabel),\n/* harmony export */   getJobs: () => (/* binding */ getJobs),\n/* harmony export */   getJobsForDashboard: () => (/* binding */ getJobsForDashboard),\n/* harmony export */   getPendingJobs: () => (/* binding */ getPendingJobs),\n/* harmony export */   getStoredJobs: () => (/* binding */ getStoredJobs),\n/* harmony export */   getUserApplications: () => (/* binding */ getUserApplications),\n/* harmony export */   getUserJobs: () => (/* binding */ getUserJobs),\n/* harmony export */   getWorkProofs: () => (/* binding */ getWorkProofs),\n/* harmony export */   getWorkProofsByJob: () => (/* binding */ getWorkProofsByJob),\n/* harmony export */   getWorkProofsByWorker: () => (/* binding */ getWorkProofsByWorker),\n/* harmony export */   isJobVisible: () => (/* binding */ isJobVisible),\n/* harmony export */   pauseJob: () => (/* binding */ pauseJob),\n/* harmony export */   reactivateJob: () => (/* binding */ reactivateJob),\n/* harmony export */   rejectJob: () => (/* binding */ rejectJob),\n/* harmony export */   rejectJobApplication: () => (/* binding */ rejectJobApplication),\n/* harmony export */   reviewWorkProof: () => (/* binding */ reviewWorkProof),\n/* harmony export */   submitJobApplication: () => (/* binding */ submitJobApplication),\n/* harmony export */   submitJobForApproval: () => (/* binding */ submitJobForApproval),\n/* harmony export */   submitWorkProof: () => (/* binding */ submitWorkProof),\n/* harmony export */   suspendJob: () => (/* binding */ suspendJob),\n/* harmony export */   toggleJobOff: () => (/* binding */ toggleJobOff),\n/* harmony export */   toggleJobOn: () => (/* binding */ toggleJobOn),\n/* harmony export */   updateJob: () => (/* binding */ updateJob),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus),\n/* harmony export */   updateJobWorkers: () => (/* binding */ updateJobWorkers)\n/* harmony export */ });\n/* harmony import */ var _categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categories */ \"(app-pages-browser)/./lib/categories.ts\");\n/* harmony import */ var _platform_fee__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform-fee */ \"(app-pages-browser)/./lib/platform-fee.ts\");\n/* harmony import */ var _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local-reservation-storage */ \"(app-pages-browser)/./lib/local-reservation-storage.ts\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auth */ \"(app-pages-browser)/./lib/auth.ts\");\n// Job-related types and mock data\nconst JOBS_STORAGE_KEY = \"marketplace-jobs\";\nconst APPLICATIONS_STORAGE_KEY = \"marketplace-applications\";\nconst WORK_PROOFS_STORAGE_KEY = \"marketplace-work-proofs\";\nconst JOB_REVIEWS_STORAGE_KEY = \"marketplace-job-reviews\";\nconst JOB_STATUS_HISTORY_STORAGE_KEY = \"marketplace-job-status-history\";\nconst getStoredJobs = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(JOBS_STORAGE_KEY);\n        if (stored) {\n            const jobs = JSON.parse(stored);\n            return jobs;\n        }\n        return [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveJobs = (jobs)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n    } catch (error) {\n        console.error(\"Failed to save jobs:\", error);\n    }\n};\nconst getStoredApplications = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(APPLICATIONS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveApplications = (applications)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(APPLICATIONS_STORAGE_KEY, JSON.stringify(applications));\n    } catch (error) {\n        console.error(\"Failed to save applications:\", error);\n    }\n};\nconst getStoredWorkProofs = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(WORK_PROOFS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveWorkProofs = (workProofs)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(WORK_PROOFS_STORAGE_KEY, JSON.stringify(workProofs));\n    } catch (error) {\n        console.error(\"Failed to save work proofs:\", error);\n    }\n};\nconst getStoredJobReviews = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(JOB_REVIEWS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveJobReviews = (reviews)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(JOB_REVIEWS_STORAGE_KEY, JSON.stringify(reviews));\n    } catch (error) {\n        console.error(\"Failed to save job reviews:\", error);\n    }\n};\n// Storage functions for job status history\nconst getStoredJobStatusHistory = ()=>{\n    if (false) {}\n    try {\n        const stored = localStorage.getItem(JOB_STATUS_HISTORY_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch (e) {\n        return [];\n    }\n};\nconst saveJobStatusHistory = (history)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(JOB_STATUS_HISTORY_STORAGE_KEY, JSON.stringify(history));\n    } catch (error) {\n        console.error(\"Failed to save job status history:\", error);\n    }\n};\n// Function to record status changes\nconst recordStatusChange = (jobId, oldStatus, newStatus, userId, notes, metadata)=>{\n    const history = getStoredJobStatusHistory();\n    const statusEntry = {\n        id: \"status_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        jobId,\n        userId,\n        oldStatus,\n        newStatus,\n        notes,\n        metadata,\n        createdAt: new Date().toISOString()\n    };\n    history.push(statusEntry);\n    saveJobStatusHistory(history);\n    console.log(\"[v0] Status change recorded for job \".concat(jobId, \": \").concat(oldStatus, \" -> \").concat(newStatus));\n};\n\n\n\nasync function populateJobCategoryData(job) {\n    var _populatedJob_category, _populatedJob_subcategory, _populatedJob_subcategory1;\n    console.log(\"[v0] Populating category data for job:\", job.title, \"categoryId:\", job.categoryId, \"subcategoryId:\", job.subcategoryId);\n    const populatedJob = {\n        ...job\n    };\n    if (!((_populatedJob_category = populatedJob.category) === null || _populatedJob_category === void 0 ? void 0 : _populatedJob_category.thumbnail) && populatedJob.categoryId) {\n        const fullCategory = await (0,_categories__WEBPACK_IMPORTED_MODULE_0__.getCategoryById)(populatedJob.categoryId);\n        console.log(\"[v0] Loaded category:\", fullCategory === null || fullCategory === void 0 ? void 0 : fullCategory.name, \"thumbnail:\", fullCategory === null || fullCategory === void 0 ? void 0 : fullCategory.thumbnail);\n        if (fullCategory) {\n            populatedJob.category = {\n                id: fullCategory.id,\n                name: fullCategory.name,\n                slug: fullCategory.slug,\n                thumbnail: fullCategory.thumbnail\n            };\n            populatedJob.categoryThumbnail = fullCategory.thumbnail;\n        }\n    }\n    // Load subcategory data if subcategoryId exists\n    if (populatedJob.subcategoryId) {\n        const subcategory = await (0,_categories__WEBPACK_IMPORTED_MODULE_0__.getSubcategoryById)(populatedJob.subcategoryId);\n        console.log(\"[v0] Loaded subcategory:\", subcategory === null || subcategory === void 0 ? void 0 : subcategory.name, \"thumbnail:\", subcategory === null || subcategory === void 0 ? void 0 : subcategory.thumbnail);\n        if (subcategory) {\n            populatedJob.subcategory = subcategory;\n        }\n    }\n    console.log(\"[v0] Final job data:\", {\n        title: populatedJob.title,\n        categoryThumbnail: populatedJob.categoryThumbnail,\n        subcategory: (_populatedJob_subcategory = populatedJob.subcategory) === null || _populatedJob_subcategory === void 0 ? void 0 : _populatedJob_subcategory.name,\n        subcategoryThumbnail: (_populatedJob_subcategory1 = populatedJob.subcategory) === null || _populatedJob_subcategory1 === void 0 ? void 0 : _populatedJob_subcategory1.thumbnail\n    });\n    return populatedJob;\n}\nasync function getJobs(filters) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    let filteredJobs = getStoredJobs().filter((job)=>job.status === \"approved\" || job.status === \"open\");\n    if (filters === null || filters === void 0 ? void 0 : filters.search) {\n        filteredJobs = filteredJobs.filter((job)=>job.title.toLowerCase().includes(filters.search.toLowerCase()) || job.description.toLowerCase().includes(filters.search.toLowerCase()) || job.skillsRequired.some((skill)=>skill.toLowerCase().includes(filters.search.toLowerCase())));\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.category) {\n        filteredJobs = filteredJobs.filter((job)=>job.category.slug === filters.category);\n    }\n    if ((filters === null || filters === void 0 ? void 0 : filters.remote) !== undefined) {\n        filteredJobs = filteredJobs.filter((job)=>job.isRemote === filters.remote);\n    }\n    if (filters === null || filters === void 0 ? void 0 : filters.budget) {\n        filteredJobs = filteredJobs.filter((job)=>job.budgetMax >= filters.budget.min && job.budgetMin <= filters.budget.max);\n    }\n    if ((filters === null || filters === void 0 ? void 0 : filters.location) && filters.location !== \"all\") {\n        filteredJobs = filteredJobs.filter((job)=>job.location.toLowerCase().includes(filters.location.toLowerCase()));\n    }\n    const sortedJobs = filteredJobs.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    const populatedJobs = await Promise.all(sortedJobs.map(populateJobCategoryData));\n    return populatedJobs;\n}\nasync function getJobById(id) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const job = jobs.find((job)=>job.id === id);\n    if (job) {\n        // Increment view count\n        job.viewsCount = (job.viewsCount || 0) + 1;\n        const jobIndex = jobs.findIndex((j)=>j.id === id);\n        if (jobIndex !== -1) {\n            jobs[jobIndex] = job;\n            saveJobs(jobs);\n        }\n        const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(app-pages-browser)/./lib/auth.ts\"));\n        const users = getAllUsers();\n        const posterUser = users.find((u)=>u.id === job.userId);\n        if (posterUser) {\n            job.poster = {\n                id: posterUser.id,\n                firstName: posterUser.firstName,\n                lastName: posterUser.lastName,\n                username: posterUser.username,\n                avatar: posterUser.avatar,\n                rating: 4.5,\n                totalReviews: 0\n            };\n        }\n        return await populateJobCategoryData(job);\n    }\n    return null;\n}\nasync function getJobApplications(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    return applications.filter((app)=>app.jobId === jobId);\n}\nasync function submitJobApplication(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    if (!data.userId) {\n        throw new Error(\"User ID is required to submit application\");\n    }\n    if (!data.coverLetter.trim()) {\n        throw new Error(\"Cover letter is required\");\n    }\n    if (data.proposedBudget <= 0) {\n        throw new Error(\"Proposed budget must be greater than 0\");\n    }\n    // Check if user already applied\n    const existingApplications = getStoredApplications();\n    const hasApplied = existingApplications.some((app)=>app.jobId === data.jobId && app.applicantId === data.userId);\n    if (hasApplied) {\n        throw new Error(\"You have already applied to this job\");\n    }\n    // Get user data for application\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(app-pages-browser)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === data.userId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const newApplication = {\n        id: \"app_\".concat(Date.now()),\n        jobId: data.jobId,\n        applicantId: data.userId,\n        coverLetter: data.coverLetter,\n        proposedBudget: data.proposedBudget,\n        estimatedDuration: data.estimatedDuration,\n        portfolioLinks: data.portfolioLinks,\n        status: \"pending\",\n        createdAt: new Date().toISOString(),\n        applicant: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            rating: 4.5,\n            totalReviews: 0,\n            skills: [\n                \"General\"\n            ]\n        }\n    };\n    const applications = getStoredApplications();\n    applications.push(newApplication);\n    saveApplications(applications);\n    // Update job application count\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === data.jobId);\n    if (jobIndex !== -1) {\n        jobs[jobIndex].applicationsCount = (jobs[jobIndex].applicationsCount || 0) + 1;\n        saveJobs(jobs);\n    }\n    // Create notification for job poster\n    const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (job) {\n        await createNotification({\n            userId: job.userId,\n            type: \"job\",\n            title: \"New Job Application\",\n            description: \"\".concat(user.firstName, \" \").concat(user.lastName, ' applied for your job \"').concat(job.title, '\"'),\n            actionUrl: \"/dashboard/jobs/\".concat(job.id, \"/applications\")\n        });\n    }\n    return newApplication;\n}\nasync function submitJobForApproval(jobData, userId) {\n    var _jobData_title, _jobData_description;\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    if (!userId) {\n        throw new Error(\"User ID is required to submit job\");\n    }\n    if (!((_jobData_title = jobData.title) === null || _jobData_title === void 0 ? void 0 : _jobData_title.trim())) {\n        throw new Error(\"Job title is required\");\n    }\n    if (!((_jobData_description = jobData.description) === null || _jobData_description === void 0 ? void 0 : _jobData_description.trim())) {\n        throw new Error(\"Job description is required\");\n    }\n    if (!jobData.budgetMin || jobData.budgetMin <= 0) {\n        throw new Error(\"Valid budget is required\");\n    }\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(app-pages-browser)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === userId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const { getCategoryById } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./categories */ \"(app-pages-browser)/./lib/categories.ts\"));\n    const category = await getCategoryById(jobData.categoryId || \"\");\n    const { getSubcategoryById } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./categories */ \"(app-pages-browser)/./lib/categories.ts\"));\n    const subcategory = jobData.subcategoryId ? await getSubcategoryById(jobData.subcategoryId) : null;\n    const checkAutoJobApproval = ()=>{\n        console.log(\"[v0] 🔧 AUTO-APPROVAL CHECK: Starting auto-approval check...\");\n        // For server-side execution, we need to pass the setting from client\n        // Default to MANUAL APPROVAL (false) for security\n        let autoApprovalSetting = false;\n        try {\n            // Check if we're in browser environment\n            if ( true && typeof localStorage !== \"undefined\") {\n                const setting = localStorage.getItem(\"admin_auto_job_approval_enabled\");\n                console.log(\"[v0] 🔧 AUTO-APPROVAL CHECK: Raw localStorage value:\", JSON.stringify(setting));\n                // Only enable if explicitly set to \"true\"\n                autoApprovalSetting = setting === \"true\";\n                console.log(\"[v0] 🔧 AUTO-APPROVAL CHECK: Parsed setting:\", autoApprovalSetting);\n            } else {\n                console.log(\"[v0] 🔧 AUTO-APPROVAL CHECK: Server-side execution - defaulting to MANUAL APPROVAL\");\n                autoApprovalSetting = false;\n            }\n        } catch (error) {\n            console.error(\"[v0] 🔧 AUTO-APPROVAL CHECK: Error accessing localStorage:\", error);\n            autoApprovalSetting = false;\n        }\n        console.log(\"[v0] 🔧 AUTO-APPROVAL CHECK: Final decision:\", autoApprovalSetting ? \"AUTO-APPROVE\" : \"MANUAL APPROVAL\");\n        return autoApprovalSetting;\n    };\n    const shouldAutoApprove = checkAutoJobApproval();\n    const jobStatus = shouldAutoApprove ? \"approved\" : \"pending\";\n    console.log(\"[v0] 💼 JOB CREATION: Starting job creation process\");\n    console.log(\"[v0] 💼 JOB CREATION: Auto-approval enabled:\", shouldAutoApprove);\n    console.log(\"[v0] 💼 JOB CREATION: Job status will be:\", jobStatus);\n    console.log(\"[v0] 💼 JOB CREATION: Job title:\", jobData.title);\n    var _jobData_isRemote;\n    const newJob = {\n        id: \"job_\".concat(Date.now()),\n        userId,\n        categoryId: jobData.categoryId || \"\",\n        subcategoryId: jobData.subcategoryId,\n        title: jobData.title,\n        description: jobData.description,\n        requirements: jobData.requirements,\n        instructions: jobData.instructions,\n        budgetMin: jobData.budgetMin,\n        budgetMax: jobData.budgetMax || jobData.budgetMin,\n        deadline: jobData.deadline || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split(\"T\")[0],\n        location: jobData.location || \"Remote\",\n        isRemote: (_jobData_isRemote = jobData.isRemote) !== null && _jobData_isRemote !== void 0 ? _jobData_isRemote : true,\n        status: jobStatus,\n        priority: jobData.priority || \"normal\",\n        skillsRequired: jobData.skillsRequired || [],\n        applicationsCount: 0,\n        viewsCount: 0,\n        workersNeeded: jobData.workersNeeded || 1,\n        duration: jobData.duration,\n        durationType: jobData.durationType,\n        tags: jobData.tags || [],\n        attachments: jobData.attachments || [],\n        requireScreenshots: jobData.requireScreenshots || 0,\n        screenshotCost: (jobData.requireScreenshots || 0) * 0.05,\n        estimatedApprovalDays: jobData.estimatedApprovalDays || 1,\n        requiredProof: jobData.requirements,\n        submittedAt: new Date().toISOString(),\n        approvedAt: shouldAutoApprove ? new Date().toISOString() : undefined,\n        approvedBy: shouldAutoApprove ? \"System (Auto-approval)\" : undefined,\n        approvalReason: shouldAutoApprove ? \"Automatically approved - Auto-approval is enabled\" : undefined,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        category: category || {\n            id: jobData.categoryId || \"\",\n            name: \"General\",\n            slug: \"general\"\n        },\n        subcategory: subcategory ? {\n            id: subcategory.id,\n            name: subcategory.name,\n            slug: subcategory.slug,\n            thumbnail: subcategory.thumbnail\n        } : undefined,\n        poster: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            rating: 4.5,\n            totalReviews: 0\n        }\n    };\n    const jobs = getStoredJobs();\n    jobs.push(newJob);\n    saveJobs(jobs);\n    const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n    await createNotification({\n        userId,\n        type: \"job\",\n        title: shouldAutoApprove ? \"Job Approved\" : \"Job Submitted for Review\",\n        description: shouldAutoApprove ? 'Your job \"'.concat(newJob.title, '\" has been automatically approved and is now live') : 'Your job \"'.concat(newJob.title, '\" has been submitted and is pending admin review'),\n        actionUrl: \"/dashboard/jobs\"\n    });\n    console.log(\"[v0] ✅ JOB CREATION: Job created successfully with ID:\", newJob.id);\n    console.log(\"[v0] ✅ JOB CREATION: Final job status:\", newJob.status);\n    console.log(\"[v0] ✅ JOB CREATION: Auto-approved:\", shouldAutoApprove);\n    return newJob;\n}\nasync function approveJob(jobId, adminId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"approved\", adminId, reason);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"open\", adminId, reason || \"Job approved by admin\", {\n        reviewId: \"review-\".concat(Date.now()),\n        decision: \"accepted\",\n        feedback: reason\n    });\n    return updatedJob;\n}\nasync function rejectJob(jobId, adminId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"rejected\", adminId, reason);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"rejected\", adminId, reason, {\n        reviewId: \"review-\".concat(Date.now()),\n        decision: \"rejected\",\n        feedback: reason\n    });\n    return updatedJob;\n}\nasync function suspendJob(jobId, adminId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", adminId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", adminId, \"Job suspended by admin\", {\n        reviewId: \"review-\".concat(Date.now()),\n        decision: \"revision_requested\",\n        feedback: \"Job suspended by admin\"\n    });\n    return updatedJob;\n}\nasync function getPendingJobs() {\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.status === \"pending\");\n}\nasync function getApprovedJobs() {\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.status === \"approved\" || job.status === \"open\");\n}\nasync function getAllJobs() {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const populatedJobs = await Promise.all(jobs.map(populateJobCategoryData));\n    return populatedJobs;\n}\nasync function getAllUserJobs(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.userId === userId);\n}\nasync function updateJob(jobId, updates) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const updatedJob = {\n        ...jobs[jobIndex],\n        ...updates,\n        updatedAt: new Date().toISOString(),\n        // If job is edited, it needs re-approval\n        status: updates.status || \"pending\"\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    return updatedJob;\n}\nasync function cancelJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Get work proofs to see how many workers have submitted work\n    const workProofs = getStoredWorkProofs().filter((wp)=>wp.jobId === jobId);\n    const submittedWorkCount = workProofs.length;\n    const remainingSlots = job.workersNeeded - submittedWorkCount;\n    const jobCostPerWorker = job.budgetMax;\n    const platformFeePerWorker = jobCostPerWorker * 0.05;\n    const totalCostPerWorker = jobCostPerWorker + platformFeePerWorker;\n    const refundAmount = remainingSlots > 0 ? remainingSlots * totalCostPerWorker : 0;\n    if (refundAmount > 0) {\n        try {\n            const { addWalletTransaction } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n            await addWalletTransaction({\n                userId,\n                type: \"refund\",\n                amount: refundAmount,\n                description: 'Refund for cancelled job: \"'.concat(job.title, '\" (Job #').concat(job.formattedJobId || job.id, \") - \").concat(remainingSlots, \" remaining slots + platform fees\"),\n                referenceId: jobId,\n                referenceType: \"job_cancellation\",\n                balanceType: \"deposit\"\n            });\n            console.log(\"[v0] ✅ Job cancellation refund processed: $\".concat(refundAmount));\n        } catch (error) {\n            if (error instanceof Error && error.message.includes(\"already exists\")) {\n                console.log(\"[v0] ⚠️ Job cancellation refund already processed for job: \".concat(jobId));\n            } else {\n                console.error(\"[v0] ❌ Failed to process job cancellation refund:\", error);\n                throw error;\n            }\n        }\n    }\n    // Update job status to cancelled but keep it accessible for submitted work review\n    const updatedJob = {\n        ...job,\n        status: \"cancelled\",\n        updatedAt: new Date().toISOString(),\n        cancellationDetails: {\n            cancelledAt: new Date().toISOString(),\n            submittedWorkCount,\n            remainingSlots,\n            refundAmount,\n            canReviewSubmissions: submittedWorkCount > 0\n        }\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"cancelled\", userId, \"Job cancelled. \".concat(submittedWorkCount, \" work submissions can still be reviewed. \").concat(remainingSlots, \" slots refunded including platform fee.\"), {\n        userAction: \"cancel\",\n        submittedWorkCount,\n        remainingSlots,\n        refundAmount,\n        canReviewSubmissions: submittedWorkCount > 0\n    });\n    console.log(\"[v0] Job \".concat(jobId, \" cancelled. Refund: $\").concat(refundAmount, \" (including platform fee), Submitted work: \").concat(submittedWorkCount));\n    return {\n        job: updatedJob,\n        refundAmount\n    };\n}\nasync function pauseJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", userId, \"Job paused by owner\", {\n        userAction: \"pause\"\n    });\n    return updatedJob;\n}\nasync function reactivateJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const oldStatus = jobs[jobIndex].status;\n    // Reactivated jobs need re-approval\n    const updatedJob = await updateJobStatus(jobId, \"pending\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"pending\", userId, \"Job reactivated and resubmitted for approval\", {\n        userAction: \"reactivate\"\n    });\n    return updatedJob;\n}\nasync function getUserApplications(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const jobs = getStoredJobs();\n    // Filter applications by user and add job details\n    const userApplications = applications.filter((app)=>app.applicantId === userId).map((app)=>{\n        const job = jobs.find((j)=>j.id === app.jobId);\n        return {\n            ...app,\n            job: job || null,\n            appliedAt: app.createdAt\n        };\n    });\n    return userApplications;\n}\n\nasync function submitWorkProof(data) {\n    var _users_find, _users_find1, _users_find2;\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] 📝 WORK PROOF: Starting work proof submission\");\n    console.log(\"[v0] 📝 WORK PROOF: Job ID:\", data.jobId);\n    console.log(\"[v0] 📝 WORK PROOF: Worker ID:\", data.workerId);\n    const users = (0,_auth__WEBPACK_IMPORTED_MODULE_3__.getAllUsers)();\n    const workerUser = users.find((u)=>u.id === data.workerId);\n    console.log(\"[v0] 👤 Found worker user:\", workerUser === null || workerUser === void 0 ? void 0 : workerUser.firstName, workerUser === null || workerUser === void 0 ? void 0 : workerUser.lastName, workerUser === null || workerUser === void 0 ? void 0 : workerUser.username);\n    // Get job details to check approval type\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (!job) {\n        throw new Error(\"Job not found\");\n    }\n    console.log(\"[v0] 📝 WORK PROOF: Job approval type:\", job.approvalType);\n    console.log(\"[v0] 📝 WORK PROOF: Instant approval enabled:\", job.isInstantApprovalEnabled);\n    // Get application details\n    const applications = getStoredApplications();\n    const application = applications.find((app)=>app.id === data.applicationId);\n    if (!application) {\n        throw new Error(\"Application not found\");\n    }\n    const paymentAmount = application.proposedBudget || job.budgetMax || job.budgetMin;\n    const shouldProcessInstantPayment = job.approvalType === \"instant\" && job.isInstantApprovalEnabled === true;\n    console.log(\"[v0] 📝 WORK PROOF: Should process instant payment:\", shouldProcessInstantPayment);\n    console.log(\"[v0] 📝 WORK PROOF: Payment amount:\", paymentAmount);\n    const newProof = {\n        id: Date.now().toString(),\n        jobId: data.jobId,\n        applicationId: data.applicationId,\n        workerId: data.workerId,\n        employerId: job.userId,\n        title: data.title,\n        description: data.description,\n        submissionText: data.submissionText,\n        proofFiles: data.proofFiles || [],\n        proofLinks: data.proofLinks || [],\n        screenshots: data.screenshots || [],\n        attachments: data.attachments || [],\n        status: shouldProcessInstantPayment ? \"approved\" : \"submitted\",\n        submittedAt: new Date().toISOString(),\n        approvedAt: shouldProcessInstantPayment ? new Date().toISOString() : undefined,\n        paymentAmount,\n        submissionNumber: 1,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        worker: {\n            id: data.workerId,\n            firstName: (workerUser === null || workerUser === void 0 ? void 0 : workerUser.firstName) || \"Unknown\",\n            lastName: (workerUser === null || workerUser === void 0 ? void 0 : workerUser.lastName) || \"Worker\",\n            username: (workerUser === null || workerUser === void 0 ? void 0 : workerUser.username) || \"user\".concat(data.workerId),\n            avatar: workerUser === null || workerUser === void 0 ? void 0 : workerUser.avatar\n        },\n        employer: {\n            id: job.userId,\n            firstName: ((_users_find = users.find((u)=>u.id === job.userId)) === null || _users_find === void 0 ? void 0 : _users_find.firstName) || \"Job\",\n            lastName: ((_users_find1 = users.find((u)=>u.id === job.userId)) === null || _users_find1 === void 0 ? void 0 : _users_find1.lastName) || \"Poster\",\n            username: ((_users_find2 = users.find((u)=>u.id === job.userId)) === null || _users_find2 === void 0 ? void 0 : _users_find2.username) || \"jobposter\"\n        }\n    };\n    if (shouldProcessInstantPayment) {\n        try {\n            console.log(\"[v0] 💰 INSTANT PAYMENT: Processing instant payment for work proof\");\n            const { addWalletTransaction } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n            // Calculate platform fee (5% default)\n            const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n            let platformFeeRate = 0.05 // Default fallback\n            ;\n            let platformFee = 0;\n            if (platformFeeSettings) {\n                const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(paymentAmount, platformFeeSettings);\n                platformFee = feeCalculation.platformFee;\n                platformFeeRate = platformFeeSettings.feePercentage / 100;\n            } else {\n                platformFee = Math.round(paymentAmount * platformFeeRate * 100) / 100;\n            }\n            const workerAmount = Math.round((paymentAmount - platformFee) * 100) / 100;\n            console.log(\"[v0] 💰 INSTANT PAYMENT: Total amount:\", paymentAmount);\n            console.log(\"[v0] 💰 INSTANT PAYMENT: Platform fee:\", platformFee);\n            console.log(\"[v0] 💰 INSTANT PAYMENT: Worker receives:\", workerAmount);\n            // Add money to worker's withdrawal balance\n            await addWalletTransaction({\n                userId: data.workerId,\n                type: \"job_payment\",\n                amount: workerAmount,\n                description: \"Instant payment for job: \".concat(job.title),\n                referenceId: data.jobId,\n                referenceType: \"job_payment\",\n                balanceType: \"withdrawal\"\n            });\n            // Record platform fee\n            await addWalletTransaction({\n                userId: \"platform\",\n                type: \"platform_fee\",\n                amount: platformFee,\n                description: \"Platform fee for job: \".concat(job.title),\n                referenceId: data.jobId,\n                referenceType: \"platform_fee\",\n                balanceType: \"withdrawal\"\n            });\n            newProof.approvedAt = new Date().toISOString();\n            newProof.approvedBy = \"System (Instant Approval)\";\n            newProof.paymentProcessedAt = new Date().toISOString();\n            console.log(\"[v0] ✅ INSTANT PAYMENT: Payment processed successfully\");\n            // Create notification for worker\n            const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n            await createNotification({\n                userId: data.workerId,\n                type: \"payment\",\n                title: \"Instant Payment Received! 💰\",\n                description: \"You received $\".concat(workerAmount.toFixed(2), ' for completing \"').concat(job.title, '\". Payment has been added to your withdrawal balance.'),\n                actionUrl: \"/dashboard/wallet\"\n            });\n            // Create notification for employer\n            await createNotification({\n                userId: job.userId,\n                type: \"job\",\n                title: \"Work Submitted & Payment Released\",\n                description: 'Work has been submitted for \"'.concat(job.title, '\" and instant payment of $').concat(paymentAmount.toFixed(2), \" has been released to the worker.\"),\n                actionUrl: \"/dashboard/jobs/\".concat(data.jobId)\n            });\n            console.log(\"[v0] ✅ INSTANT PAYMENT: Notifications sent successfully\");\n        } catch (error) {\n            console.error(\"[v0] ❌ INSTANT PAYMENT: Error processing instant payment:\", error);\n            // Don't fail the work proof submission, just log the error\n            newProof.status = \"submitted\";\n            newProof.paymentError = error.message;\n        }\n    } else {\n        console.log(\"[v0] 📝 WORK PROOF: Manual approval required, creating notification for employer\");\n        const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n        await createNotification({\n            userId: job.userId,\n            type: \"job\",\n            title: \"Work Submitted for Review\",\n            description: 'Work has been submitted for \"'.concat(job.title, '\". Please review and approve within ').concat(job.manualApprovalDays || 3, \" days.\"),\n            actionUrl: \"/dashboard/jobs/\".concat(data.jobId)\n        });\n    }\n    const workProofs = getStoredWorkProofs();\n    workProofs.push(newProof);\n    saveWorkProofs(workProofs);\n    console.log(\"[v0] ✅ WORK PROOF: Work proof saved successfully with status:\", newProof.status);\n    return newProof;\n}\nasync function getWorkProofsByJob(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const workProofs = getStoredWorkProofs();\n    return workProofs.filter((proof)=>proof.jobId === jobId);\n}\nasync function getWorkProofsByWorker(workerId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const workProofs = getStoredWorkProofs();\n    return workProofs.filter((proof)=>proof.workerId === workerId);\n}\nasync function getWorkProofs(jobId) {\n    return await getWorkProofsByJob(jobId);\n}\nasync function reviewWorkProof(proofId, reviewData) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const workProofs = getStoredWorkProofs();\n    const proofIndex = workProofs.findIndex((proof)=>proof.id === proofId);\n    if (proofIndex === -1) {\n        throw new Error(\"Work proof not found\");\n    }\n    const proof = workProofs[proofIndex];\n    // Update proof status\n    workProofs[proofIndex] = {\n        ...proof,\n        status: reviewData.decision === \"accepted\" ? \"accepted\" : reviewData.decision === \"rejected\" ? \"rejected\" : \"revision_requested\",\n        updatedAt: new Date().toISOString()\n    };\n    saveWorkProofs(workProofs);\n    // Create review record\n    const review = {\n        id: \"review-\".concat(Date.now()),\n        jobId: proof.jobId,\n        proofId: proofId,\n        reviewerId: reviewData.reviewerId,\n        decision: reviewData.decision,\n        feedback: reviewData.feedback,\n        revisionNotes: reviewData.revisionNotes,\n        reviewedAt: new Date().toISOString()\n    };\n    // Store review (in real app, this would go to database)\n    const reviews = getStoredJobReviews();\n    reviews.push(review);\n    saveJobReviews(reviews);\n    // Update job and application status based on decision\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === proof.jobId);\n    if (jobIndex !== -1) {\n        const oldStatus = jobs[jobIndex].status;\n        let newStatus = oldStatus;\n        if (reviewData.decision === \"accepted\") {\n            // Update job to completed\n            newStatus = \"completed\";\n            jobs[jobIndex] = {\n                ...jobs[jobIndex],\n                status: \"completed\",\n                updatedAt: new Date().toISOString()\n            };\n            recordStatusChange(proof.jobId, oldStatus, \"completed\", reviewData.reviewerId, \"Work proof accepted - job completed\", {\n                reviewId: review.id,\n                decision: \"accepted\",\n                feedback: reviewData.feedback\n            });\n        } else if (reviewData.decision === \"rejected\") {\n            recordStatusChange(proof.jobId, oldStatus, oldStatus, reviewData.reviewerId, \"Work proof rejected - awaiting rework or dispute\", {\n                reviewId: review.id,\n                decision: \"rejected\",\n                feedback: reviewData.feedback,\n                revisionNotes: reviewData.revisionNotes\n            });\n        } else {\n            recordStatusChange(proof.jobId, oldStatus, oldStatus, reviewData.reviewerId, \"Revision requested on work proof\", {\n                reviewId: review.id,\n                decision: \"revision_requested\",\n                revisionNotes: reviewData.revisionNotes\n            });\n        }\n        saveJobs(jobs);\n        // Update application to completed if accepted\n        if (reviewData.decision === \"accepted\") {\n            const applications = getStoredApplications();\n            const appIndex = applications.findIndex((app)=>app.jobId === proof.jobId && app.applicantId === proof.workerId);\n            if (appIndex !== -1) {\n                applications[appIndex] = {\n                    ...applications[appIndex],\n                    status: \"completed\"\n                };\n                saveApplications(applications);\n            }\n        }\n    }\n    return review;\n}\nasync function getJobApplicationById(applicationId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    return applications.find((app)=>app.id === applicationId) || null;\n}\nasync function updateJobStatus(jobId, newStatus, userId, metadata) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    const updatedJob = {\n        ...job,\n        status: newStatus,\n        updatedAt: new Date().toISOString(),\n        ...newStatus === \"completed\" && {\n            completedAt: new Date().toISOString()\n        }\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    // Add to status history\n    const statusHistory = getStoredJobStatusHistory();\n    statusHistory.push({\n        id: \"status_\".concat(Date.now()),\n        jobId,\n        userId,\n        oldStatus,\n        newStatus,\n        notes: (metadata === null || metadata === void 0 ? void 0 : metadata.notes) || \"Status changed from \".concat(oldStatus, \" to \").concat(newStatus),\n        metadata,\n        createdAt: new Date().toISOString()\n    });\n    saveJobStatusHistory(statusHistory);\n    console.log(\"[v0] Job status updated:\", jobId, \"from\", oldStatus, \"to\", newStatus);\n    if (newStatus === \"completed\") {\n        try {\n            const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n            // Notify job poster\n            await createNotification({\n                userId: job.userId,\n                type: \"job\",\n                title: \"Job Completed Successfully\",\n                description: 'Your job \"'.concat(job.title, '\" has been completed by all required workers.'),\n                actionUrl: \"/dashboard/jobs/\".concat(jobId)\n            });\n            // If there are multiple workers, notify them all\n            if ((metadata === null || metadata === void 0 ? void 0 : metadata.totalWorkersCompleted) && metadata.totalWorkersCompleted > 1) {\n                const { getJobApplications } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./jobs */ \"(app-pages-browser)/./lib/jobs.ts\"));\n                const applications = await getJobApplications(jobId);\n                const acceptedWorkers = applications.filter((app)=>app.status === \"accepted\");\n                for (const app of acceptedWorkers){\n                    await createNotification({\n                        userId: app.applicantId,\n                        type: \"job\",\n                        title: \"Job Fully Completed\",\n                        description: 'The job \"'.concat(job.title, '\" has been completed by all required workers.'),\n                        actionUrl: \"/dashboard/applied-jobs\"\n                    });\n                }\n            }\n        } catch (error) {\n            console.error(\"[v0] Failed to send completion notifications:\", error);\n        }\n    }\n    return updatedJob;\n}\nconst JOB_STATUS = {\n    PENDING: \"pending\",\n    APPROVED: \"approved\",\n    REJECTED: \"rejected\",\n    SUSPENDED: \"suspended\",\n    OPEN: \"open\",\n    IN_PROGRESS: \"in_progress\",\n    COMPLETED: \"completed\",\n    CANCELLED: \"cancelled\"\n};\nconst getJobStatusColor = (status)=>{\n    switch(status){\n        case JOB_STATUS.PENDING:\n            return \"bg-yellow-100 text-yellow-800\";\n        case JOB_STATUS.APPROVED:\n        case JOB_STATUS.OPEN:\n            return \"bg-green-100 text-green-800\";\n        case JOB_STATUS.REJECTED:\n            return \"bg-red-100 text-red-800\";\n        case JOB_STATUS.SUSPENDED:\n            return \"bg-gray-100 text-gray-800\";\n        case JOB_STATUS.IN_PROGRESS:\n            return \"bg-blue-100 text-blue-800\";\n        case JOB_STATUS.COMPLETED:\n            return \"bg-purple-100 text-purple-800\";\n        case JOB_STATUS.CANCELLED:\n            return \"bg-orange-100 text-orange-800\";\n        default:\n            return \"bg-gray-100 text-gray-800\";\n    }\n};\nconst getJobStatusLabel = (status)=>{\n    switch(status){\n        case JOB_STATUS.PENDING:\n            return \"Pending Review\";\n        case JOB_STATUS.APPROVED:\n            return \"Approved\";\n        case JOB_STATUS.REJECTED:\n            return \"Rejected\";\n        case JOB_STATUS.SUSPENDED:\n            return \"Suspended\";\n        case JOB_STATUS.OPEN:\n            return \"Open\";\n        case JOB_STATUS.IN_PROGRESS:\n            return \"In Progress\";\n        case JOB_STATUS.COMPLETED:\n            return \"Completed\";\n        case JOB_STATUS.CANCELLED:\n            return \"Cancelled\";\n        default:\n            return status;\n    }\n};\nconst canApplyToJob = (job)=>{\n    return job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN;\n};\nconst isJobVisible = function(job) {\n    let userType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"user\";\n    if (userType === \"admin\") {\n        return true // Admins can see all jobs\n        ;\n    }\n    // Regular users can only see approved/open jobs\n    return job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN;\n};\nconst getAvailableJobs = async (currentUserId)=>{\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>{\n        // Basic status filter - only show approved/open jobs that aren't completed\n        const isValidStatus = (job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN) && job.status !== JOB_STATUS.COMPLETED;\n        if (!isValidStatus) return false;\n        const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n        const currentApplications = job.applicationsCount || 0;\n        // If job has reached its worker limit, don't show it as available\n        if (currentApplications >= workersNeeded) {\n            console.log(\"[v0] Job\", job.id, \"at capacity:\", currentApplications, \"of\", workersNeeded, \"workers\");\n            return false;\n        }\n        const reservationInfo = _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__.localReservationStorage.isJobReserved(job.id);\n        // If job is not reserved, show it to everyone\n        if (!reservationInfo.isReserved) return true;\n        // If job needs multiple workers, show it even when reserved (partial reservation)\n        if (job.workersNeeded > 1) return true;\n        // For single-worker jobs that are reserved:\n        // Only show to the user who reserved it, hide from others\n        if (job.workersNeeded === 1 && reservationInfo.isReserved) {\n            return currentUserId === reservationInfo.userId;\n        }\n        return true;\n    });\n};\nconst getJobsForDashboard = (jobs, currentUserId)=>{\n    return jobs.filter((job)=>{\n        // Basic status filter\n        const isValidStatus = (job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN) && job.status !== JOB_STATUS.COMPLETED;\n        if (!isValidStatus) return false;\n        const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n        const currentApplications = job.applicationsCount || 0;\n        // If job has reached its worker limit, don't show it as available\n        if (currentApplications >= workersNeeded) {\n            console.log(\"[v0] Dashboard job\", job.id, \"at capacity:\", currentApplications, \"of\", workersNeeded, \"workers\");\n            return false;\n        }\n        const reservationInfo = _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__.localReservationStorage.isJobReserved(job.id);\n        // If job is not reserved, show it to everyone\n        if (!reservationInfo.isReserved) return true;\n        // If job needs multiple workers, show it even when reserved\n        if (job.workersNeeded > 1) return true;\n        // For single-worker jobs that are reserved:\n        // Only show to the user who reserved it\n        if (job.workersNeeded === 1 && reservationInfo.isReserved) {\n            return currentUserId === reservationInfo.userId;\n        }\n        return true;\n    });\n};\n// Function to get job status history\nasync function getJobStatusHistory(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const history = getStoredJobStatusHistory();\n    return history.filter((entry)=>entry.jobId === jobId).sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n}\n// Function to get all status history for admin\nasync function getAllJobStatusHistory() {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const history = getStoredJobStatusHistory();\n    return history.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n}\nasync function acceptJobApplication(applicationId, employerId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const applicationIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (applicationIndex === -1) {\n        throw new Error(\"Application not found\");\n    }\n    const application = applications[applicationIndex];\n    // Verify employer owns the job\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === application.jobId);\n    const job = jobs[jobIndex];\n    if (!job || job.userId !== employerId) {\n        throw new Error(\"You don't have permission to accept this application\");\n    }\n    const updatedApplication = {\n        ...application,\n        status: \"accepted\",\n        acceptedAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    applications[applicationIndex] = updatedApplication;\n    saveApplications(applications);\n    const updatedJob = {\n        ...job,\n        status: \"completed\",\n        assignedWorkerId: application.applicantId,\n        completedAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    try {\n        const { addWalletTransaction } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n        const paymentAmount = application.proposedBudget;\n        if (!paymentAmount || paymentAmount <= 0) {\n            throw new Error(\"Invalid payment amount: \".concat(paymentAmount));\n        }\n        // Calculate platform fee (5% default)\n        const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n        let platformFeeRate = 0.05 // Default fallback\n        ;\n        let platformFee = 0;\n        if (platformFeeSettings) {\n            const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(paymentAmount, platformFeeSettings);\n            platformFee = feeCalculation.platformFee;\n            platformFeeRate = platformFeeSettings.feePercentage / 100;\n        } else {\n            platformFee = Math.round(paymentAmount * platformFeeRate * 100) / 100;\n        }\n        const workerAmount = Math.round((paymentAmount - platformFee) * 100) / 100 // Round to 2 decimals\n        ;\n        console.log(\"[v0] \\uD83D\\uDCB0 Processing instant payment:\");\n        console.log(\"[v0] - Total job amount: $\".concat(paymentAmount));\n        console.log(\"[v0] - Platform fee (5%): $\".concat(platformFee));\n        console.log(\"[v0] - Worker receives: $\".concat(workerAmount));\n        console.log(\"[v0] - Worker ID: \".concat(application.applicantId));\n        // Add money to worker's withdrawal balance\n        await addWalletTransaction(application.applicantId, {\n            type: \"job_payment\",\n            amount: workerAmount,\n            description: \"Payment for job: \".concat(job.title),\n            jobId: job.id,\n            fromUserId: employerId\n        });\n        console.log(\"[v0] ✅ Payment successfully added to worker \".concat(application.applicantId, \" wallet: $\").concat(workerAmount));\n        // Record platform fee\n        await addWalletTransaction(\"platform\", {\n            type: \"platform_fee\",\n            amount: platformFee,\n            description: \"Platform fee for job: \".concat(job.title),\n            jobId: job.id,\n            fromUserId: employerId\n        });\n        console.log(\"[v0] ✅ Platform fee recorded: $\".concat(platformFee));\n    } catch (error) {\n        console.error(\"[v0] ❌ Error processing instant payment:\", error);\n        throw new Error(\"Payment processing failed: \".concat(error.message));\n    }\n    // Create notification for applicant\n    const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: application.applicantId,\n        type: \"job\",\n        title: \"Job Accepted & Payment Released!\",\n        description: 'Your application for \"'.concat(job.title, '\" has been accepted and payment of $').concat(application.proposedBudget - application.proposedBudget * 0.05, \" has been added to your withdrawal balance!\"),\n        actionUrl: \"/dashboard/wallet\"\n    });\n    // Create notification for employer\n    await createNotification({\n        userId: employerId,\n        type: \"job\",\n        title: \"Job Completed\",\n        description: 'Job \"'.concat(job.title, '\" has been completed and payment has been released to the worker.'),\n        actionUrl: \"/dashboard/jobs\"\n    });\n    return updatedApplication;\n}\nasync function rejectJobApplication(applicationId, employerId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const applicationIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (applicationIndex === -1) {\n        throw new Error(\"Application not found\");\n    }\n    const application = applications[applicationIndex];\n    // Verify employer owns the job\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === application.jobId);\n    if (!job || job.userId !== employerId) {\n        throw new Error(\"You don't have permission to reject this application\");\n    }\n    const updatedApplication = {\n        ...application,\n        status: \"rejected\",\n        rejectedAt: new Date().toISOString(),\n        rejectionReason: reason,\n        updatedAt: new Date().toISOString()\n    };\n    applications[applicationIndex] = updatedApplication;\n    saveApplications(applications);\n    // Create notification for applicant\n    const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: application.applicantId,\n        type: \"job\",\n        title: \"Application Rejected\",\n        description: 'Your application for \"'.concat(job.title, '\" was not selected. Keep applying to other opportunities!'),\n        actionUrl: \"/dashboard/applied-jobs\"\n    });\n    return updatedApplication;\n}\nasync function getUserJobs(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const userJobs = jobs.filter((job)=>job.userId === userId);\n    const jobsWithCounts = await Promise.all(userJobs.map(async (job)=>{\n        try {\n            // Get applications for this job\n            const applications = await getJobApplications(job.id);\n            const applicationsCount = applications.length;\n            console.log(\"[v0] Job \".concat(job.id, \" (\").concat(job.title, \"): Found \").concat(applicationsCount, \" applications\"));\n            // Update the job with actual counts\n            return {\n                ...job,\n                applicationsCount,\n                // For now, we'll use a simple view count based on applications\n                // In a real system, this would be tracked separately\n                viewsCount: Math.max(job.viewsCount || 0, applicationsCount * 2)\n            };\n        } catch (error) {\n            console.error(\"[v0] Error counting applications for job \".concat(job.id, \":\"), error);\n            return job;\n        }\n    }));\n    return jobsWithCounts;\n}\nasync function applyToJob(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] 🔍 WORKER VALIDATION: Checking application for job:\", data.jobId, \"by worker:\", data.applicantId);\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (!job) {\n        throw new Error(\"Job not found\");\n    }\n    if (job.status !== \"approved\") {\n        throw new Error(\"Job is not available for applications\");\n    }\n    // Check if user already applied to this job\n    const existingApplications = getStoredApplications();\n    const existingApplication = existingApplications.find((app)=>app.jobId === data.jobId && app.applicantId === data.applicantId);\n    if (existingApplication) {\n        console.log(\"[v0] ⚠️ WORKER VALIDATION: User already applied to this job - treating as resubmission\");\n        // Update existing application instead of creating new one\n        const applications = JSON.parse(localStorage.getItem(\"job_applications\") || \"[]\");\n        const applicationIndex = applications.findIndex((app)=>app.id === existingApplication.id);\n        if (applicationIndex !== -1) {\n            applications[applicationIndex] = {\n                ...applications[applicationIndex],\n                coverLetter: data.coverLetter,\n                proposedBudget: data.proposedBudget,\n                estimatedDuration: data.estimatedDuration,\n                portfolioLinks: data.portfolioLinks,\n                updatedAt: new Date().toISOString(),\n                resubmissionCount: (applications[applicationIndex].resubmissionCount || 0) + 1\n            };\n            localStorage.setItem(\"job_applications\", JSON.stringify(applications));\n            console.log(\"[v0] ✅ WORKER VALIDATION: Application updated as resubmission\");\n            return applications[applicationIndex];\n        }\n    }\n    // Check if job has reached worker limit\n    const acceptedApplications = existingApplications.filter((app)=>app.status === \"accepted\");\n    const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n    if (acceptedApplications.length >= workersNeeded) {\n        throw new Error(\"This job has already reached its worker limit of \".concat(workersNeeded, \" workers\"));\n    }\n    console.log(\"[v0] ✅ WORKER VALIDATION: New application allowed\");\n    console.log(\"[v0] 📊 WORKER VALIDATION: Current accepted workers:\", acceptedApplications.length, \"/ Needed:\", workersNeeded);\n    // Get user data for application\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(app-pages-browser)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === data.applicantId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const newApplication = {\n        id: \"app_\".concat(Date.now()),\n        jobId: data.jobId,\n        applicantId: data.applicantId,\n        coverLetter: data.coverLetter,\n        proposedBudget: data.proposedBudget,\n        estimatedDuration: data.estimatedDuration,\n        portfolioLinks: data.portfolioLinks,\n        status: \"pending\",\n        createdAt: new Date().toISOString(),\n        applicant: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            avatar: user.avatar,\n            rating: user.rating,\n            totalReviews: user.totalReviews,\n            skills: user.skills\n        }\n    };\n    const applications = getStoredApplications();\n    applications.push(newApplication);\n    saveApplications(applications);\n    // Update job application count\n    const jobIndex = jobs.findIndex((j)=>j.id === data.jobId);\n    if (jobIndex !== -1) {\n        jobs[jobIndex].applicationsCount = (jobs[jobIndex].applicationsCount || 0) + 1;\n        saveJobs(jobs);\n    }\n    // Create notification for job poster\n    const { createNotification } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_notifications_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(app-pages-browser)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: job.userId,\n        type: \"job\",\n        title: \"New Job Application\",\n        description: \"\".concat(user.firstName, \" \").concat(user.lastName, ' applied for your job \"').concat(job.title, '\"'),\n        actionUrl: \"/dashboard/jobs/\".concat(job.id, \"/applications\")\n    });\n    return newApplication;\n}\nasync function createJob(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    console.log(\"[v0] 💼 JOB CREATION: Starting job creation process\");\n    console.log(\"[v0] 💼 JOB CREATION: Workers needed:\", data.workersNeeded);\n    console.log(\"[v0] 💼 JOB CREATION: Budget per worker:\", data.budgetMin, \"-\", data.budgetMax);\n    console.log(\"[v0] 💼 JOB CREATION: Screenshot requirements:\", data.requireScreenshots || 0);\n    console.log(\"[v0] 💼 JOB CREATION: Approval type:\", data.approvalType);\n    console.log(\"[v0] 💼 JOB CREATION: Manual approval days:\", data.manualApprovalDays);\n    console.log(\"[v0] 💼 JOB CREATION: Country restrictions enabled:\", data.enableCountryRestrictions);\n    console.log(\"[v0] 💼 JOB CREATION: Restriction type:\", data.restrictionType);\n    console.log(\"[v0] 💼 JOB CREATION: Allowed countries:\", data.allowedCountries);\n    console.log(\"[v0] 💼 JOB CREATION: Restricted countries:\", data.restrictedCountries);\n    const isInstantApproval = data.approvalType === \"instant\";\n    const isInstantApprovalEnabled = ()=>{\n        try {\n            // Check if we're in browser environment\n            if ( true && typeof localStorage !== \"undefined\") {\n                const setting = localStorage.getItem(\"admin_instant_approval_enabled\");\n                console.log(\"[v0] 🔧 INSTANT-APPROVAL: localStorage setting found:\", setting);\n                const enabled = setting === \"true\";\n                console.log(\"[v0] 🔧 INSTANT-APPROVAL: Instant approval enabled:\", enabled);\n                return enabled;\n            } else {\n                // On server side or when localStorage is not available, default to true for instant approval requests\n                console.log(\"[v0] 🔧 INSTANT-APPROVAL: Server side or no localStorage, defaulting to true for instant requests\");\n                return isInstantApproval;\n            }\n        } catch (error) {\n            console.error(\"[v0] 🔧 INSTANT-APPROVAL: Error checking setting:\", error);\n            // If there's an error, allow instant approval if user requested it\n            return isInstantApproval;\n        }\n    };\n    const getDefaultManualApprovalDays = ()=>{\n        try {\n            if ( true && typeof localStorage !== \"undefined\") {\n                const defaultDays = localStorage.getItem(\"admin_default_manual_approval_days\");\n                return defaultDays ? Number.parseInt(defaultDays) : 3;\n            }\n            return 3 // Default fallback\n            ;\n        } catch (error) {\n            console.error(\"[v0] 🔧 DEFAULT-DAYS: Error getting default days:\", error);\n            return 3;\n        }\n    };\n    const canUseInstantApproval = isInstantApproval && isInstantApprovalEnabled();\n    const existingJobs = getStoredJobs();\n    const nextJobNumber = existingJobs.length + 1;\n    const formattedJobId = String(nextJobNumber).padStart(3, \"0\");\n    console.log(\"[v0] 💼 JOB CREATION: Generated job number:\", nextJobNumber, \"formatted as:\", formattedJobId);\n    const jobStatus = \"approved\" // All jobs are approved immediately, instant payment happens on work submission\n    ;\n    const finalManualApprovalDays = data.manualApprovalDays || getDefaultManualApprovalDays();\n    console.log(\"[v0] 🔧 INSTANT-APPROVAL: User requested instant approval:\", isInstantApproval);\n    console.log(\"[v0] 🔧 INSTANT-APPROVAL: Can use instant approval:\", canUseInstantApproval);\n    console.log(\"[v0] 🔧 INSTANT-APPROVAL: Job status will be:\", jobStatus);\n    console.log(\"[v0] 🔧 MANUAL-APPROVAL: Final manual approval days:\", finalManualApprovalDays);\n    const budgetPerWorker = data.budgetMax || data.budgetMin;\n    const baseJobCost = budgetPerWorker * data.workersNeeded;\n    // Calculate screenshot costs\n    let screenshotCost = 0;\n    if (data.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_screenshot-pricing_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(app-pages-browser)/./lib/screenshot-pricing.ts\"));\n            const screenshotCalculation = await calculateScreenshotCosts(data.requireScreenshots, baseJobCost);\n            screenshotCost = screenshotCalculation.totalScreenshotCost;\n            console.log(\"[v0] 📸 JOB CREATION: Screenshot cost calculated:\", screenshotCost);\n        } catch (error) {\n            console.error(\"[v0] 📸 JOB CREATION: Error calculating screenshot costs:\", error);\n            // Fallback calculation\n            screenshotCost = data.requireScreenshots * 0.05;\n        }\n    }\n    const subtotal = baseJobCost + screenshotCost;\n    let platformFee = 0;\n    let platformFeeRate = 0.05 // Default fallback\n    ;\n    try {\n        const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n        if (platformFeeSettings) {\n            const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(subtotal, platformFeeSettings);\n            platformFee = feeCalculation.platformFee;\n            platformFeeRate = platformFeeSettings.feePercentage / 100;\n            console.log(\"[v0] 💰 JOB CREATION: Using configurable platform fee:\", platformFeeSettings.feePercentage + \"%\");\n        } else {\n            platformFee = subtotal * platformFeeRate;\n            console.log(\"[v0] 💰 JOB CREATION: Using default platform fee: 5%\");\n        }\n    } catch (error) {\n        console.error(\"[v0] 💰 JOB CREATION: Error loading platform fee settings, using default:\", error);\n        platformFee = subtotal * platformFeeRate;\n    }\n    const totalWithFees = subtotal + platformFee;\n    console.log(\"[v0] 💰 JOB CREATION: Base job cost:\", baseJobCost);\n    console.log(\"[v0] 💰 JOB CREATION: Screenshot cost:\", screenshotCost);\n    console.log(\"[v0] 💰 JOB CREATION: Subtotal:\", subtotal);\n    console.log(\"[v0] 💰 JOB CREATION: Platform fee:\", platformFee);\n    console.log(\"[v0] 💰 JOB CREATION: Total with fees:\", totalWithFees);\n    // Check and deduct from user's deposit wallet\n    try {\n        const { getWallet, addWalletTransaction } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n        const wallet = await getWallet(data.userId);\n        if (wallet.depositBalance < totalWithFees) {\n            throw new Error(\"Insufficient deposit balance. Required: $\".concat(totalWithFees.toFixed(2), \", Available: $\").concat(wallet.depositBalance.toFixed(2)));\n        }\n        let transactionDescription = \"Job creation deposit for: \".concat(data.title, \" (\").concat(data.workersNeeded, \" workers \\xd7 $\").concat(budgetPerWorker);\n        if (screenshotCost > 0) {\n            transactionDescription += \" + $\".concat(screenshotCost.toFixed(2), \" screenshot fee\");\n        }\n        transactionDescription += \" + $\".concat(platformFee.toFixed(2), \" platform fee)\");\n        // Deduct estimated cost from deposit balance\n        await addWalletTransaction({\n            userId: data.userId,\n            type: \"payment\",\n            amount: -totalWithFees,\n            description: transactionDescription,\n            referenceId: \"job_\".concat(Date.now()),\n            referenceType: \"job_creation\",\n            balanceType: \"deposit\"\n        });\n        console.log(\"[v0] ✅ JOB CREATION: Deposit deducted successfully:\", totalWithFees);\n    } catch (error) {\n        console.error(\"[v0] ❌ JOB CREATION: Deposit deduction failed:\", error);\n        throw new Error(\"Failed to process job creation deposit: \".concat(error.message));\n    }\n    const newJob = {\n        id: \"job_\".concat(Date.now()),\n        jobNumber: nextJobNumber,\n        formattedJobId: formattedJobId,\n        userId: data.userId,\n        categoryId: data.categoryId,\n        subcategoryId: data.subcategoryId,\n        title: data.title,\n        description: data.description,\n        requirements: data.requirements,\n        instructions: data.instructions,\n        budgetMin: data.budgetMin,\n        budgetMax: data.budgetMax,\n        deadline: data.deadline,\n        location: data.location || \"Remote\",\n        isRemote: true,\n        status: jobStatus,\n        priority: \"normal\",\n        skillsRequired: [],\n        applicationsCount: 0,\n        viewsCount: 0,\n        workersNeeded: data.workersNeeded,\n        maxWorkers: data.workersNeeded,\n        tags: data.tags || [],\n        attachments: data.attachments || [],\n        requireScreenshots: data.requireScreenshots || 0,\n        screenshotCost: (data.requireScreenshots || 0) * 0.05,\n        estimatedApprovalDays: data.estimatedApprovalDays || 1,\n        approvalType: data.approvalType || \"manual\",\n        manualApprovalDays: finalManualApprovalDays,\n        isInstantApprovalEnabled: canUseInstantApproval,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        submittedAt: new Date().toISOString(),\n        approvedAt: new Date().toISOString(),\n        approvedBy: \"System\",\n        approvalReason: \"Job approved for posting\",\n        estimatedTotalCost: subtotal,\n        depositDeducted: totalWithFees,\n        enableCountryRestrictions: data.enableCountryRestrictions || false,\n        restrictionType: data.restrictionType || \"include\",\n        allowedCountries: data.allowedCountries || [],\n        restrictedCountries: data.restrictedCountries || [],\n        category: {\n            id: data.categoryId,\n            name: \"Unknown Category\",\n            slug: \"unknown\"\n        }\n    };\n    const jobs = getStoredJobs();\n    jobs.push(newJob);\n    saveJobs(jobs);\n    return newJob;\n}\nasync function toggleJobOn(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Only allow toggle if job was previously approved/open or suspended\n    if (![\n        \"suspended\",\n        \"open\",\n        \"approved\"\n    ].includes(oldStatus)) {\n        throw new Error(\"Job cannot be turned on from current status\");\n    }\n    const updatedJob = await updateJobStatus(jobId, \"open\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"open\", userId, \"Job turned on by owner\", {\n        userAction: \"toggle_on\",\n        instantToggle: true\n    });\n    return updatedJob;\n}\nasync function toggleJobOff(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Only allow toggle if job is currently open/approved\n    if (![\n        \"open\",\n        \"approved\"\n    ].includes(oldStatus)) {\n        throw new Error(\"Job cannot be turned off from current status\");\n    }\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", userId, \"Job turned off by owner\", {\n        userAction: \"toggle_off\",\n        instantToggle: true\n    });\n    return updatedJob;\n}\nasync function updateJobWorkers(jobId, newWorkerCount, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] 👥 UPDATE-WORKERS: Starting worker count update for job:\", jobId);\n    console.log(\"[v0] 👥 UPDATE-WORKERS: New worker count:\", newWorkerCount);\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === jobId && job.userId === userId);\n    if (jobIndex === -1) {\n        console.log(\"[v0] ❌ UPDATE-WORKERS: Job not found or unauthorized\");\n        return {\n            success: false,\n            message: \"Job not found or you don't have permission to modify it.\"\n        };\n    }\n    const job = jobs[jobIndex];\n    const currentWorkerCount = job.workersNeeded;\n    const workerDifference = newWorkerCount - currentWorkerCount;\n    console.log(\"[v0] 👥 UPDATE-WORKERS: Current workers:\", currentWorkerCount);\n    console.log(\"[v0] 👥 UPDATE-WORKERS: Worker difference:\", workerDifference);\n    if (workerDifference === 0) {\n        console.log(\"[v0] 👥 UPDATE-WORKERS: No change in worker count\");\n        return {\n            success: true,\n            message: \"Worker count unchanged.\"\n        };\n    }\n    if (workerDifference < 0) {\n        console.log(\"[v0] 👥 UPDATE-WORKERS: Reducing worker count - no additional payment needed\");\n        jobs[jobIndex].workersNeeded = newWorkerCount;\n        localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n        console.log(\"[v0] 👥 UPDATE-WORKERS: Updated job saved to localStorage with key:\", JOBS_STORAGE_KEY);\n        return {\n            success: true,\n            message: \"Worker count reduced to \".concat(newWorkerCount, \".\")\n        };\n    }\n    const costPerWorker = job.budgetMax || job.budgetMin || 0;\n    const additionalBaseCost = workerDifference * costPerWorker;\n    // Calculate additional screenshot costs proportionally\n    let additionalScreenshotCost = 0;\n    if (job.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_screenshot-pricing_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(app-pages-browser)/./lib/screenshot-pricing.ts\"));\n            // Calculate screenshot cost for new total workers\n            const newTotalBaseCost = newWorkerCount * costPerWorker;\n            // Calculate current screenshot cost for comparison\n            const currentTotalBaseCost = currentWorkerCount * costPerWorker;\n            const currentScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, currentTotalBaseCost)).totalScreenshotCost;\n            const newScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, newTotalBaseCost)).totalScreenshotCost;\n            additionalScreenshotCost = newScreenshotCost - currentScreenshotCost;\n            console.log(\"[v0] 👥 UPDATE-WORKERS: Additional screenshot cost:\", additionalScreenshotCost);\n        } catch (error) {\n            console.error(\"[v0] ❌ UPDATE-WORKERS: Error calculating screenshot costs:\", error);\n        }\n    }\n    const platformFeeRate = 0.05;\n    const subtotal = additionalBaseCost + additionalScreenshotCost;\n    const platformFee = subtotal * platformFeeRate;\n    const totalAdditionalCost = subtotal + platformFee;\n    console.log(\"[v0] 👥 UPDATE-WORKERS: Cost breakdown:\", {\n        additionalBaseCost,\n        additionalScreenshotCost,\n        platformFee,\n        totalAdditionalCost\n    });\n    const { getWallet } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n    // Check wallet balance\n    const wallet = await getWallet(userId);\n    if (wallet.depositBalance < totalAdditionalCost) {\n        console.log(\"[v0] ❌ UPDATE-WORKERS: Insufficient balance\");\n        return {\n            success: false,\n            message: \"Insufficient deposit balance. Required: $\".concat(totalAdditionalCost.toFixed(2), \", Available: $\").concat(wallet.depositBalance.toFixed(2))\n        };\n    }\n    const { addWalletTransaction } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_wallet_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(app-pages-browser)/./lib/wallet.ts\"));\n    let transactionDescription = \"Additional workers for job: \".concat(job.title, \" (+\").concat(workerDifference, \" workers)\");\n    if (additionalScreenshotCost > 0) {\n        transactionDescription += \" + $\".concat(additionalScreenshotCost.toFixed(2), \" screenshot fee\");\n    }\n    transactionDescription += \" + $\".concat(platformFee.toFixed(2), \" platform fee)\");\n    // Deduct from wallet\n    await addWalletTransaction({\n        userId: userId,\n        type: \"payment\",\n        amount: -totalAdditionalCost,\n        description: transactionDescription,\n        referenceId: jobId,\n        referenceType: \"worker_update\",\n        balanceType: \"deposit\"\n    });\n    const newTotalBaseCost = newWorkerCount * costPerWorker;\n    let newTotalScreenshotCost = 0;\n    if (job.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_lib_screenshot-pricing_ts\").then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(app-pages-browser)/./lib/screenshot-pricing.ts\"));\n            newTotalScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, newTotalBaseCost)).totalScreenshotCost;\n        } catch (error) {\n            console.error(\"[v0] Error recalculating total screenshot costs:\", error);\n        }\n    }\n    const newSubtotal = newTotalBaseCost + newTotalScreenshotCost;\n    const newPlatformFee = newSubtotal * platformFeeRate;\n    const newTotalCost = newSubtotal + newPlatformFee;\n    jobs[jobIndex] = {\n        ...job,\n        workersNeeded: newWorkerCount,\n        estimatedTotalCost: newTotalCost\n    };\n    localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n    console.log(\"[v0] 👥 UPDATE-WORKERS: Updated job saved to localStorage with key:\", JOBS_STORAGE_KEY);\n    console.log(\"[v0] ✅ UPDATE-WORKERS: Worker count updated successfully\");\n    console.log(\"[v0] 👥 UPDATE-WORKERS: New total cost:\", newTotalCost.toFixed(2));\n    return {\n        success: true,\n        message: \"Worker count updated to \".concat(newWorkerCount, \". Additional cost: $\").concat(totalAdditionalCost.toFixed(2)),\n        additionalCost: totalAdditionalCost\n    };\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ckMsTUFBTXdILGVBQWVGLGNBQWNDO0lBRW5DOVUsSUFBSSxDQUFDNkYsU0FBUyxHQUFHO1FBQ2YsR0FBR2hELEdBQUc7UUFDTmdHLGVBQWVtTDtRQUNmTixvQkFBb0JxQjtJQUN0QjtJQUVBalYsYUFBYU0sT0FBTyxDQUFDYixrQkFBa0JVLEtBQUtJLFNBQVMsQ0FBQ0w7SUFDdERPLFFBQVErQixHQUFHLENBQUMsdUVBQXVFL0M7SUFFbkZnQixRQUFRK0IsR0FBRyxDQUFDO0lBQ1ovQixRQUFRK0IsR0FBRyxDQUFDLDJDQUEyQ3lTLGFBQWFqSCxPQUFPLENBQUM7SUFFNUUsT0FBTztRQUNMbUcsU0FBUztRQUNUdkksU0FBUywyQkFBZ0VpSixPQUFyQ1gsZ0JBQWUsd0JBQXFELE9BQS9CVyxvQkFBb0I3RyxPQUFPLENBQUM7UUFDckdrSCxnQkFBZ0JMO0lBQ2xCO0FBQ0Y7QUFFd0IiLCJzb3VyY2VzIjpbIi9ob21lL3Byb2plY3QvbGliL2pvYnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSm9iLXJlbGF0ZWQgdHlwZXMgYW5kIG1vY2sgZGF0YVxuZXhwb3J0IGludGVyZmFjZSBKb2Ige1xuICBpZDogc3RyaW5nXG4gIHVzZXJJZDogc3RyaW5nXG4gIGNhdGVnb3J5SWQ6IHN0cmluZ1xuICBzdWJjYXRlZ29yeUlkPzogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICByZXF1aXJlbWVudHM/OiBzdHJpbmdcbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nXG4gIGJ1ZGdldE1pbjogbnVtYmVyXG4gIGJ1ZGdldE1heDogbnVtYmVyXG4gIGRlYWRsaW5lOiBzdHJpbmdcbiAgbG9jYXRpb246IHN0cmluZ1xuICBpc1JlbW90ZTogYm9vbGVhblxuICBzdGF0dXM6IFwicGVuZGluZ1wiIHwgXCJhcHByb3ZlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJzdXNwZW5kZWRcIiB8IFwib3BlblwiIHwgXCJpbl9wcm9ncmVzc1wiIHwgXCJjb21wbGV0ZWRcIiB8IFwiY2FuY2VsbGVkXCJcbiAgcHJpb3JpdHk6IFwibG93XCIgfCBcIm5vcm1hbFwiIHwgXCJoaWdoXCIgfCBcInVyZ2VudFwiXG4gIHNraWxsc1JlcXVpcmVkOiBzdHJpbmdbXVxuICBhcHBsaWNhdGlvbnNDb3VudDogbnVtYmVyXG4gIHZpZXdzQ291bnQ6IG51bWJlclxuICB3b3JrZXJzTmVlZGVkPzogbnVtYmVyXG4gIGR1cmF0aW9uPzogc3RyaW5nXG4gIGR1cmF0aW9uVHlwZT86IHN0cmluZ1xuICB0YWdzPzogc3RyaW5nW11cbiAgYXR0YWNobWVudHM/OiBzdHJpbmdbXVxuICB0aHVtYm5haWw/OiBzdHJpbmdcbiAgcmVxdWlyZVNjcmVlbnNob3RzPzogbnVtYmVyXG4gIHNjcmVlbnNob3RDb3N0PzogbnVtYmVyXG4gIGVzdGltYXRlZEFwcHJvdmFsRGF5cz86IG51bWJlclxuICByZXF1aXJlZFByb29mPzogc3RyaW5nXG4gIHN1Ym1pdHRlZEF0OiBzdHJpbmdcbiAgYXBwcm92ZWRBdD86IHN0cmluZ1xuICBhcHByb3ZlZEJ5Pzogc3RyaW5nXG4gIGFwcHJvdmFsUmVhc29uPzogc3RyaW5nXG4gIHJlamVjdGVkQXQ/OiBzdHJpbmdcbiAgcmVqZWN0ZWRCeT86IHN0cmluZ1xuICByZWplY3Rpb25SZWFzb24/OiBzdHJpbmdcbiAgc3VzcGVuZGVkQXQ/OiBzdHJpbmdcbiAgc3VzcGVuZGVkQnk/OiBzdHJpbmdcbiAgY29tcGxldGVkQXQ/OiBzdHJpbmdcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgdXBkYXRlZEF0OiBzdHJpbmdcbiAgZW5hYmxlQ291bnRyeVJlc3RyaWN0aW9ucz86IGJvb2xlYW5cbiAgcmVzdHJpY3Rpb25UeXBlPzogXCJpbmNsdWRlXCIgfCBcImV4Y2x1ZGVcIlxuICBhbGxvd2VkQ291bnRyaWVzPzogc3RyaW5nW11cbiAgcmVzdHJpY3RlZENvdW50cmllcz86IHN0cmluZ1tdXG4gIGNhdGVnb3J5OiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNsdWc6IHN0cmluZ1xuICB9XG4gIHN1YmNhdGVnb3J5Pzoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBzbHVnOiBzdHJpbmdcbiAgICB0aHVtYm5haWw/OiBzdHJpbmdcbiAgfVxuICBwb3N0ZXI6IHtcbiAgICBpZDogc3RyaW5nXG4gICAgZmlyc3ROYW1lOiBzdHJpbmdcbiAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIGF2YXRhcj86IHN0cmluZ1xuICAgIHJhdGluZzogbnVtYmVyXG4gICAgdG90YWxSZXZpZXdzOiBudW1iZXJcbiAgfVxuICBhc3NpZ25lZFdvcmtlcklkPzogc3RyaW5nIC8vIE5ldyBmaWVsZCBmb3IgYXNzaWduZWQgd29ya2VyIElEXG4gIHBheW1lbnRUeXBlPzogc3RyaW5nXG4gIGNhdGVnb3J5VGh1bWJuYWlsPzogc3RyaW5nXG4gIGFwcHJvdmFsVHlwZT86IHN0cmluZ1xuICBtYW51YWxBcHByb3ZhbERheXM/OiBudW1iZXJcbiAgaXNJbnN0YW50QXBwcm92YWxFbmFibGVkPzogYm9vbGVhblxuICBlc3RpbWF0ZWRUb3RhbENvc3Q/OiBudW1iZXJcbiAgZGVwb3NpdERlZHVjdGVkPzogbnVtYmVyXG4gIGNhbmNlbGxhdGlvbkRldGFpbHM/OiB7XG4gICAgY2FuY2VsbGVkQXQ6IHN0cmluZ1xuICAgIHN1Ym1pdHRlZFdvcmtDb3VudDogbnVtYmVyXG4gICAgcmVtYWluaW5nU2xvdHM6IG51bWJlclxuICAgIHJlZnVuZEFtb3VudDogbnVtYmVyXG4gICAgY2FuUmV2aWV3U3VibWlzc2lvbnM6IGJvb2xlYW5cbiAgfVxuICBqb2JOdW1iZXI/OiBudW1iZXJcbiAgZm9ybWF0dGVkSm9iSWQ/OiBzdHJpbmdcbiAgbWF4V29ya2Vycz86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYkFwcGxpY2F0aW9uIHtcbiAgaWQ6IHN0cmluZ1xuICBqb2JJZDogc3RyaW5nXG4gIGFwcGxpY2FudElkOiBzdHJpbmdcbiAgY292ZXJMZXR0ZXI6IHN0cmluZ1xuICBwcm9wb3NlZEJ1ZGdldDogbnVtYmVyXG4gIGVzdGltYXRlZER1cmF0aW9uOiBzdHJpbmdcbiAgcG9ydGZvbGlvTGlua3M6IHN0cmluZ1tdXG4gIHN0YXR1czogXCJwZW5kaW5nXCIgfCBcImFjY2VwdGVkXCIgfCBcInJlamVjdGVkXCIgfCBcImNvbXBsZXRlZFwiXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIGFwcGxpY2FudDoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gICAgYXZhdGFyPzogc3RyaW5nXG4gICAgcmF0aW5nOiBudW1iZXJcbiAgICB0b3RhbFJldmlld3M6IG51bWJlclxuICAgIHNraWxsczogc3RyaW5nW11cbiAgfVxuICBqb2I/OiBKb2JcbiAgYXBwbGllZEF0Pzogc3RyaW5nXG4gIGFjY2VwdGVkQXQ/OiBzdHJpbmdcbiAgYWNjZXB0ZWRCeT86IHN0cmluZ1xuICByZWplY3RlZEF0Pzogc3RyaW5nXG4gIHJlamVjdGVkQnk/OiBzdHJpbmdcbiAgcmVqZWN0aW9uUmVhc29uPzogc3RyaW5nXG4gIHJlc3VibWlzc2lvbkNvdW50PzogbnVtYmVyXG59XG5cbi8vIE5ldyBpbnRlcmZhY2VzIGZvciBlbmhhbmNlZCB3b3JrIHByb29mIHN5c3RlbVxuZXhwb3J0IGludGVyZmFjZSBXb3JrUHJvb2Yge1xuICBpZDogc3RyaW5nXG4gIGpvYklkOiBzdHJpbmdcbiAgYXBwbGljYXRpb25JZDogc3RyaW5nXG4gIHdvcmtlcklkOiBzdHJpbmdcbiAgZW1wbG95ZXJJZDogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBzdWJtaXNzaW9uVGV4dDogc3RyaW5nXG4gIHByb29mRmlsZXM6IHN0cmluZ1tdIC8vIFVSTHMgdG8gdXBsb2FkZWQgZmlsZXNcbiAgcHJvb2ZMaW5rczogc3RyaW5nW10gLy8gRXh0ZXJuYWwgVVJMcyAoWW91VHViZSwgc29jaWFsIG1lZGlhLCBldGMuKVxuICBzY3JlZW5zaG90czogc3RyaW5nW11cbiAgYXR0YWNobWVudHM6IHN0cmluZ1tdXG4gIGFkZGl0aW9uYWxOb3Rlcz86IHN0cmluZ1xuICBzdWJtaXNzaW9uTnVtYmVyOiBudW1iZXJcbiAgc3RhdHVzOiBcInN1Ym1pdHRlZFwiIHwgXCJ1bmRlcl9yZXZpZXdcIiB8IFwiYWNjZXB0ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwicmV2aXNpb25fcmVxdWVzdGVkXCIgfCBcImFwcHJvdmVkXCJcbiAgc3VibWl0dGVkQXQ6IHN0cmluZ1xuICBhcHByb3ZlZEF0Pzogc3RyaW5nXG4gIGFwcHJvdmVkQnk/OiBzdHJpbmdcbiAgcGF5bWVudEFtb3VudD86IG51bWJlclxuICBwYXltZW50UHJvY2Vzc2VkQXQ/OiBzdHJpbmdcbiAgcGF5bWVudEVycm9yPzogc3RyaW5nXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIHVwZGF0ZWRBdDogc3RyaW5nXG4gIHdvcmtlcj86IHtcbiAgICBpZDogc3RyaW5nXG4gICAgZmlyc3ROYW1lOiBzdHJpbmdcbiAgICBsYXN0TmFtZTogc3RyaW5nXG4gICAgdXNlcm5hbWU6IHN0cmluZ1xuICAgIGF2YXRhcj86IHN0cmluZ1xuICB9XG4gIGVtcGxveWVyPzoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBKb2JSZXZpZXcge1xuICBpZDogc3RyaW5nXG4gIGpvYklkOiBzdHJpbmdcbiAgcHJvb2ZJZDogc3RyaW5nXG4gIHJldmlld2VySWQ6IHN0cmluZ1xuICBkZWNpc2lvbjogXCJhY2NlcHRlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJyZXZpc2lvbl9yZXF1ZXN0ZWRcIlxuICBmZWVkYmFjaz86IHN0cmluZ1xuICByZXZpc2lvbk5vdGVzPzogc3RyaW5nXG4gIHJldmlld2VkQXQ6IHN0cmluZ1xufVxuXG4vLyBKb2Igc3RhdHVzIGhpc3RvcnkgaW50ZXJmYWNlIGZvciB0cmFja2luZyB3b3JrZmxvdyBjaGFuZ2VzXG5leHBvcnQgaW50ZXJmYWNlIEpvYlN0YXR1c0hpc3Rvcnkge1xuICBpZDogc3RyaW5nXG4gIGpvYklkOiBzdHJpbmdcbiAgdXNlcklkPzogc3RyaW5nXG4gIG9sZFN0YXR1cz86IHN0cmluZ1xuICBuZXdTdGF0dXM6IHN0cmluZ1xuICBub3Rlcz86IHN0cmluZ1xuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgY3JlYXRlZEF0OiBzdHJpbmdcbn1cblxuY29uc3QgSk9CU19TVE9SQUdFX0tFWSA9IFwibWFya2V0cGxhY2Utam9ic1wiXG5jb25zdCBBUFBMSUNBVElPTlNfU1RPUkFHRV9LRVkgPSBcIm1hcmtldHBsYWNlLWFwcGxpY2F0aW9uc1wiXG5jb25zdCBXT1JLX1BST09GU19TVE9SQUdFX0tFWSA9IFwibWFya2V0cGxhY2Utd29yay1wcm9vZnNcIlxuY29uc3QgSk9CX1JFVklFV1NfU1RPUkFHRV9LRVkgPSBcIm1hcmtldHBsYWNlLWpvYi1yZXZpZXdzXCJcbmNvbnN0IEpPQl9TVEFUVVNfSElTVE9SWV9TVE9SQUdFX0tFWSA9IFwibWFya2V0cGxhY2Utam9iLXN0YXR1cy1oaXN0b3J5XCJcblxuY29uc3QgZ2V0U3RvcmVkSm9icyA9ICgpOiBKb2JbXSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gW11cbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShKT0JTX1NUT1JBR0VfS0VZKVxuICAgIGlmIChzdG9yZWQpIHtcbiAgICAgIGNvbnN0IGpvYnMgPSBKU09OLnBhcnNlKHN0b3JlZClcbiAgICAgIHJldHVybiBqb2JzXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBzYXZlSm9icyA9IChqb2JzOiBKb2JbXSk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oSk9CU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoam9icykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIGpvYnM6XCIsIGVycm9yKVxuICB9XG59XG5cbmNvbnN0IGdldFN0b3JlZEFwcGxpY2F0aW9ucyA9ICgpOiBKb2JBcHBsaWNhdGlvbltdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEFQUExJQ0FUSU9OU19TVE9SQUdFX0tFWSlcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW11cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuY29uc3Qgc2F2ZUFwcGxpY2F0aW9ucyA9IChhcHBsaWNhdGlvbnM6IEpvYkFwcGxpY2F0aW9uW10pOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEFQUExJQ0FUSU9OU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgYXBwbGljYXRpb25zOlwiLCBlcnJvcilcbiAgfVxufVxuXG5jb25zdCBnZXRTdG9yZWRXb3JrUHJvb2ZzID0gKCk6IFdvcmtQcm9vZltdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFdPUktfUFJPT0ZTX1NUT1JBR0VfS0VZKVxuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBzYXZlV29ya1Byb29mcyA9ICh3b3JrUHJvb2ZzOiBXb3JrUHJvb2ZbXSk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oV09SS19QUk9PRlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHdvcmtQcm9vZnMpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSB3b3JrIHByb29mczpcIiwgZXJyb3IpXG4gIH1cbn1cblxuY29uc3QgZ2V0U3RvcmVkSm9iUmV2aWV3cyA9ICgpOiBKb2JSZXZpZXdbXSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gW11cbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShKT0JfUkVWSUVXU19TVE9SQUdFX0tFWSlcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW11cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuY29uc3Qgc2F2ZUpvYlJldmlld3MgPSAocmV2aWV3czogSm9iUmV2aWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEpPQl9SRVZJRVdTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShyZXZpZXdzKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgam9iIHJldmlld3M6XCIsIGVycm9yKVxuICB9XG59XG5cbi8vIFN0b3JhZ2UgZnVuY3Rpb25zIGZvciBqb2Igc3RhdHVzIGhpc3RvcnlcbmNvbnN0IGdldFN0b3JlZEpvYlN0YXR1c0hpc3RvcnkgPSAoKTogSm9iU3RhdHVzSGlzdG9yeVtdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEpPQl9TVEFUVVNfSElTVE9SWV9TVE9SQUdFX0tFWSlcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW11cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuY29uc3Qgc2F2ZUpvYlN0YXR1c0hpc3RvcnkgPSAoaGlzdG9yeTogSm9iU3RhdHVzSGlzdG9yeVtdKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShKT0JfU1RBVFVTX0hJU1RPUllfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGhpc3RvcnkpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBqb2Igc3RhdHVzIGhpc3Rvcnk6XCIsIGVycm9yKVxuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIHJlY29yZCBzdGF0dXMgY2hhbmdlc1xuY29uc3QgcmVjb3JkU3RhdHVzQ2hhbmdlID0gKFxuICBqb2JJZDogc3RyaW5nLFxuICBvbGRTdGF0dXM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgbmV3U3RhdHVzOiBzdHJpbmcsXG4gIHVzZXJJZD86IHN0cmluZyxcbiAgbm90ZXM/OiBzdHJpbmcsXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IHZvaWQgPT4ge1xuICBjb25zdCBoaXN0b3J5ID0gZ2V0U3RvcmVkSm9iU3RhdHVzSGlzdG9yeSgpXG4gIGNvbnN0IHN0YXR1c0VudHJ5OiBKb2JTdGF0dXNIaXN0b3J5ID0ge1xuICAgIGlkOiBgc3RhdHVzXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcbiAgICBqb2JJZCxcbiAgICB1c2VySWQsXG4gICAgb2xkU3RhdHVzLFxuICAgIG5ld1N0YXR1cyxcbiAgICBub3RlcyxcbiAgICBtZXRhZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIGhpc3RvcnkucHVzaChzdGF0dXNFbnRyeSlcbiAgc2F2ZUpvYlN0YXR1c0hpc3RvcnkoaGlzdG9yeSlcblxuICBjb25zb2xlLmxvZyhgW3YwXSBTdGF0dXMgY2hhbmdlIHJlY29yZGVkIGZvciBqb2IgJHtqb2JJZH06ICR7b2xkU3RhdHVzfSAtPiAke25ld1N0YXR1c31gKVxufVxuXG5pbXBvcnQgeyBnZXRTdWJjYXRlZ29yeUJ5SWQsIGdldENhdGVnb3J5QnlJZCB9IGZyb20gXCIuL2NhdGVnb3JpZXNcIlxuaW1wb3J0IHsgZ2V0UGxhdGZvcm1GZWVTZXR0aW5ncywgY2FsY3VsYXRlUGxhdGZvcm1GZWUgfSBmcm9tIFwiLi9wbGF0Zm9ybS1mZWVcIlxuXG5pbXBvcnQgeyBsb2NhbFJlc2VydmF0aW9uU3RvcmFnZSB9IGZyb20gXCIuL2xvY2FsLXJlc2VydmF0aW9uLXN0b3JhZ2VcIlxuXG5hc3luYyBmdW5jdGlvbiBwb3B1bGF0ZUpvYkNhdGVnb3J5RGF0YShqb2I6IEpvYik6IFByb21pc2U8Sm9iPiB7XG4gIGNvbnNvbGUubG9nKFxuICAgIFwiW3YwXSBQb3B1bGF0aW5nIGNhdGVnb3J5IGRhdGEgZm9yIGpvYjpcIixcbiAgICBqb2IudGl0bGUsXG4gICAgXCJjYXRlZ29yeUlkOlwiLFxuICAgIGpvYi5jYXRlZ29yeUlkLFxuICAgIFwic3ViY2F0ZWdvcnlJZDpcIixcbiAgICBqb2Iuc3ViY2F0ZWdvcnlJZCxcbiAgKVxuICBjb25zdCBwb3B1bGF0ZWRKb2IgPSB7IC4uLmpvYiB9XG5cbiAgaWYgKCFwb3B1bGF0ZWRKb2IuY2F0ZWdvcnk/LnRodW1ibmFpbCAmJiBwb3B1bGF0ZWRKb2IuY2F0ZWdvcnlJZCkge1xuICAgIGNvbnN0IGZ1bGxDYXRlZ29yeSA9IGF3YWl0IGdldENhdGVnb3J5QnlJZChwb3B1bGF0ZWRKb2IuY2F0ZWdvcnlJZClcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gTG9hZGVkIGNhdGVnb3J5OlwiLCBmdWxsQ2F0ZWdvcnk/Lm5hbWUsIFwidGh1bWJuYWlsOlwiLCBmdWxsQ2F0ZWdvcnk/LnRodW1ibmFpbClcbiAgICBpZiAoZnVsbENhdGVnb3J5KSB7XG4gICAgICBwb3B1bGF0ZWRKb2IuY2F0ZWdvcnkgPSB7XG4gICAgICAgIGlkOiBmdWxsQ2F0ZWdvcnkuaWQsXG4gICAgICAgIG5hbWU6IGZ1bGxDYXRlZ29yeS5uYW1lLFxuICAgICAgICBzbHVnOiBmdWxsQ2F0ZWdvcnkuc2x1ZyxcbiAgICAgICAgdGh1bWJuYWlsOiBmdWxsQ2F0ZWdvcnkudGh1bWJuYWlsLFxuICAgICAgfVxuICAgICAgcG9wdWxhdGVkSm9iLmNhdGVnb3J5VGh1bWJuYWlsID0gZnVsbENhdGVnb3J5LnRodW1ibmFpbFxuICAgIH1cbiAgfVxuXG4gIC8vIExvYWQgc3ViY2F0ZWdvcnkgZGF0YSBpZiBzdWJjYXRlZ29yeUlkIGV4aXN0c1xuICBpZiAocG9wdWxhdGVkSm9iLnN1YmNhdGVnb3J5SWQpIHtcbiAgICBjb25zdCBzdWJjYXRlZ29yeSA9IGF3YWl0IGdldFN1YmNhdGVnb3J5QnlJZChwb3B1bGF0ZWRKb2Iuc3ViY2F0ZWdvcnlJZClcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gTG9hZGVkIHN1YmNhdGVnb3J5OlwiLCBzdWJjYXRlZ29yeT8ubmFtZSwgXCJ0aHVtYm5haWw6XCIsIHN1YmNhdGVnb3J5Py50aHVtYm5haWwpXG4gICAgaWYgKHN1YmNhdGVnb3J5KSB7XG4gICAgICBwb3B1bGF0ZWRKb2Iuc3ViY2F0ZWdvcnkgPSBzdWJjYXRlZ29yeVxuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBGaW5hbCBqb2IgZGF0YTpcIiwge1xuICAgIHRpdGxlOiBwb3B1bGF0ZWRKb2IudGl0bGUsXG4gICAgY2F0ZWdvcnlUaHVtYm5haWw6IHBvcHVsYXRlZEpvYi5jYXRlZ29yeVRodW1ibmFpbCxcbiAgICBzdWJjYXRlZ29yeTogcG9wdWxhdGVkSm9iLnN1YmNhdGVnb3J5Py5uYW1lLFxuICAgIHN1YmNhdGVnb3J5VGh1bWJuYWlsOiBwb3B1bGF0ZWRKb2Iuc3ViY2F0ZWdvcnk/LnRodW1ibmFpbCxcbiAgfSlcblxuICByZXR1cm4gcG9wdWxhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRKb2JzKGZpbHRlcnM/OiB7XG4gIGNhdGVnb3J5Pzogc3RyaW5nXG4gIGxvY2F0aW9uPzogc3RyaW5nXG4gIGJ1ZGdldD86IHsgbWluOiBudW1iZXI7IG1heDogbnVtYmVyIH1cbiAgcmVtb3RlPzogYm9vbGVhblxuICBzZWFyY2g/OiBzdHJpbmdcbn0pOiBQcm9taXNlPEpvYltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgbGV0IGZpbHRlcmVkSm9icyA9IGdldFN0b3JlZEpvYnMoKS5maWx0ZXIoKGpvYikgPT4gam9iLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiIHx8IGpvYi5zdGF0dXMgPT09IFwib3BlblwiKVxuXG4gIGlmIChmaWx0ZXJzPy5zZWFyY2gpIHtcbiAgICBmaWx0ZXJlZEpvYnMgPSBmaWx0ZXJlZEpvYnMuZmlsdGVyKFxuICAgICAgKGpvYikgPT5cbiAgICAgICAgam9iLnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVycy5zZWFyY2ghLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgIGpvYi5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcnMuc2VhcmNoIS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICBqb2Iuc2tpbGxzUmVxdWlyZWQuc29tZSgoc2tpbGwpID0+IHNraWxsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVycy5zZWFyY2ghLnRvTG93ZXJDYXNlKCkpKSxcbiAgICApXG4gIH1cblxuICBpZiAoZmlsdGVycz8uY2F0ZWdvcnkpIHtcbiAgICBmaWx0ZXJlZEpvYnMgPSBmaWx0ZXJlZEpvYnMuZmlsdGVyKChqb2IpID0+IGpvYi5jYXRlZ29yeS5zbHVnID09PSBmaWx0ZXJzLmNhdGVnb3J5KVxuICB9XG5cbiAgaWYgKGZpbHRlcnM/LnJlbW90ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsdGVyZWRKb2JzID0gZmlsdGVyZWRKb2JzLmZpbHRlcigoam9iKSA9PiBqb2IuaXNSZW1vdGUgPT09IGZpbHRlcnMucmVtb3RlKVxuICB9XG5cbiAgaWYgKGZpbHRlcnM/LmJ1ZGdldCkge1xuICAgIGZpbHRlcmVkSm9icyA9IGZpbHRlcmVkSm9icy5maWx0ZXIoXG4gICAgICAoam9iKSA9PiBqb2IuYnVkZ2V0TWF4ID49IGZpbHRlcnMuYnVkZ2V0IS5taW4gJiYgam9iLmJ1ZGdldE1pbiA8PSBmaWx0ZXJzLmJ1ZGdldCEubWF4LFxuICAgIClcbiAgfVxuXG4gIGlmIChmaWx0ZXJzPy5sb2NhdGlvbiAmJiBmaWx0ZXJzLmxvY2F0aW9uICE9PSBcImFsbFwiKSB7XG4gICAgZmlsdGVyZWRKb2JzID0gZmlsdGVyZWRKb2JzLmZpbHRlcigoam9iKSA9PiBqb2IubG9jYXRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLmxvY2F0aW9uIS50b0xvd2VyQ2FzZSgpKSlcbiAgfVxuXG4gIGNvbnN0IHNvcnRlZEpvYnMgPSBmaWx0ZXJlZEpvYnMuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkpXG5cbiAgY29uc3QgcG9wdWxhdGVkSm9icyA9IGF3YWl0IFByb21pc2UuYWxsKHNvcnRlZEpvYnMubWFwKHBvcHVsYXRlSm9iQ2F0ZWdvcnlEYXRhKSlcblxuICByZXR1cm4gcG9wdWxhdGVkSm9ic1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxKb2IgfCBudWxsPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iID0gam9icy5maW5kKChqb2IpID0+IGpvYi5pZCA9PT0gaWQpXG5cbiAgaWYgKGpvYikge1xuICAgIC8vIEluY3JlbWVudCB2aWV3IGNvdW50XG4gICAgam9iLnZpZXdzQ291bnQgPSAoam9iLnZpZXdzQ291bnQgfHwgMCkgKyAxXG4gICAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gaWQpXG4gICAgaWYgKGpvYkluZGV4ICE9PSAtMSkge1xuICAgICAgam9ic1tqb2JJbmRleF0gPSBqb2JcbiAgICAgIHNhdmVKb2JzKGpvYnMpXG4gICAgfVxuXG4gICAgY29uc3QgeyBnZXRBbGxVc2VycyB9ID0gYXdhaXQgaW1wb3J0KFwiLi9hdXRoXCIpXG4gICAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gICAgY29uc3QgcG9zdGVyVXNlciA9IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGpvYi51c2VySWQpXG5cbiAgICBpZiAocG9zdGVyVXNlcikge1xuICAgICAgam9iLnBvc3RlciA9IHtcbiAgICAgICAgaWQ6IHBvc3RlclVzZXIuaWQsXG4gICAgICAgIGZpcnN0TmFtZTogcG9zdGVyVXNlci5maXJzdE5hbWUsXG4gICAgICAgIGxhc3ROYW1lOiBwb3N0ZXJVc2VyLmxhc3ROYW1lLFxuICAgICAgICB1c2VybmFtZTogcG9zdGVyVXNlci51c2VybmFtZSxcbiAgICAgICAgYXZhdGFyOiBwb3N0ZXJVc2VyLmF2YXRhcixcbiAgICAgICAgcmF0aW5nOiA0LjUsIC8vIFRPRE86IENhbGN1bGF0ZSBmcm9tIGFjdHVhbCByZXZpZXdzXG4gICAgICAgIHRvdGFsUmV2aWV3czogMCwgLy8gVE9ETzogQ291bnQgZnJvbSBhY3R1YWwgcmV2aWV3c1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBwb3B1bGF0ZUpvYkNhdGVnb3J5RGF0YShqb2IpXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iQXBwbGljYXRpb25zKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYkFwcGxpY2F0aW9uW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgcmV0dXJuIGFwcGxpY2F0aW9ucy5maWx0ZXIoKGFwcCkgPT4gYXBwLmpvYklkID09PSBqb2JJZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdEpvYkFwcGxpY2F0aW9uKGRhdGE6IHtcbiAgam9iSWQ6IHN0cmluZ1xuICBjb3ZlckxldHRlcjogc3RyaW5nXG4gIHByb3Bvc2VkQnVkZ2V0OiBudW1iZXJcbiAgZXN0aW1hdGVkRHVyYXRpb246IHN0cmluZ1xuICBwb3J0Zm9saW9MaW5rczogc3RyaW5nW11cbiAgdXNlcklkPzogc3RyaW5nXG59KTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuXG4gIGlmICghZGF0YS51c2VySWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIElEIGlzIHJlcXVpcmVkIHRvIHN1Ym1pdCBhcHBsaWNhdGlvblwiKVxuICB9XG5cbiAgaWYgKCFkYXRhLmNvdmVyTGV0dGVyLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdmVyIGxldHRlciBpcyByZXF1aXJlZFwiKVxuICB9XG5cbiAgaWYgKGRhdGEucHJvcG9zZWRCdWRnZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3Bvc2VkIGJ1ZGdldCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpXG4gIH1cblxuICAvLyBDaGVjayBpZiB1c2VyIGFscmVhZHkgYXBwbGllZFxuICBjb25zdCBleGlzdGluZ0FwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGNvbnN0IGhhc0FwcGxpZWQgPSBleGlzdGluZ0FwcGxpY2F0aW9ucy5zb21lKChhcHApID0+IGFwcC5qb2JJZCA9PT0gZGF0YS5qb2JJZCAmJiBhcHAuYXBwbGljYW50SWQgPT09IGRhdGEudXNlcklkKVxuXG4gIGlmIChoYXNBcHBsaWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGhhdmUgYWxyZWFkeSBhcHBsaWVkIHRvIHRoaXMgam9iXCIpXG4gIH1cblxuICAvLyBHZXQgdXNlciBkYXRhIGZvciBhcHBsaWNhdGlvblxuICBjb25zdCB7IGdldEFsbFVzZXJzIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2F1dGhcIilcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXIgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmlkID09PSBkYXRhLnVzZXJJZClcblxuICBpZiAoIXVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgbmV3QXBwbGljYXRpb246IEpvYkFwcGxpY2F0aW9uID0ge1xuICAgIGlkOiBgYXBwXyR7RGF0ZS5ub3coKX1gLFxuICAgIGpvYklkOiBkYXRhLmpvYklkLFxuICAgIGFwcGxpY2FudElkOiBkYXRhLnVzZXJJZCxcbiAgICBjb3ZlckxldHRlcjogZGF0YS5jb3ZlckxldHRlcixcbiAgICBwcm9wb3NlZEJ1ZGdldDogZGF0YS5wcm9wb3NlZEJ1ZGdldCxcbiAgICBlc3RpbWF0ZWREdXJhdGlvbjogZGF0YS5lc3RpbWF0ZWREdXJhdGlvbixcbiAgICBwb3J0Zm9saW9MaW5rczogZGF0YS5wb3J0Zm9saW9MaW5rcyxcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGFwcGxpY2FudDoge1xuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBmaXJzdE5hbWU6IHVzZXIuZmlyc3ROYW1lLFxuICAgICAgbGFzdE5hbWU6IHVzZXIubGFzdE5hbWUsXG4gICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgIHJhdGluZzogNC41LCAvLyBEZWZhdWx0IHJhdGluZyBmb3IgbmV3IHVzZXJzXG4gICAgICB0b3RhbFJldmlld3M6IDAsXG4gICAgICBza2lsbHM6IFtcIkdlbmVyYWxcIl0sIC8vIERlZmF1bHQgc2tpbGxzXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGFwcGxpY2F0aW9ucy5wdXNoKG5ld0FwcGxpY2F0aW9uKVxuICBzYXZlQXBwbGljYXRpb25zKGFwcGxpY2F0aW9ucylcblxuICAvLyBVcGRhdGUgam9iIGFwcGxpY2F0aW9uIGNvdW50XG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gZGF0YS5qb2JJZClcbiAgaWYgKGpvYkluZGV4ICE9PSAtMSkge1xuICAgIGpvYnNbam9iSW5kZXhdLmFwcGxpY2F0aW9uc0NvdW50ID0gKGpvYnNbam9iSW5kZXhdLmFwcGxpY2F0aW9uc0NvdW50IHx8IDApICsgMVxuICAgIHNhdmVKb2JzKGpvYnMpXG4gIH1cblxuICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIGZvciBqb2IgcG9zdGVyXG4gIGNvbnN0IHsgY3JlYXRlTm90aWZpY2F0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL25vdGlmaWNhdGlvbnNcIilcbiAgY29uc3Qgam9iID0gam9icy5maW5kKChqKSA9PiBqLmlkID09PSBkYXRhLmpvYklkKVxuICBpZiAoam9iKSB7XG4gICAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICAgIHVzZXJJZDogam9iLnVzZXJJZCxcbiAgICAgIHR5cGU6IFwiam9iXCIsXG4gICAgICB0aXRsZTogXCJOZXcgSm9iIEFwcGxpY2F0aW9uXCIsXG4gICAgICBkZXNjcmlwdGlvbjogYCR7dXNlci5maXJzdE5hbWV9ICR7dXNlci5sYXN0TmFtZX0gYXBwbGllZCBmb3IgeW91ciBqb2IgXCIke2pvYi50aXRsZX1cImAsXG4gICAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL2pvYnMvJHtqb2IuaWR9L2FwcGxpY2F0aW9uc2AsXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBuZXdBcHBsaWNhdGlvblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0Sm9iRm9yQXBwcm92YWwoam9iRGF0YTogUGFydGlhbDxKb2I+LCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuXG4gIGlmICghdXNlcklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBJRCBpcyByZXF1aXJlZCB0byBzdWJtaXQgam9iXCIpXG4gIH1cblxuICBpZiAoIWpvYkRhdGEudGl0bGU/LnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiB0aXRsZSBpcyByZXF1aXJlZFwiKVxuICB9XG5cbiAgaWYgKCFqb2JEYXRhLmRlc2NyaXB0aW9uPy50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJKb2IgZGVzY3JpcHRpb24gaXMgcmVxdWlyZWRcIilcbiAgfVxuXG4gIGlmICgham9iRGF0YS5idWRnZXRNaW4gfHwgam9iRGF0YS5idWRnZXRNaW4gPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkIGJ1ZGdldCBpcyByZXF1aXJlZFwiKVxuICB9XG5cbiAgY29uc3QgeyBnZXRBbGxVc2VycyB9ID0gYXdhaXQgaW1wb3J0KFwiLi9hdXRoXCIpXG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB1c2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gdXNlcklkKVxuXG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCB7IGdldENhdGVnb3J5QnlJZCB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jYXRlZ29yaWVzXCIpXG4gIGNvbnN0IGNhdGVnb3J5ID0gYXdhaXQgZ2V0Q2F0ZWdvcnlCeUlkKGpvYkRhdGEuY2F0ZWdvcnlJZCB8fCBcIlwiKVxuXG4gIGNvbnN0IHsgZ2V0U3ViY2F0ZWdvcnlCeUlkIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NhdGVnb3JpZXNcIilcbiAgY29uc3Qgc3ViY2F0ZWdvcnkgPSBqb2JEYXRhLnN1YmNhdGVnb3J5SWQgPyBhd2FpdCBnZXRTdWJjYXRlZ29yeUJ5SWQoam9iRGF0YS5zdWJjYXRlZ29yeUlkKSA6IG51bGxcblxuICBjb25zdCBjaGVja0F1dG9Kb2JBcHByb3ZhbCA9ICgpOiBib29sZWFuID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBBVVRPLUFQUFJPVkFMIENIRUNLOiBTdGFydGluZyBhdXRvLWFwcHJvdmFsIGNoZWNrLi4uXCIpXG5cbiAgICAvLyBGb3Igc2VydmVyLXNpZGUgZXhlY3V0aW9uLCB3ZSBuZWVkIHRvIHBhc3MgdGhlIHNldHRpbmcgZnJvbSBjbGllbnRcbiAgICAvLyBEZWZhdWx0IHRvIE1BTlVBTCBBUFBST1ZBTCAoZmFsc2UpIGZvciBzZWN1cml0eVxuICAgIGxldCBhdXRvQXBwcm92YWxTZXR0aW5nID0gZmFsc2VcblxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFkbWluX2F1dG9fam9iX2FwcHJvdmFsX2VuYWJsZWRcIilcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgQVVUTy1BUFBST1ZBTCBDSEVDSzogUmF3IGxvY2FsU3RvcmFnZSB2YWx1ZTpcIiwgSlNPTi5zdHJpbmdpZnkoc2V0dGluZykpXG5cbiAgICAgICAgLy8gT25seSBlbmFibGUgaWYgZXhwbGljaXRseSBzZXQgdG8gXCJ0cnVlXCJcbiAgICAgICAgYXV0b0FwcHJvdmFsU2V0dGluZyA9IHNldHRpbmcgPT09IFwidHJ1ZVwiXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIEFVVE8tQVBQUk9WQUwgQ0hFQ0s6IFBhcnNlZCBzZXR0aW5nOlwiLCBhdXRvQXBwcm92YWxTZXR0aW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgQVVUTy1BUFBST1ZBTCBDSEVDSzogU2VydmVyLXNpZGUgZXhlY3V0aW9uIC0gZGVmYXVsdGluZyB0byBNQU5VQUwgQVBQUk9WQUxcIilcbiAgICAgICAgYXV0b0FwcHJvdmFsU2V0dGluZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIPCflKcgQVVUTy1BUFBST1ZBTCBDSEVDSzogRXJyb3IgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgICBhdXRvQXBwcm92YWxTZXR0aW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiW3YwXSDwn5SnIEFVVE8tQVBQUk9WQUwgQ0hFQ0s6IEZpbmFsIGRlY2lzaW9uOlwiLFxuICAgICAgYXV0b0FwcHJvdmFsU2V0dGluZyA/IFwiQVVUTy1BUFBST1ZFXCIgOiBcIk1BTlVBTCBBUFBST1ZBTFwiLFxuICAgIClcbiAgICByZXR1cm4gYXV0b0FwcHJvdmFsU2V0dGluZ1xuICB9XG5cbiAgY29uc3Qgc2hvdWxkQXV0b0FwcHJvdmUgPSBjaGVja0F1dG9Kb2JBcHByb3ZhbCgpXG5cbiAgY29uc3Qgam9iU3RhdHVzID0gc2hvdWxkQXV0b0FwcHJvdmUgPyBcImFwcHJvdmVkXCIgOiBcInBlbmRpbmdcIlxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogU3RhcnRpbmcgam9iIGNyZWF0aW9uIHByb2Nlc3NcIilcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBBdXRvLWFwcHJvdmFsIGVuYWJsZWQ6XCIsIHNob3VsZEF1dG9BcHByb3ZlKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IEpvYiBzdGF0dXMgd2lsbCBiZTpcIiwgam9iU3RhdHVzKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IEpvYiB0aXRsZTpcIiwgam9iRGF0YS50aXRsZSlcblxuICBjb25zdCBuZXdKb2I6IEpvYiA9IHtcbiAgICBpZDogYGpvYl8ke0RhdGUubm93KCl9YCxcbiAgICB1c2VySWQsXG4gICAgY2F0ZWdvcnlJZDogam9iRGF0YS5jYXRlZ29yeUlkIHx8IFwiXCIsXG4gICAgc3ViY2F0ZWdvcnlJZDogam9iRGF0YS5zdWJjYXRlZ29yeUlkLFxuICAgIHRpdGxlOiBqb2JEYXRhLnRpdGxlLFxuICAgIGRlc2NyaXB0aW9uOiBqb2JEYXRhLmRlc2NyaXB0aW9uLFxuICAgIHJlcXVpcmVtZW50czogam9iRGF0YS5yZXF1aXJlbWVudHMsXG4gICAgaW5zdHJ1Y3Rpb25zOiBqb2JEYXRhLmluc3RydWN0aW9ucyxcbiAgICBidWRnZXRNaW46IGpvYkRhdGEuYnVkZ2V0TWluLFxuICAgIGJ1ZGdldE1heDogam9iRGF0YS5idWRnZXRNYXggfHwgam9iRGF0YS5idWRnZXRNaW4sXG4gICAgZGVhZGxpbmU6IGpvYkRhdGEuZGVhZGxpbmUgfHwgbmV3IERhdGUoRGF0ZS5ub3coKSArIDMwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5zcGxpdChcIlRcIilbMF0sXG4gICAgbG9jYXRpb246IGpvYkRhdGEubG9jYXRpb24gfHwgXCJSZW1vdGVcIixcbiAgICBpc1JlbW90ZTogam9iRGF0YS5pc1JlbW90ZSA/PyB0cnVlLFxuICAgIHN0YXR1czogam9iU3RhdHVzLCAvLyBVc2UgdGhlIGV4cGxpY2l0bHkgZGV0ZXJtaW5lZCBzdGF0dXNcbiAgICBwcmlvcml0eTogam9iRGF0YS5wcmlvcml0eSB8fCBcIm5vcm1hbFwiLFxuICAgIHNraWxsc1JlcXVpcmVkOiBqb2JEYXRhLnNraWxsc1JlcXVpcmVkIHx8IFtdLFxuICAgIGFwcGxpY2F0aW9uc0NvdW50OiAwLFxuICAgIHZpZXdzQ291bnQ6IDAsXG4gICAgd29ya2Vyc05lZWRlZDogam9iRGF0YS53b3JrZXJzTmVlZGVkIHx8IDEsXG4gICAgZHVyYXRpb246IGpvYkRhdGEuZHVyYXRpb24sXG4gICAgZHVyYXRpb25UeXBlOiBqb2JEYXRhLmR1cmF0aW9uVHlwZSxcbiAgICB0YWdzOiBqb2JEYXRhLnRhZ3MgfHwgW10sXG4gICAgYXR0YWNobWVudHM6IGpvYkRhdGEuYXR0YWNobWVudHMgfHwgW10sXG4gICAgcmVxdWlyZVNjcmVlbnNob3RzOiBqb2JEYXRhLnJlcXVpcmVTY3JlZW5zaG90cyB8fCAwLFxuICAgIHNjcmVlbnNob3RDb3N0OiAoam9iRGF0YS5yZXF1aXJlU2NyZWVuc2hvdHMgfHwgMCkgKiAwLjA1LFxuICAgIGVzdGltYXRlZEFwcHJvdmFsRGF5czogam9iRGF0YS5lc3RpbWF0ZWRBcHByb3ZhbERheXMgfHwgMSxcbiAgICByZXF1aXJlZFByb29mOiBqb2JEYXRhLnJlcXVpcmVtZW50cyxcbiAgICBzdWJtaXR0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGFwcHJvdmVkQXQ6IHNob3VsZEF1dG9BcHByb3ZlID8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpIDogdW5kZWZpbmVkLFxuICAgIGFwcHJvdmVkQnk6IHNob3VsZEF1dG9BcHByb3ZlID8gXCJTeXN0ZW0gKEF1dG8tYXBwcm92YWwpXCIgOiB1bmRlZmluZWQsXG4gICAgYXBwcm92YWxSZWFzb246IHNob3VsZEF1dG9BcHByb3ZlID8gXCJBdXRvbWF0aWNhbGx5IGFwcHJvdmVkIC0gQXV0by1hcHByb3ZhbCBpcyBlbmFibGVkXCIgOiB1bmRlZmluZWQsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgY2F0ZWdvcnk6IGNhdGVnb3J5IHx8IHtcbiAgICAgIGlkOiBqb2JEYXRhLmNhdGVnb3J5SWQgfHwgXCJcIixcbiAgICAgIG5hbWU6IFwiR2VuZXJhbFwiLFxuICAgICAgc2x1ZzogXCJnZW5lcmFsXCIsXG4gICAgfSxcbiAgICBzdWJjYXRlZ29yeTogc3ViY2F0ZWdvcnlcbiAgICAgID8ge1xuICAgICAgICAgIGlkOiBzdWJjYXRlZ29yeS5pZCxcbiAgICAgICAgICBuYW1lOiBzdWJjYXRlZ29yeS5uYW1lLFxuICAgICAgICAgIHNsdWc6IHN1YmNhdGVnb3J5LnNsdWcsXG4gICAgICAgICAgdGh1bWJuYWlsOiBzdWJjYXRlZ29yeS50aHVtYm5haWwsXG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkLFxuICAgIHBvc3Rlcjoge1xuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBmaXJzdE5hbWU6IHVzZXIuZmlyc3ROYW1lLFxuICAgICAgbGFzdE5hbWU6IHVzZXIubGFzdE5hbWUsXG4gICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgIHJhdGluZzogNC41LFxuICAgICAgdG90YWxSZXZpZXdzOiAwLFxuICAgIH0sXG4gIH1cblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGpvYnMucHVzaChuZXdKb2IpXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgIHVzZXJJZCxcbiAgICB0eXBlOiBcImpvYlwiLFxuICAgIHRpdGxlOiBzaG91bGRBdXRvQXBwcm92ZSA/IFwiSm9iIEFwcHJvdmVkXCIgOiBcIkpvYiBTdWJtaXR0ZWQgZm9yIFJldmlld1wiLFxuICAgIGRlc2NyaXB0aW9uOiBzaG91bGRBdXRvQXBwcm92ZVxuICAgICAgPyBgWW91ciBqb2IgXCIke25ld0pvYi50aXRsZX1cIiBoYXMgYmVlbiBhdXRvbWF0aWNhbGx5IGFwcHJvdmVkIGFuZCBpcyBub3cgbGl2ZWBcbiAgICAgIDogYFlvdXIgam9iIFwiJHtuZXdKb2IudGl0bGV9XCIgaGFzIGJlZW4gc3VibWl0dGVkIGFuZCBpcyBwZW5kaW5nIGFkbWluIHJldmlld2AsXG4gICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9qb2JzYCxcbiAgfSlcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIEpPQiBDUkVBVElPTjogSm9iIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5IHdpdGggSUQ6XCIsIG5ld0pvYi5pZClcbiAgY29uc29sZS5sb2coXCJbdjBdIOKchSBKT0IgQ1JFQVRJT046IEZpbmFsIGpvYiBzdGF0dXM6XCIsIG5ld0pvYi5zdGF0dXMpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgSk9CIENSRUFUSU9OOiBBdXRvLWFwcHJvdmVkOlwiLCBzaG91bGRBdXRvQXBwcm92ZSlcblxuICByZXR1cm4gbmV3Sm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHByb3ZlSm9iKGpvYklkOiBzdHJpbmcsIGFkbWluSWQ6IHN0cmluZywgcmVhc29uPzogc3RyaW5nKTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGpvYklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kXCIpXG5cbiAgY29uc3Qgb2xkU3RhdHVzID0gam9ic1tqb2JJbmRleF0uc3RhdHVzXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsIFwiYXBwcm92ZWRcIiwgYWRtaW5JZCwgcmVhc29uKVxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZWNvcmRTdGF0dXNDaGFuZ2UoXG4gICAgam9iSWQsXG4gICAgb2xkU3RhdHVzLFxuICAgIFwib3BlblwiLCAvLyBKb2JzIGJlY29tZSBcIm9wZW5cIiB3aGVuIGFwcHJvdmVkXG4gICAgYWRtaW5JZCxcbiAgICByZWFzb24gfHwgXCJKb2IgYXBwcm92ZWQgYnkgYWRtaW5cIixcbiAgICB7XG4gICAgICByZXZpZXdJZDogYHJldmlldy0ke0RhdGUubm93KCl9YCxcbiAgICAgIGRlY2lzaW9uOiBcImFjY2VwdGVkXCIsXG4gICAgICBmZWVkYmFjazogcmVhc29uLFxuICAgIH0sXG4gIClcblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVqZWN0Sm9iKGpvYklkOiBzdHJpbmcsIGFkbWluSWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmRcIilcblxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJyZWplY3RlZFwiLCBhZG1pbklkLCByZWFzb24pXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJlY29yZFN0YXR1c0NoYW5nZShqb2JJZCwgb2xkU3RhdHVzLCBcInJlamVjdGVkXCIsIGFkbWluSWQsIHJlYXNvbiwge1xuICAgIHJldmlld0lkOiBgcmV2aWV3LSR7RGF0ZS5ub3coKX1gLFxuICAgIGRlY2lzaW9uOiBcInJlamVjdGVkXCIsXG4gICAgZmVlZGJhY2s6IHJlYXNvbixcbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VzcGVuZEpvYihqb2JJZDogc3RyaW5nLCBhZG1pbklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmRcIilcblxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJzdXNwZW5kZWRcIiwgYWRtaW5JZClcbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKGpvYklkLCBvbGRTdGF0dXMsIFwic3VzcGVuZGVkXCIsIGFkbWluSWQsIFwiSm9iIHN1c3BlbmRlZCBieSBhZG1pblwiLCB7XG4gICAgcmV2aWV3SWQ6IGByZXZpZXctJHtEYXRlLm5vdygpfWAsXG4gICAgZGVjaXNpb246IFwicmV2aXNpb25fcmVxdWVzdGVkXCIsXG4gICAgZmVlZGJhY2s6IFwiSm9iIHN1c3BlbmRlZCBieSBhZG1pblwiLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQZW5kaW5nSm9icygpOiBQcm9taXNlPEpvYltdPiB7XG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgcmV0dXJuIGpvYnMuZmlsdGVyKChqb2IpID0+IGpvYi5zdGF0dXMgPT09IFwicGVuZGluZ1wiKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXBwcm92ZWRKb2JzKCk6IFByb21pc2U8Sm9iW10+IHtcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICByZXR1cm4gam9icy5maWx0ZXIoKGpvYikgPT4gam9iLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiIHx8IGpvYi5zdGF0dXMgPT09IFwib3BlblwiKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsSm9icygpOiBQcm9taXNlPEpvYltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcblxuICBjb25zdCBwb3B1bGF0ZWRKb2JzID0gYXdhaXQgUHJvbWlzZS5hbGwoam9icy5tYXAocG9wdWxhdGVKb2JDYXRlZ29yeURhdGEpKVxuXG4gIHJldHVybiBwb3B1bGF0ZWRKb2JzXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxVc2VySm9icyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICByZXR1cm4gam9icy5maWx0ZXIoKGpvYikgPT4gam9iLnVzZXJJZCA9PT0gdXNlcklkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iKGpvYklkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8Sm9iPik6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSB7XG4gICAgLi4uam9ic1tqb2JJbmRleF0sXG4gICAgLi4udXBkYXRlcyxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAvLyBJZiBqb2IgaXMgZWRpdGVkLCBpdCBuZWVkcyByZS1hcHByb3ZhbFxuICAgIHN0YXR1czogdXBkYXRlcy5zdGF0dXMgfHwgXCJwZW5kaW5nXCIsXG4gIH1cblxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FuY2VsSm9iKGpvYklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7IGpvYjogSm9iOyByZWZ1bmRBbW91bnQ6IG51bWJlciB9PiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZCAmJiBqLnVzZXJJZCA9PT0gdXNlcklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kIG9yIHVuYXV0aG9yaXplZFwiKVxuXG4gIGNvbnN0IGpvYiA9IGpvYnNbam9iSW5kZXhdXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYi5zdGF0dXNcblxuICAvLyBHZXQgd29yayBwcm9vZnMgdG8gc2VlIGhvdyBtYW55IHdvcmtlcnMgaGF2ZSBzdWJtaXR0ZWQgd29ya1xuICBjb25zdCB3b3JrUHJvb2ZzID0gZ2V0U3RvcmVkV29ya1Byb29mcygpLmZpbHRlcigod3ApID0+IHdwLmpvYklkID09PSBqb2JJZClcbiAgY29uc3Qgc3VibWl0dGVkV29ya0NvdW50ID0gd29ya1Byb29mcy5sZW5ndGhcbiAgY29uc3QgcmVtYWluaW5nU2xvdHMgPSBqb2Iud29ya2Vyc05lZWRlZCAtIHN1Ym1pdHRlZFdvcmtDb3VudFxuXG4gIGNvbnN0IGpvYkNvc3RQZXJXb3JrZXIgPSBqb2IuYnVkZ2V0TWF4XG4gIGNvbnN0IHBsYXRmb3JtRmVlUGVyV29ya2VyID0gam9iQ29zdFBlcldvcmtlciAqIDAuMDVcbiAgY29uc3QgdG90YWxDb3N0UGVyV29ya2VyID0gam9iQ29zdFBlcldvcmtlciArIHBsYXRmb3JtRmVlUGVyV29ya2VyXG4gIGNvbnN0IHJlZnVuZEFtb3VudCA9IHJlbWFpbmluZ1Nsb3RzID4gMCA/IHJlbWFpbmluZ1Nsb3RzICogdG90YWxDb3N0UGVyV29ya2VyIDogMFxuXG4gIGlmIChyZWZ1bmRBbW91bnQgPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgYWRkV2FsbGV0VHJhbnNhY3Rpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vd2FsbGV0XCIpXG4gICAgICBhd2FpdCBhZGRXYWxsZXRUcmFuc2FjdGlvbih7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgdHlwZTogXCJyZWZ1bmRcIixcbiAgICAgICAgYW1vdW50OiByZWZ1bmRBbW91bnQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgUmVmdW5kIGZvciBjYW5jZWxsZWQgam9iOiBcIiR7am9iLnRpdGxlfVwiIChKb2IgIyR7am9iLmZvcm1hdHRlZEpvYklkIHx8IGpvYi5pZH0pIC0gJHtyZW1haW5pbmdTbG90c30gcmVtYWluaW5nIHNsb3RzICsgcGxhdGZvcm0gZmVlc2AsXG4gICAgICAgIHJlZmVyZW5jZUlkOiBqb2JJZCxcbiAgICAgICAgcmVmZXJlbmNlVHlwZTogXCJqb2JfY2FuY2VsbGF0aW9uXCIsXG4gICAgICAgIGJhbGFuY2VUeXBlOiBcImRlcG9zaXRcIixcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhgW3YwXSDinIUgSm9iIGNhbmNlbGxhdGlvbiByZWZ1bmQgcHJvY2Vzc2VkOiAkJHtyZWZ1bmRBbW91bnR9YClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbdjBdIOKaoO+4jyBKb2IgY2FuY2VsbGF0aW9uIHJlZnVuZCBhbHJlYWR5IHByb2Nlc3NlZCBmb3Igam9iOiAke2pvYklkfWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbdjBdIOKdjCBGYWlsZWQgdG8gcHJvY2VzcyBqb2IgY2FuY2VsbGF0aW9uIHJlZnVuZDpgLCBlcnJvcilcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgam9iIHN0YXR1cyB0byBjYW5jZWxsZWQgYnV0IGtlZXAgaXQgYWNjZXNzaWJsZSBmb3Igc3VibWl0dGVkIHdvcmsgcmV2aWV3XG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSB7XG4gICAgLi4uam9iLFxuICAgIHN0YXR1czogXCJjYW5jZWxsZWRcIiBhcyBKb2JbXCJzdGF0dXNcIl0sXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgY2FuY2VsbGF0aW9uRGV0YWlsczoge1xuICAgICAgY2FuY2VsbGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHN1Ym1pdHRlZFdvcmtDb3VudCxcbiAgICAgIHJlbWFpbmluZ1Nsb3RzLFxuICAgICAgcmVmdW5kQW1vdW50LFxuICAgICAgY2FuUmV2aWV3U3VibWlzc2lvbnM6IHN1Ym1pdHRlZFdvcmtDb3VudCA+IDAsXG4gICAgfSxcbiAgfVxuXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJlY29yZFN0YXR1c0NoYW5nZShcbiAgICBqb2JJZCxcbiAgICBvbGRTdGF0dXMsXG4gICAgXCJjYW5jZWxsZWRcIixcbiAgICB1c2VySWQsXG4gICAgYEpvYiBjYW5jZWxsZWQuICR7c3VibWl0dGVkV29ya0NvdW50fSB3b3JrIHN1Ym1pc3Npb25zIGNhbiBzdGlsbCBiZSByZXZpZXdlZC4gJHtyZW1haW5pbmdTbG90c30gc2xvdHMgcmVmdW5kZWQgaW5jbHVkaW5nIHBsYXRmb3JtIGZlZS5gLFxuICAgIHtcbiAgICAgIHVzZXJBY3Rpb246IFwiY2FuY2VsXCIsXG4gICAgICBzdWJtaXR0ZWRXb3JrQ291bnQsXG4gICAgICByZW1haW5pbmdTbG90cyxcbiAgICAgIHJlZnVuZEFtb3VudCxcbiAgICAgIGNhblJldmlld1N1Ym1pc3Npb25zOiBzdWJtaXR0ZWRXb3JrQ291bnQgPiAwLFxuICAgIH0sXG4gIClcblxuICBjb25zb2xlLmxvZyhcbiAgICBgW3YwXSBKb2IgJHtqb2JJZH0gY2FuY2VsbGVkLiBSZWZ1bmQ6ICQke3JlZnVuZEFtb3VudH0gKGluY2x1ZGluZyBwbGF0Zm9ybSBmZWUpLCBTdWJtaXR0ZWQgd29yazogJHtzdWJtaXR0ZWRXb3JrQ291bnR9YCxcbiAgKVxuXG4gIHJldHVybiB7IGpvYjogdXBkYXRlZEpvYiwgcmVmdW5kQW1vdW50IH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhdXNlSm9iKGpvYklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGpvYklkICYmIGoudXNlcklkID09PSB1c2VySWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmQgb3IgdW5hdXRob3JpemVkXCIpXG5cbiAgY29uc3Qgb2xkU3RhdHVzID0gam9ic1tqb2JJbmRleF0uc3RhdHVzXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsIFwic3VzcGVuZGVkXCIsIHVzZXJJZClcbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKGpvYklkLCBvbGRTdGF0dXMsIFwic3VzcGVuZGVkXCIsIHVzZXJJZCwgXCJKb2IgcGF1c2VkIGJ5IG93bmVyXCIsIHsgdXNlckFjdGlvbjogXCJwYXVzZVwiIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlYWN0aXZhdGVKb2Ioam9iSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQgJiYgai51c2VySWQgPT09IHVzZXJJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZCBvciB1bmF1dGhvcml6ZWRcIilcblxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgLy8gUmVhY3RpdmF0ZWQgam9icyBuZWVkIHJlLWFwcHJvdmFsXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSBhd2FpdCB1cGRhdGVKb2JTdGF0dXMoam9iSWQsIFwicGVuZGluZ1wiLCB1c2VySWQpXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJlY29yZFN0YXR1c0NoYW5nZShqb2JJZCwgb2xkU3RhdHVzLCBcInBlbmRpbmdcIiwgdXNlcklkLCBcIkpvYiByZWFjdGl2YXRlZCBhbmQgcmVzdWJtaXR0ZWQgZm9yIGFwcHJvdmFsXCIsIHtcbiAgICB1c2VyQWN0aW9uOiBcInJlYWN0aXZhdGVcIixcbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXNlckFwcGxpY2F0aW9ucyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iQXBwbGljYXRpb25bXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG5cbiAgLy8gRmlsdGVyIGFwcGxpY2F0aW9ucyBieSB1c2VyIGFuZCBhZGQgam9iIGRldGFpbHNcbiAgY29uc3QgdXNlckFwcGxpY2F0aW9ucyA9IGFwcGxpY2F0aW9uc1xuICAgIC5maWx0ZXIoKGFwcCkgPT4gYXBwLmFwcGxpY2FudElkID09PSB1c2VySWQpXG4gICAgLm1hcCgoYXBwKSA9PiB7XG4gICAgICBjb25zdCBqb2IgPSBqb2JzLmZpbmQoKGopID0+IGouaWQgPT09IGFwcC5qb2JJZClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcCxcbiAgICAgICAgam9iOiBqb2IgfHwgbnVsbCxcbiAgICAgICAgYXBwbGllZEF0OiBhcHAuY3JlYXRlZEF0LFxuICAgICAgfVxuICAgIH0pXG5cbiAgcmV0dXJuIHVzZXJBcHBsaWNhdGlvbnNcbn1cblxuaW1wb3J0IHsgZ2V0QWxsVXNlcnMgfSBmcm9tIFwiLi9hdXRoXCJcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdFdvcmtQcm9vZihkYXRhOiB7XG4gIGpvYklkOiBzdHJpbmdcbiAgYXBwbGljYXRpb25JZDogc3RyaW5nXG4gIHdvcmtlcklkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHN1Ym1pc3Npb25UZXh0OiBzdHJpbmdcbiAgcHJvb2ZGaWxlcz86IGFueVtdXG4gIHByb29mTGlua3M/OiBzdHJpbmdbXVxuICBzY3JlZW5zaG90cz86IGFueVtdXG4gIGF0dGFjaG1lbnRzPzogYW55W11cbn0pOiBQcm9taXNlPFdvcmtQcm9vZj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IFN0YXJ0aW5nIHdvcmsgcHJvb2Ygc3VibWlzc2lvblwiKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+TnSBXT1JLIFBST09GOiBKb2IgSUQ6XCIsIGRhdGEuam9iSWQpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IFdvcmtlciBJRDpcIiwgZGF0YS53b3JrZXJJZClcblxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3Qgd29ya2VyVXNlciA9IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGRhdGEud29ya2VySWQpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GkIEZvdW5kIHdvcmtlciB1c2VyOlwiLCB3b3JrZXJVc2VyPy5maXJzdE5hbWUsIHdvcmtlclVzZXI/Lmxhc3ROYW1lLCB3b3JrZXJVc2VyPy51c2VybmFtZSlcblxuICAvLyBHZXQgam9iIGRldGFpbHMgdG8gY2hlY2sgYXBwcm92YWwgdHlwZVxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYiA9IGpvYnMuZmluZCgoaikgPT4gai5pZCA9PT0gZGF0YS5qb2JJZClcblxuICBpZiAoIWpvYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IEpvYiBhcHByb3ZhbCB0eXBlOlwiLCBqb2IuYXBwcm92YWxUeXBlKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+TnSBXT1JLIFBST09GOiBJbnN0YW50IGFwcHJvdmFsIGVuYWJsZWQ6XCIsIGpvYi5pc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQpXG5cbiAgLy8gR2V0IGFwcGxpY2F0aW9uIGRldGFpbHNcbiAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgY29uc3QgYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbnMuZmluZCgoYXBwKSA9PiBhcHAuaWQgPT09IGRhdGEuYXBwbGljYXRpb25JZClcblxuICBpZiAoIWFwcGxpY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXBwbGljYXRpb24gbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBwYXltZW50QW1vdW50ID0gYXBwbGljYXRpb24ucHJvcG9zZWRCdWRnZXQgfHwgam9iLmJ1ZGdldE1heCB8fCBqb2IuYnVkZ2V0TWluXG5cbiAgY29uc3Qgc2hvdWxkUHJvY2Vzc0luc3RhbnRQYXltZW50ID0gam9iLmFwcHJvdmFsVHlwZSA9PT0gXCJpbnN0YW50XCIgJiYgam9iLmlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZCA9PT0gdHJ1ZVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IFNob3VsZCBwcm9jZXNzIGluc3RhbnQgcGF5bWVudDpcIiwgc2hvdWxkUHJvY2Vzc0luc3RhbnRQYXltZW50KVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+TnSBXT1JLIFBST09GOiBQYXltZW50IGFtb3VudDpcIiwgcGF5bWVudEFtb3VudClcblxuICBjb25zdCBuZXdQcm9vZjogV29ya1Byb29mID0ge1xuICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgam9iSWQ6IGRhdGEuam9iSWQsXG4gICAgYXBwbGljYXRpb25JZDogZGF0YS5hcHBsaWNhdGlvbklkLFxuICAgIHdvcmtlcklkOiBkYXRhLndvcmtlcklkLFxuICAgIGVtcGxveWVySWQ6IGpvYi51c2VySWQsXG4gICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24sXG4gICAgc3VibWlzc2lvblRleHQ6IGRhdGEuc3VibWlzc2lvblRleHQsXG4gICAgcHJvb2ZGaWxlczogZGF0YS5wcm9vZkZpbGVzIHx8IFtdLFxuICAgIHByb29mTGlua3M6IGRhdGEucHJvb2ZMaW5rcyB8fCBbXSxcbiAgICBzY3JlZW5zaG90czogZGF0YS5zY3JlZW5zaG90cyB8fCBbXSxcbiAgICBhdHRhY2htZW50czogZGF0YS5hdHRhY2htZW50cyB8fCBbXSxcbiAgICBzdGF0dXM6IHNob3VsZFByb2Nlc3NJbnN0YW50UGF5bWVudCA/IFwiYXBwcm92ZWRcIiA6IFwic3VibWl0dGVkXCIsXG4gICAgc3VibWl0dGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBhcHByb3ZlZEF0OiBzaG91bGRQcm9jZXNzSW5zdGFudFBheW1lbnQgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgcGF5bWVudEFtb3VudCxcbiAgICBzdWJtaXNzaW9uTnVtYmVyOiAxLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHdvcmtlcjoge1xuICAgICAgaWQ6IGRhdGEud29ya2VySWQsXG4gICAgICBmaXJzdE5hbWU6IHdvcmtlclVzZXI/LmZpcnN0TmFtZSB8fCBcIlVua25vd25cIixcbiAgICAgIGxhc3ROYW1lOiB3b3JrZXJVc2VyPy5sYXN0TmFtZSB8fCBcIldvcmtlclwiLFxuICAgICAgdXNlcm5hbWU6IHdvcmtlclVzZXI/LnVzZXJuYW1lIHx8IGB1c2VyJHtkYXRhLndvcmtlcklkfWAsXG4gICAgICBhdmF0YXI6IHdvcmtlclVzZXI/LmF2YXRhcixcbiAgICB9LFxuICAgIGVtcGxveWVyOiB7XG4gICAgICBpZDogam9iLnVzZXJJZCxcbiAgICAgIGZpcnN0TmFtZTogdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gam9iLnVzZXJJZCk/LmZpcnN0TmFtZSB8fCBcIkpvYlwiLFxuICAgICAgbGFzdE5hbWU6IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGpvYi51c2VySWQpPy5sYXN0TmFtZSB8fCBcIlBvc3RlclwiLFxuICAgICAgdXNlcm5hbWU6IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGpvYi51c2VySWQpPy51c2VybmFtZSB8fCBcImpvYnBvc3RlclwiLFxuICAgIH0sXG4gIH1cblxuICBpZiAoc2hvdWxkUHJvY2Vzc0luc3RhbnRQYXltZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIElOU1RBTlQgUEFZTUVOVDogUHJvY2Vzc2luZyBpbnN0YW50IHBheW1lbnQgZm9yIHdvcmsgcHJvb2ZcIilcblxuICAgICAgY29uc3QgeyBhZGRXYWxsZXRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi93YWxsZXRcIilcblxuICAgICAgLy8gQ2FsY3VsYXRlIHBsYXRmb3JtIGZlZSAoNSUgZGVmYXVsdClcbiAgICAgIGNvbnN0IHBsYXRmb3JtRmVlU2V0dGluZ3MgPSBhd2FpdCBnZXRQbGF0Zm9ybUZlZVNldHRpbmdzKClcbiAgICAgIGxldCBwbGF0Zm9ybUZlZVJhdGUgPSAwLjA1IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICAgIGxldCBwbGF0Zm9ybUZlZSA9IDBcblxuICAgICAgaWYgKHBsYXRmb3JtRmVlU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgZmVlQ2FsY3VsYXRpb24gPSBjYWxjdWxhdGVQbGF0Zm9ybUZlZShwYXltZW50QW1vdW50LCBwbGF0Zm9ybUZlZVNldHRpbmdzKVxuICAgICAgICBwbGF0Zm9ybUZlZSA9IGZlZUNhbGN1bGF0aW9uLnBsYXRmb3JtRmVlXG4gICAgICAgIHBsYXRmb3JtRmVlUmF0ZSA9IHBsYXRmb3JtRmVlU2V0dGluZ3MuZmVlUGVyY2VudGFnZSAvIDEwMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGxhdGZvcm1GZWUgPSBNYXRoLnJvdW5kKHBheW1lbnRBbW91bnQgKiBwbGF0Zm9ybUZlZVJhdGUgKiAxMDApIC8gMTAwXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdvcmtlckFtb3VudCA9IE1hdGgucm91bmQoKHBheW1lbnRBbW91bnQgLSBwbGF0Zm9ybUZlZSkgKiAxMDApIC8gMTAwXG5cbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIElOU1RBTlQgUEFZTUVOVDogVG90YWwgYW1vdW50OlwiLCBwYXltZW50QW1vdW50KVxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSU5TVEFOVCBQQVlNRU5UOiBQbGF0Zm9ybSBmZWU6XCIsIHBsYXRmb3JtRmVlKVxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSU5TVEFOVCBQQVlNRU5UOiBXb3JrZXIgcmVjZWl2ZXM6XCIsIHdvcmtlckFtb3VudClcblxuICAgICAgLy8gQWRkIG1vbmV5IHRvIHdvcmtlcidzIHdpdGhkcmF3YWwgYmFsYW5jZVxuICAgICAgYXdhaXQgYWRkV2FsbGV0VHJhbnNhY3Rpb24oe1xuICAgICAgICB1c2VySWQ6IGRhdGEud29ya2VySWQsXG4gICAgICAgIHR5cGU6IFwiam9iX3BheW1lbnRcIixcbiAgICAgICAgYW1vdW50OiB3b3JrZXJBbW91bnQsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgSW5zdGFudCBwYXltZW50IGZvciBqb2I6ICR7am9iLnRpdGxlfWAsXG4gICAgICAgIHJlZmVyZW5jZUlkOiBkYXRhLmpvYklkLFxuICAgICAgICByZWZlcmVuY2VUeXBlOiBcImpvYl9wYXltZW50XCIsXG4gICAgICAgIGJhbGFuY2VUeXBlOiBcIndpdGhkcmF3YWxcIixcbiAgICAgIH0pXG5cbiAgICAgIC8vIFJlY29yZCBwbGF0Zm9ybSBmZWVcbiAgICAgIGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdXNlcklkOiBcInBsYXRmb3JtXCIsXG4gICAgICAgIHR5cGU6IFwicGxhdGZvcm1fZmVlXCIsXG4gICAgICAgIGFtb3VudDogcGxhdGZvcm1GZWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgUGxhdGZvcm0gZmVlIGZvciBqb2I6ICR7am9iLnRpdGxlfWAsXG4gICAgICAgIHJlZmVyZW5jZUlkOiBkYXRhLmpvYklkLFxuICAgICAgICByZWZlcmVuY2VUeXBlOiBcInBsYXRmb3JtX2ZlZVwiLFxuICAgICAgICBiYWxhbmNlVHlwZTogXCJ3aXRoZHJhd2FsXCIsXG4gICAgICB9KVxuXG4gICAgICBuZXdQcm9vZi5hcHByb3ZlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICBuZXdQcm9vZi5hcHByb3ZlZEJ5ID0gXCJTeXN0ZW0gKEluc3RhbnQgQXBwcm92YWwpXCJcbiAgICAgIG5ld1Byb29mLnBheW1lbnRQcm9jZXNzZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIElOU1RBTlQgUEFZTUVOVDogUGF5bWVudCBwcm9jZXNzZWQgc3VjY2Vzc2Z1bGx5XCIpXG5cbiAgICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIHdvcmtlclxuICAgICAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICAgICAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICAgICAgdXNlcklkOiBkYXRhLndvcmtlcklkLFxuICAgICAgICB0eXBlOiBcInBheW1lbnRcIixcbiAgICAgICAgdGl0bGU6IFwiSW5zdGFudCBQYXltZW50IFJlY2VpdmVkISDwn5KwXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgWW91IHJlY2VpdmVkICQke3dvcmtlckFtb3VudC50b0ZpeGVkKDIpfSBmb3IgY29tcGxldGluZyBcIiR7am9iLnRpdGxlfVwiLiBQYXltZW50IGhhcyBiZWVuIGFkZGVkIHRvIHlvdXIgd2l0aGRyYXdhbCBiYWxhbmNlLmAsXG4gICAgICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvd2FsbGV0YCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIGVtcGxveWVyXG4gICAgICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgICAgICB1c2VySWQ6IGpvYi51c2VySWQsXG4gICAgICAgIHR5cGU6IFwiam9iXCIsXG4gICAgICAgIHRpdGxlOiBcIldvcmsgU3VibWl0dGVkICYgUGF5bWVudCBSZWxlYXNlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogYFdvcmsgaGFzIGJlZW4gc3VibWl0dGVkIGZvciBcIiR7am9iLnRpdGxlfVwiIGFuZCBpbnN0YW50IHBheW1lbnQgb2YgJCR7cGF5bWVudEFtb3VudC50b0ZpeGVkKDIpfSBoYXMgYmVlbiByZWxlYXNlZCB0byB0aGUgd29ya2VyLmAsXG4gICAgICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvam9icy8ke2RhdGEuam9iSWR9YCxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgSU5TVEFOVCBQQVlNRU5UOiBOb3RpZmljYXRpb25zIHNlbnQgc3VjY2Vzc2Z1bGx5XCIpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIOKdjCBJTlNUQU5UIFBBWU1FTlQ6IEVycm9yIHByb2Nlc3NpbmcgaW5zdGFudCBwYXltZW50OlwiLCBlcnJvcilcbiAgICAgIC8vIERvbid0IGZhaWwgdGhlIHdvcmsgcHJvb2Ygc3VibWlzc2lvbiwganVzdCBsb2cgdGhlIGVycm9yXG4gICAgICBuZXdQcm9vZi5zdGF0dXMgPSBcInN1Ym1pdHRlZFwiXG4gICAgICBuZXdQcm9vZi5wYXltZW50RXJyb3IgPSBlcnJvci5tZXNzYWdlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IE1hbnVhbCBhcHByb3ZhbCByZXF1aXJlZCwgY3JlYXRpbmcgbm90aWZpY2F0aW9uIGZvciBlbXBsb3llclwiKVxuICAgIGNvbnN0IHsgY3JlYXRlTm90aWZpY2F0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL25vdGlmaWNhdGlvbnNcIilcbiAgICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgICAgdXNlcklkOiBqb2IudXNlcklkLFxuICAgICAgdHlwZTogXCJqb2JcIixcbiAgICAgIHRpdGxlOiBcIldvcmsgU3VibWl0dGVkIGZvciBSZXZpZXdcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgV29yayBoYXMgYmVlbiBzdWJtaXR0ZWQgZm9yIFwiJHtqb2IudGl0bGV9XCIuIFBsZWFzZSByZXZpZXcgYW5kIGFwcHJvdmUgd2l0aGluICR7am9iLm1hbnVhbEFwcHJvdmFsRGF5cyB8fCAzfSBkYXlzLmAsXG4gICAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL2pvYnMvJHtkYXRhLmpvYklkfWAsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHdvcmtQcm9vZnMgPSBnZXRTdG9yZWRXb3JrUHJvb2ZzKClcbiAgd29ya1Byb29mcy5wdXNoKG5ld1Byb29mKVxuICBzYXZlV29ya1Byb29mcyh3b3JrUHJvb2ZzKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgV09SSyBQUk9PRjogV29yayBwcm9vZiBzYXZlZCBzdWNjZXNzZnVsbHkgd2l0aCBzdGF0dXM6XCIsIG5ld1Byb29mLnN0YXR1cylcblxuICByZXR1cm4gbmV3UHJvb2Zcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdvcmtQcm9vZnNCeUpvYihqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxXb3JrUHJvb2ZbXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCB3b3JrUHJvb2ZzID0gZ2V0U3RvcmVkV29ya1Byb29mcygpXG4gIHJldHVybiB3b3JrUHJvb2ZzLmZpbHRlcigocHJvb2YpID0+IHByb29mLmpvYklkID09PSBqb2JJZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdvcmtQcm9vZnNCeVdvcmtlcih3b3JrZXJJZDogc3RyaW5nKTogUHJvbWlzZTxXb3JrUHJvb2ZbXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCB3b3JrUHJvb2ZzID0gZ2V0U3RvcmVkV29ya1Byb29mcygpXG4gIHJldHVybiB3b3JrUHJvb2ZzLmZpbHRlcigocHJvb2YpID0+IHByb29mLndvcmtlcklkID09PSB3b3JrZXJJZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFdvcmtQcm9vZnMoam9iSWQ6IHN0cmluZyk6IFByb21pc2U8V29ya1Byb29mW10+IHtcbiAgcmV0dXJuIGF3YWl0IGdldFdvcmtQcm9vZnNCeUpvYihqb2JJZClcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldmlld1dvcmtQcm9vZihcbiAgcHJvb2ZJZDogc3RyaW5nLFxuICByZXZpZXdEYXRhOiB7XG4gICAgZGVjaXNpb246IFwiYWNjZXB0ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwicmV2aXNpb25fcmVxdWVzdGVkXCJcbiAgICBmZWVkYmFjaz86IHN0cmluZ1xuICAgIHJldmlzaW9uTm90ZXM/OiBzdHJpbmdcbiAgICByZXZpZXdlcklkOiBzdHJpbmdcbiAgfSxcbik6IFByb21pc2U8Sm9iUmV2aWV3PiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgY29uc3Qgd29ya1Byb29mcyA9IGdldFN0b3JlZFdvcmtQcm9vZnMoKVxuICBjb25zdCBwcm9vZkluZGV4ID0gd29ya1Byb29mcy5maW5kSW5kZXgoKHByb29mKSA9PiBwcm9vZi5pZCA9PT0gcHJvb2ZJZClcblxuICBpZiAocHJvb2ZJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrIHByb29mIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgcHJvb2YgPSB3b3JrUHJvb2ZzW3Byb29mSW5kZXhdXG5cbiAgLy8gVXBkYXRlIHByb29mIHN0YXR1c1xuICB3b3JrUHJvb2ZzW3Byb29mSW5kZXhdID0ge1xuICAgIC4uLnByb29mLFxuICAgIHN0YXR1czpcbiAgICAgIHJldmlld0RhdGEuZGVjaXNpb24gPT09IFwiYWNjZXB0ZWRcIlxuICAgICAgICA/IFwiYWNjZXB0ZWRcIlxuICAgICAgICA6IHJldmlld0RhdGEuZGVjaXNpb24gPT09IFwicmVqZWN0ZWRcIlxuICAgICAgICAgID8gXCJyZWplY3RlZFwiXG4gICAgICAgICAgOiBcInJldmlzaW9uX3JlcXVlc3RlZFwiLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG4gIHNhdmVXb3JrUHJvb2ZzKHdvcmtQcm9vZnMpXG5cbiAgLy8gQ3JlYXRlIHJldmlldyByZWNvcmRcbiAgY29uc3QgcmV2aWV3OiBKb2JSZXZpZXcgPSB7XG4gICAgaWQ6IGByZXZpZXctJHtEYXRlLm5vdygpfWAsXG4gICAgam9iSWQ6IHByb29mLmpvYklkLFxuICAgIHByb29mSWQ6IHByb29mSWQsXG4gICAgcmV2aWV3ZXJJZDogcmV2aWV3RGF0YS5yZXZpZXdlcklkLFxuICAgIGRlY2lzaW9uOiByZXZpZXdEYXRhLmRlY2lzaW9uLFxuICAgIGZlZWRiYWNrOiByZXZpZXdEYXRhLmZlZWRiYWNrLFxuICAgIHJldmlzaW9uTm90ZXM6IHJldmlld0RhdGEucmV2aXNpb25Ob3RlcyxcbiAgICByZXZpZXdlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cblxuICAvLyBTdG9yZSByZXZpZXcgKGluIHJlYWwgYXBwLCB0aGlzIHdvdWxkIGdvIHRvIGRhdGFiYXNlKVxuICBjb25zdCByZXZpZXdzID0gZ2V0U3RvcmVkSm9iUmV2aWV3cygpXG4gIHJldmlld3MucHVzaChyZXZpZXcpXG4gIHNhdmVKb2JSZXZpZXdzKHJldmlld3MpXG5cbiAgLy8gVXBkYXRlIGpvYiBhbmQgYXBwbGljYXRpb24gc3RhdHVzIGJhc2VkIG9uIGRlY2lzaW9uXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoam9iKSA9PiBqb2IuaWQgPT09IHByb29mLmpvYklkKVxuXG4gIGlmIChqb2JJbmRleCAhPT0gLTEpIHtcbiAgICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgICBsZXQgbmV3U3RhdHVzID0gb2xkU3RhdHVzXG5cbiAgICBpZiAocmV2aWV3RGF0YS5kZWNpc2lvbiA9PT0gXCJhY2NlcHRlZFwiKSB7XG4gICAgICAvLyBVcGRhdGUgam9iIHRvIGNvbXBsZXRlZFxuICAgICAgbmV3U3RhdHVzID0gXCJjb21wbGV0ZWRcIlxuICAgICAgam9ic1tqb2JJbmRleF0gPSB7XG4gICAgICAgIC4uLmpvYnNbam9iSW5kZXhdLFxuICAgICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfVxuXG4gICAgICByZWNvcmRTdGF0dXNDaGFuZ2UoXG4gICAgICAgIHByb29mLmpvYklkLFxuICAgICAgICBvbGRTdGF0dXMsXG4gICAgICAgIFwiY29tcGxldGVkXCIsXG4gICAgICAgIHJldmlld0RhdGEucmV2aWV3ZXJJZCxcbiAgICAgICAgXCJXb3JrIHByb29mIGFjY2VwdGVkIC0gam9iIGNvbXBsZXRlZFwiLFxuICAgICAgICB7XG4gICAgICAgICAgcmV2aWV3SWQ6IHJldmlldy5pZCxcbiAgICAgICAgICBkZWNpc2lvbjogXCJhY2NlcHRlZFwiLFxuICAgICAgICAgIGZlZWRiYWNrOiByZXZpZXdEYXRhLmZlZWRiYWNrLFxuICAgICAgICB9LFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAocmV2aWV3RGF0YS5kZWNpc2lvbiA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICByZWNvcmRTdGF0dXNDaGFuZ2UoXG4gICAgICAgIHByb29mLmpvYklkLFxuICAgICAgICBvbGRTdGF0dXMsXG4gICAgICAgIG9sZFN0YXR1cywgLy8gU3RhdHVzIG1pZ2h0IG5vdCBjaGFuZ2UsIGJ1dCB3ZSByZWNvcmQgdGhlIHJldmlld1xuICAgICAgICByZXZpZXdEYXRhLnJldmlld2VySWQsXG4gICAgICAgIFwiV29yayBwcm9vZiByZWplY3RlZCAtIGF3YWl0aW5nIHJld29yayBvciBkaXNwdXRlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZXZpZXdJZDogcmV2aWV3LmlkLFxuICAgICAgICAgIGRlY2lzaW9uOiBcInJlamVjdGVkXCIsXG4gICAgICAgICAgZmVlZGJhY2s6IHJldmlld0RhdGEuZmVlZGJhY2ssXG4gICAgICAgICAgcmV2aXNpb25Ob3RlczogcmV2aWV3RGF0YS5yZXZpc2lvbk5vdGVzLFxuICAgICAgICB9LFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNvcmRTdGF0dXNDaGFuZ2UoXG4gICAgICAgIHByb29mLmpvYklkLFxuICAgICAgICBvbGRTdGF0dXMsXG4gICAgICAgIG9sZFN0YXR1cywgLy8gU3RhdHVzIHN0YXlzIHRoZSBzYW1lIGZvciByZXZpc2lvbiByZXF1ZXN0c1xuICAgICAgICByZXZpZXdEYXRhLnJldmlld2VySWQsXG4gICAgICAgIFwiUmV2aXNpb24gcmVxdWVzdGVkIG9uIHdvcmsgcHJvb2ZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJldmlld0lkOiByZXZpZXcuaWQsXG4gICAgICAgICAgZGVjaXNpb246IFwicmV2aXNpb25fcmVxdWVzdGVkXCIsXG4gICAgICAgICAgcmV2aXNpb25Ob3RlczogcmV2aWV3RGF0YS5yZXZpc2lvbk5vdGVzLFxuICAgICAgICB9LFxuICAgICAgKVxuICAgIH1cblxuICAgIHNhdmVKb2JzKGpvYnMpXG5cbiAgICAvLyBVcGRhdGUgYXBwbGljYXRpb24gdG8gY29tcGxldGVkIGlmIGFjY2VwdGVkXG4gICAgaWYgKHJldmlld0RhdGEuZGVjaXNpb24gPT09IFwiYWNjZXB0ZWRcIikge1xuICAgICAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgICAgIGNvbnN0IGFwcEluZGV4ID0gYXBwbGljYXRpb25zLmZpbmRJbmRleCgoYXBwKSA9PiBhcHAuam9iSWQgPT09IHByb29mLmpvYklkICYmIGFwcC5hcHBsaWNhbnRJZCA9PT0gcHJvb2Yud29ya2VySWQpXG4gICAgICBpZiAoYXBwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGFwcGxpY2F0aW9uc1thcHBJbmRleF0gPSB7XG4gICAgICAgICAgLi4uYXBwbGljYXRpb25zW2FwcEluZGV4XSxcbiAgICAgICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIsXG4gICAgICAgIH1cbiAgICAgICAgc2F2ZUFwcGxpY2F0aW9ucyhhcHBsaWNhdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldmlld1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iQXBwbGljYXRpb25CeUlkKGFwcGxpY2F0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iQXBwbGljYXRpb24gfCBudWxsPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIHJldHVybiBhcHBsaWNhdGlvbnMuZmluZCgoYXBwKSA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpIHx8IG51bGxcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUpvYlN0YXR1cyhcbiAgam9iSWQ6IHN0cmluZyxcbiAgbmV3U3RhdHVzOiBKb2JbXCJzdGF0dXNcIl0sXG4gIHVzZXJJZD86IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuKTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGpvYikgPT4gam9iLmlkID09PSBqb2JJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuXG4gIGNvbnN0IGpvYiA9IGpvYnNbam9iSW5kZXhdXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYi5zdGF0dXNcblxuICBjb25zdCB1cGRhdGVkSm9iID0ge1xuICAgIC4uLmpvYixcbiAgICBzdGF0dXM6IG5ld1N0YXR1cyxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAuLi4obmV3U3RhdHVzID09PSBcImNvbXBsZXRlZFwiICYmIHsgY29tcGxldGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KSxcbiAgfVxuXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIC8vIEFkZCB0byBzdGF0dXMgaGlzdG9yeVxuICBjb25zdCBzdGF0dXNIaXN0b3J5ID0gZ2V0U3RvcmVkSm9iU3RhdHVzSGlzdG9yeSgpXG4gIHN0YXR1c0hpc3RvcnkucHVzaCh7XG4gICAgaWQ6IGBzdGF0dXNfJHtEYXRlLm5vdygpfWAsXG4gICAgam9iSWQsXG4gICAgdXNlcklkLFxuICAgIG9sZFN0YXR1cyxcbiAgICBuZXdTdGF0dXMsXG4gICAgbm90ZXM6IG1ldGFkYXRhPy5ub3RlcyB8fCBgU3RhdHVzIGNoYW5nZWQgZnJvbSAke29sZFN0YXR1c30gdG8gJHtuZXdTdGF0dXN9YCxcbiAgICBtZXRhZGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfSlcbiAgc2F2ZUpvYlN0YXR1c0hpc3Rvcnkoc3RhdHVzSGlzdG9yeSlcblxuICBjb25zb2xlLmxvZyhcIlt2MF0gSm9iIHN0YXR1cyB1cGRhdGVkOlwiLCBqb2JJZCwgXCJmcm9tXCIsIG9sZFN0YXR1cywgXCJ0b1wiLCBuZXdTdGF0dXMpXG5cbiAgaWYgKG5ld1N0YXR1cyA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG5cbiAgICAgIC8vIE5vdGlmeSBqb2IgcG9zdGVyXG4gICAgICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgICAgICB1c2VySWQ6IGpvYi51c2VySWQsXG4gICAgICAgIHR5cGU6IFwiam9iXCIsXG4gICAgICAgIHRpdGxlOiBcIkpvYiBDb21wbGV0ZWQgU3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgWW91ciBqb2IgXCIke2pvYi50aXRsZX1cIiBoYXMgYmVlbiBjb21wbGV0ZWQgYnkgYWxsIHJlcXVpcmVkIHdvcmtlcnMuYCxcbiAgICAgICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9qb2JzLyR7am9iSWR9YCxcbiAgICAgIH0pXG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB3b3JrZXJzLCBub3RpZnkgdGhlbSBhbGxcbiAgICAgIGlmIChtZXRhZGF0YT8udG90YWxXb3JrZXJzQ29tcGxldGVkICYmIG1ldGFkYXRhLnRvdGFsV29ya2Vyc0NvbXBsZXRlZCA+IDEpIHtcbiAgICAgICAgY29uc3QgeyBnZXRKb2JBcHBsaWNhdGlvbnMgfSA9IGF3YWl0IGltcG9ydChcIi4vam9ic1wiKVxuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBhd2FpdCBnZXRKb2JBcHBsaWNhdGlvbnMoam9iSWQpXG4gICAgICAgIGNvbnN0IGFjY2VwdGVkV29ya2VycyA9IGFwcGxpY2F0aW9ucy5maWx0ZXIoKGFwcCkgPT4gYXBwLnN0YXR1cyA9PT0gXCJhY2NlcHRlZFwiKVxuXG4gICAgICAgIGZvciAoY29uc3QgYXBwIG9mIGFjY2VwdGVkV29ya2Vycykge1xuICAgICAgICAgIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICB1c2VySWQ6IGFwcC5hcHBsaWNhbnRJZCxcbiAgICAgICAgICAgIHR5cGU6IFwiam9iXCIsXG4gICAgICAgICAgICB0aXRsZTogXCJKb2IgRnVsbHkgQ29tcGxldGVkXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFRoZSBqb2IgXCIke2pvYi50aXRsZX1cIiBoYXMgYmVlbiBjb21wbGV0ZWQgYnkgYWxsIHJlcXVpcmVkIHdvcmtlcnMuYCxcbiAgICAgICAgICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvYXBwbGllZC1qb2JzYCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEZhaWxlZCB0byBzZW5kIGNvbXBsZXRpb24gbm90aWZpY2F0aW9uczpcIiwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGNvbnN0IEpPQl9TVEFUVVMgPSB7XG4gIFBFTkRJTkc6IFwicGVuZGluZ1wiIGFzIGNvbnN0LFxuICBBUFBST1ZFRDogXCJhcHByb3ZlZFwiIGFzIGNvbnN0LFxuICBSRUpFQ1RFRDogXCJyZWplY3RlZFwiIGFzIGNvbnN0LFxuICBTVVNQRU5ERUQ6IFwic3VzcGVuZGVkXCIgYXMgY29uc3QsXG4gIE9QRU46IFwib3BlblwiIGFzIGNvbnN0LFxuICBJTl9QUk9HUkVTUzogXCJpbl9wcm9ncmVzc1wiIGFzIGNvbnN0LFxuICBDT01QTEVURUQ6IFwiY29tcGxldGVkXCIgYXMgY29uc3QsXG4gIENBTkNFTExFRDogXCJjYW5jZWxsZWRcIiBhcyBjb25zdCxcbn1cblxuZXhwb3J0IGNvbnN0IGdldEpvYlN0YXR1c0NvbG9yID0gKHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBKT0JfU1RBVFVTLlBFTkRJTkc6XG4gICAgICByZXR1cm4gXCJiZy15ZWxsb3ctMTAwIHRleHQteWVsbG93LTgwMFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLkFQUFJPVkVEOlxuICAgIGNhc2UgSk9CX1NUQVRVUy5PUEVOOlxuICAgICAgcmV0dXJuIFwiYmctZ3JlZW4tMTAwIHRleHQtZ3JlZW4tODAwXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuUkVKRUNURUQ6XG4gICAgICByZXR1cm4gXCJiZy1yZWQtMTAwIHRleHQtcmVkLTgwMFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLlNVU1BFTkRFRDpcbiAgICAgIHJldHVybiBcImJnLWdyYXktMTAwIHRleHQtZ3JheS04MDBcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5JTl9QUk9HUkVTUzpcbiAgICAgIHJldHVybiBcImJnLWJsdWUtMTAwIHRleHQtYmx1ZS04MDBcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5DT01QTEVURUQ6XG4gICAgICByZXR1cm4gXCJiZy1wdXJwbGUtMTAwIHRleHQtcHVycGxlLTgwMFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLkNBTkNFTExFRDpcbiAgICAgIHJldHVybiBcImJnLW9yYW5nZS0xMDAgdGV4dC1vcmFuZ2UtODAwXCJcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMFwiXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldEpvYlN0YXR1c0xhYmVsID0gKHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBKT0JfU1RBVFVTLlBFTkRJTkc6XG4gICAgICByZXR1cm4gXCJQZW5kaW5nIFJldmlld1wiXG4gICAgY2FzZSBKT0JfU1RBVFVTLkFQUFJPVkVEOlxuICAgICAgcmV0dXJuIFwiQXBwcm92ZWRcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5SRUpFQ1RFRDpcbiAgICAgIHJldHVybiBcIlJlamVjdGVkXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuU1VTUEVOREVEOlxuICAgICAgcmV0dXJuIFwiU3VzcGVuZGVkXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuT1BFTjpcbiAgICAgIHJldHVybiBcIk9wZW5cIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5JTl9QUk9HUkVTUzpcbiAgICAgIHJldHVybiBcIkluIFByb2dyZXNzXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuQ09NUExFVEVEOlxuICAgICAgcmV0dXJuIFwiQ29tcGxldGVkXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuQ0FOQ0VMTEVEOlxuICAgICAgcmV0dXJuIFwiQ2FuY2VsbGVkXCJcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXR1c1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjYW5BcHBseVRvSm9iID0gKGpvYjogSm9iKSA9PiB7XG4gIHJldHVybiBqb2Iuc3RhdHVzID09PSBKT0JfU1RBVFVTLkFQUFJPVkVEIHx8IGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuT1BFTlxufVxuXG5leHBvcnQgY29uc3QgaXNKb2JWaXNpYmxlID0gKGpvYjogSm9iLCB1c2VyVHlwZTogXCJ1c2VyXCIgfCBcImFkbWluXCIgPSBcInVzZXJcIikgPT4ge1xuICBpZiAodXNlclR5cGUgPT09IFwiYWRtaW5cIikge1xuICAgIHJldHVybiB0cnVlIC8vIEFkbWlucyBjYW4gc2VlIGFsbCBqb2JzXG4gIH1cblxuICAvLyBSZWd1bGFyIHVzZXJzIGNhbiBvbmx5IHNlZSBhcHByb3ZlZC9vcGVuIGpvYnNcbiAgcmV0dXJuIGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuQVBQUk9WRUQgfHwgam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5PUEVOXG59XG5cbmV4cG9ydCBjb25zdCBnZXRBdmFpbGFibGVKb2JzID0gYXN5bmMgKGN1cnJlbnRVc2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPEpvYltdPiA9PiB7XG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcblxuICByZXR1cm4gam9icy5maWx0ZXIoKGpvYikgPT4ge1xuICAgIC8vIEJhc2ljIHN0YXR1cyBmaWx0ZXIgLSBvbmx5IHNob3cgYXBwcm92ZWQvb3BlbiBqb2JzIHRoYXQgYXJlbid0IGNvbXBsZXRlZFxuICAgIGNvbnN0IGlzVmFsaWRTdGF0dXMgPVxuICAgICAgKGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuQVBQUk9WRUQgfHwgam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5PUEVOKSAmJiBqb2Iuc3RhdHVzICE9PSBKT0JfU1RBVFVTLkNPTVBMRVRFRFxuXG4gICAgaWYgKCFpc1ZhbGlkU3RhdHVzKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHdvcmtlcnNOZWVkZWQgPSBqb2Iud29ya2Vyc05lZWRlZCB8fCBqb2IubWF4V29ya2VycyB8fCAxXG4gICAgY29uc3QgY3VycmVudEFwcGxpY2F0aW9ucyA9IGpvYi5hcHBsaWNhdGlvbnNDb3VudCB8fCAwXG5cbiAgICAvLyBJZiBqb2IgaGFzIHJlYWNoZWQgaXRzIHdvcmtlciBsaW1pdCwgZG9uJ3Qgc2hvdyBpdCBhcyBhdmFpbGFibGVcbiAgICBpZiAoY3VycmVudEFwcGxpY2F0aW9ucyA+PSB3b3JrZXJzTmVlZGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0gSm9iXCIsIGpvYi5pZCwgXCJhdCBjYXBhY2l0eTpcIiwgY3VycmVudEFwcGxpY2F0aW9ucywgXCJvZlwiLCB3b3JrZXJzTmVlZGVkLCBcIndvcmtlcnNcIilcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IHJlc2VydmF0aW9uSW5mbyA9IGxvY2FsUmVzZXJ2YXRpb25TdG9yYWdlLmlzSm9iUmVzZXJ2ZWQoam9iLmlkKVxuXG4gICAgLy8gSWYgam9iIGlzIG5vdCByZXNlcnZlZCwgc2hvdyBpdCB0byBldmVyeW9uZVxuICAgIGlmICghcmVzZXJ2YXRpb25JbmZvLmlzUmVzZXJ2ZWQpIHJldHVybiB0cnVlXG5cbiAgICAvLyBJZiBqb2IgbmVlZHMgbXVsdGlwbGUgd29ya2Vycywgc2hvdyBpdCBldmVuIHdoZW4gcmVzZXJ2ZWQgKHBhcnRpYWwgcmVzZXJ2YXRpb24pXG4gICAgaWYgKGpvYi53b3JrZXJzTmVlZGVkID4gMSkgcmV0dXJuIHRydWVcblxuICAgIC8vIEZvciBzaW5nbGUtd29ya2VyIGpvYnMgdGhhdCBhcmUgcmVzZXJ2ZWQ6XG4gICAgLy8gT25seSBzaG93IHRvIHRoZSB1c2VyIHdobyByZXNlcnZlZCBpdCwgaGlkZSBmcm9tIG90aGVyc1xuICAgIGlmIChqb2Iud29ya2Vyc05lZWRlZCA9PT0gMSAmJiByZXNlcnZhdGlvbkluZm8uaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRVc2VySWQgPT09IHJlc2VydmF0aW9uSW5mby51c2VySWRcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Sm9ic0ZvckRhc2hib2FyZCA9IChqb2JzOiBKb2JbXSwgY3VycmVudFVzZXJJZD86IHN0cmluZykgPT4ge1xuICByZXR1cm4gam9icy5maWx0ZXIoKGpvYikgPT4ge1xuICAgIC8vIEJhc2ljIHN0YXR1cyBmaWx0ZXJcbiAgICBjb25zdCBpc1ZhbGlkU3RhdHVzID1cbiAgICAgIChqb2Iuc3RhdHVzID09PSBKT0JfU1RBVFVTLkFQUFJPVkVEIHx8IGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuT1BFTikgJiYgam9iLnN0YXR1cyAhPT0gSk9CX1NUQVRVUy5DT01QTEVURURcblxuICAgIGlmICghaXNWYWxpZFN0YXR1cykgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCB3b3JrZXJzTmVlZGVkID0gam9iLndvcmtlcnNOZWVkZWQgfHwgam9iLm1heFdvcmtlcnMgfHwgMVxuICAgIGNvbnN0IGN1cnJlbnRBcHBsaWNhdGlvbnMgPSBqb2IuYXBwbGljYXRpb25zQ291bnQgfHwgMFxuXG4gICAgLy8gSWYgam9iIGhhcyByZWFjaGVkIGl0cyB3b3JrZXIgbGltaXQsIGRvbid0IHNob3cgaXQgYXMgYXZhaWxhYmxlXG4gICAgaWYgKGN1cnJlbnRBcHBsaWNhdGlvbnMgPj0gd29ya2Vyc05lZWRlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJbdjBdIERhc2hib2FyZCBqb2JcIiwgam9iLmlkLCBcImF0IGNhcGFjaXR5OlwiLCBjdXJyZW50QXBwbGljYXRpb25zLCBcIm9mXCIsIHdvcmtlcnNOZWVkZWQsIFwid29ya2Vyc1wiKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXJ2YXRpb25JbmZvID0gbG9jYWxSZXNlcnZhdGlvblN0b3JhZ2UuaXNKb2JSZXNlcnZlZChqb2IuaWQpXG5cbiAgICAvLyBJZiBqb2IgaXMgbm90IHJlc2VydmVkLCBzaG93IGl0IHRvIGV2ZXJ5b25lXG4gICAgaWYgKCFyZXNlcnZhdGlvbkluZm8uaXNSZXNlcnZlZCkgcmV0dXJuIHRydWVcblxuICAgIC8vIElmIGpvYiBuZWVkcyBtdWx0aXBsZSB3b3JrZXJzLCBzaG93IGl0IGV2ZW4gd2hlbiByZXNlcnZlZFxuICAgIGlmIChqb2Iud29ya2Vyc05lZWRlZCA+IDEpIHJldHVybiB0cnVlXG5cbiAgICAvLyBGb3Igc2luZ2xlLXdvcmtlciBqb2JzIHRoYXQgYXJlIHJlc2VydmVkOlxuICAgIC8vIE9ubHkgc2hvdyB0byB0aGUgdXNlciB3aG8gcmVzZXJ2ZWQgaXRcbiAgICBpZiAoam9iLndvcmtlcnNOZWVkZWQgPT09IDEgJiYgcmVzZXJ2YXRpb25JbmZvLmlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VXNlcklkID09PSByZXNlcnZhdGlvbkluZm8udXNlcklkXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSlcbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2V0IGpvYiBzdGF0dXMgaGlzdG9yeVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEpvYlN0YXR1c0hpc3Rvcnkoam9iSWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iU3RhdHVzSGlzdG9yeVtdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGhpc3RvcnkgPSBnZXRTdG9yZWRKb2JTdGF0dXNIaXN0b3J5KClcbiAgcmV0dXJuIGhpc3RvcnlcbiAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuam9iSWQgPT09IGpvYklkKVxuICAgIC5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSlcbn1cblxuLy8gRnVuY3Rpb24gdG8gZ2V0IGFsbCBzdGF0dXMgaGlzdG9yeSBmb3IgYWRtaW5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxKb2JTdGF0dXNIaXN0b3J5KCk6IFByb21pc2U8Sm9iU3RhdHVzSGlzdG9yeVtdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGhpc3RvcnkgPSBnZXRTdG9yZWRKb2JTdGF0dXNIaXN0b3J5KClcbiAgcmV0dXJuIGhpc3Rvcnkuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5jcmVhdGVkQXQpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuY3JlYXRlZEF0KS5nZXRUaW1lKCkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhY2NlcHRKb2JBcHBsaWNhdGlvbihhcHBsaWNhdGlvbklkOiBzdHJpbmcsIGVtcGxveWVySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iQXBwbGljYXRpb24+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICBjb25zdCBhcHBsaWNhdGlvbkluZGV4ID0gYXBwbGljYXRpb25zLmZpbmRJbmRleCgoYXBwKSA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpXG5cbiAgaWYgKGFwcGxpY2F0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXBwbGljYXRpb24gbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBhcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uc1thcHBsaWNhdGlvbkluZGV4XVxuXG4gIC8vIFZlcmlmeSBlbXBsb3llciBvd25zIHRoZSBqb2JcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBhcHBsaWNhdGlvbi5qb2JJZClcbiAgY29uc3Qgam9iID0gam9ic1tqb2JJbmRleF1cblxuICBpZiAoIWpvYiB8fCBqb2IudXNlcklkICE9PSBlbXBsb3llcklkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGRvbid0IGhhdmUgcGVybWlzc2lvbiB0byBhY2NlcHQgdGhpcyBhcHBsaWNhdGlvblwiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZEFwcGxpY2F0aW9uID0ge1xuICAgIC4uLmFwcGxpY2F0aW9uLFxuICAgIHN0YXR1czogXCJhY2NlcHRlZFwiIGFzIGNvbnN0LFxuICAgIGFjY2VwdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIGFwcGxpY2F0aW9uc1thcHBsaWNhdGlvbkluZGV4XSA9IHVwZGF0ZWRBcHBsaWNhdGlvblxuICBzYXZlQXBwbGljYXRpb25zKGFwcGxpY2F0aW9ucylcblxuICBjb25zdCB1cGRhdGVkSm9iID0ge1xuICAgIC4uLmpvYixcbiAgICBzdGF0dXM6IFwiY29tcGxldGVkXCIgYXMgY29uc3QsXG4gICAgYXNzaWduZWRXb3JrZXJJZDogYXBwbGljYXRpb24uYXBwbGljYW50SWQsXG4gICAgY29tcGxldGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBhZGRXYWxsZXRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi93YWxsZXRcIilcblxuICAgIGNvbnN0IHBheW1lbnRBbW91bnQgPSBhcHBsaWNhdGlvbi5wcm9wb3NlZEJ1ZGdldFxuXG4gICAgaWYgKCFwYXltZW50QW1vdW50IHx8IHBheW1lbnRBbW91bnQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheW1lbnQgYW1vdW50OiAke3BheW1lbnRBbW91bnR9YClcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcGxhdGZvcm0gZmVlICg1JSBkZWZhdWx0KVxuICAgIGNvbnN0IHBsYXRmb3JtRmVlU2V0dGluZ3MgPSBhd2FpdCBnZXRQbGF0Zm9ybUZlZVNldHRpbmdzKClcbiAgICBsZXQgcGxhdGZvcm1GZWVSYXRlID0gMC4wNSAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgbGV0IHBsYXRmb3JtRmVlID0gMFxuXG4gICAgaWYgKHBsYXRmb3JtRmVlU2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IGZlZUNhbGN1bGF0aW9uID0gY2FsY3VsYXRlUGxhdGZvcm1GZWUocGF5bWVudEFtb3VudCwgcGxhdGZvcm1GZWVTZXR0aW5ncylcbiAgICAgIHBsYXRmb3JtRmVlID0gZmVlQ2FsY3VsYXRpb24ucGxhdGZvcm1GZWVcbiAgICAgIHBsYXRmb3JtRmVlUmF0ZSA9IHBsYXRmb3JtRmVlU2V0dGluZ3MuZmVlUGVyY2VudGFnZSAvIDEwMFxuICAgIH0gZWxzZSB7XG4gICAgICBwbGF0Zm9ybUZlZSA9IE1hdGgucm91bmQocGF5bWVudEFtb3VudCAqIHBsYXRmb3JtRmVlUmF0ZSAqIDEwMCkgLyAxMDBcbiAgICB9XG5cbiAgICBjb25zdCB3b3JrZXJBbW91bnQgPSBNYXRoLnJvdW5kKChwYXltZW50QW1vdW50IC0gcGxhdGZvcm1GZWUpICogMTAwKSAvIDEwMCAvLyBSb3VuZCB0byAyIGRlY2ltYWxzXG5cbiAgICBjb25zb2xlLmxvZyhgW3YwXSDwn5KwIFByb2Nlc3NpbmcgaW5zdGFudCBwYXltZW50OmApXG4gICAgY29uc29sZS5sb2coYFt2MF0gLSBUb3RhbCBqb2IgYW1vdW50OiAkJHtwYXltZW50QW1vdW50fWApXG4gICAgY29uc29sZS5sb2coYFt2MF0gLSBQbGF0Zm9ybSBmZWUgKDUlKTogJCR7cGxhdGZvcm1GZWV9YClcbiAgICBjb25zb2xlLmxvZyhgW3YwXSAtIFdvcmtlciByZWNlaXZlczogJCR7d29ya2VyQW1vdW50fWApXG4gICAgY29uc29sZS5sb2coYFt2MF0gLSBXb3JrZXIgSUQ6ICR7YXBwbGljYXRpb24uYXBwbGljYW50SWR9YClcblxuICAgIC8vIEFkZCBtb25leSB0byB3b3JrZXIncyB3aXRoZHJhd2FsIGJhbGFuY2VcbiAgICBhd2FpdCBhZGRXYWxsZXRUcmFuc2FjdGlvbihhcHBsaWNhdGlvbi5hcHBsaWNhbnRJZCwge1xuICAgICAgdHlwZTogXCJqb2JfcGF5bWVudFwiLFxuICAgICAgYW1vdW50OiB3b3JrZXJBbW91bnQsXG4gICAgICBkZXNjcmlwdGlvbjogYFBheW1lbnQgZm9yIGpvYjogJHtqb2IudGl0bGV9YCxcbiAgICAgIGpvYklkOiBqb2IuaWQsXG4gICAgICBmcm9tVXNlcklkOiBlbXBsb3llcklkLFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW3YwXSDinIUgUGF5bWVudCBzdWNjZXNzZnVsbHkgYWRkZWQgdG8gd29ya2VyICR7YXBwbGljYXRpb24uYXBwbGljYW50SWR9IHdhbGxldDogJCR7d29ya2VyQW1vdW50fWApXG5cbiAgICAvLyBSZWNvcmQgcGxhdGZvcm0gZmVlXG4gICAgYXdhaXQgYWRkV2FsbGV0VHJhbnNhY3Rpb24oXCJwbGF0Zm9ybVwiLCB7XG4gICAgICB0eXBlOiBcInBsYXRmb3JtX2ZlZVwiLFxuICAgICAgYW1vdW50OiBwbGF0Zm9ybUZlZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBgUGxhdGZvcm0gZmVlIGZvciBqb2I6ICR7am9iLnRpdGxlfWAsXG4gICAgICBqb2JJZDogam9iLmlkLFxuICAgICAgZnJvbVVzZXJJZDogZW1wbG95ZXJJZCxcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYFt2MF0g4pyFIFBsYXRmb3JtIGZlZSByZWNvcmRlZDogJCR7cGxhdGZvcm1GZWV9YClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDinYwgRXJyb3IgcHJvY2Vzc2luZyBpbnN0YW50IHBheW1lbnQ6XCIsIGVycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcihgUGF5bWVudCBwcm9jZXNzaW5nIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIGZvciBhcHBsaWNhbnRcbiAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgIHVzZXJJZDogYXBwbGljYXRpb24uYXBwbGljYW50SWQsXG4gICAgdHlwZTogXCJqb2JcIixcbiAgICB0aXRsZTogXCJKb2IgQWNjZXB0ZWQgJiBQYXltZW50IFJlbGVhc2VkIVwiLFxuICAgIGRlc2NyaXB0aW9uOiBgWW91ciBhcHBsaWNhdGlvbiBmb3IgXCIke2pvYi50aXRsZX1cIiBoYXMgYmVlbiBhY2NlcHRlZCBhbmQgcGF5bWVudCBvZiAkJHthcHBsaWNhdGlvbi5wcm9wb3NlZEJ1ZGdldCAtIGFwcGxpY2F0aW9uLnByb3Bvc2VkQnVkZ2V0ICogMC4wNX0gaGFzIGJlZW4gYWRkZWQgdG8geW91ciB3aXRoZHJhd2FsIGJhbGFuY2UhYCxcbiAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL3dhbGxldGAsXG4gIH0pXG5cbiAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBmb3IgZW1wbG95ZXJcbiAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICB1c2VySWQ6IGVtcGxveWVySWQsXG4gICAgdHlwZTogXCJqb2JcIixcbiAgICB0aXRsZTogXCJKb2IgQ29tcGxldGVkXCIsXG4gICAgZGVzY3JpcHRpb246IGBKb2IgXCIke2pvYi50aXRsZX1cIiBoYXMgYmVlbiBjb21wbGV0ZWQgYW5kIHBheW1lbnQgaGFzIGJlZW4gcmVsZWFzZWQgdG8gdGhlIHdvcmtlci5gLFxuICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvam9ic2AsXG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRBcHBsaWNhdGlvblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVqZWN0Sm9iQXBwbGljYXRpb24oXG4gIGFwcGxpY2F0aW9uSWQ6IHN0cmluZyxcbiAgZW1wbG95ZXJJZDogc3RyaW5nLFxuICByZWFzb246IHN0cmluZyxcbik6IFByb21pc2U8Sm9iQXBwbGljYXRpb24+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICBjb25zdCBhcHBsaWNhdGlvbkluZGV4ID0gYXBwbGljYXRpb25zLmZpbmRJbmRleCgoYXBwKSA9PiBhcHAuaWQgPT09IGFwcGxpY2F0aW9uSWQpXG5cbiAgaWYgKGFwcGxpY2F0aW9uSW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXBwbGljYXRpb24gbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBhcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uc1thcHBsaWNhdGlvbkluZGV4XVxuXG4gIC8vIFZlcmlmeSBlbXBsb3llciBvd25zIHRoZSBqb2JcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2IgPSBqb2JzLmZpbmQoKGopID0+IGouaWQgPT09IGFwcGxpY2F0aW9uLmpvYklkKVxuXG4gIGlmICgham9iIHx8IGpvYi51c2VySWQgIT09IGVtcGxveWVySWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIHJlamVjdCB0aGlzIGFwcGxpY2F0aW9uXCIpXG4gIH1cblxuICBjb25zdCB1cGRhdGVkQXBwbGljYXRpb24gPSB7XG4gICAgLi4uYXBwbGljYXRpb24sXG4gICAgc3RhdHVzOiBcInJlamVjdGVkXCIgYXMgY29uc3QsXG4gICAgcmVqZWN0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHJlamVjdGlvblJlYXNvbjogcmVhc29uLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdID0gdXBkYXRlZEFwcGxpY2F0aW9uXG4gIHNhdmVBcHBsaWNhdGlvbnMoYXBwbGljYXRpb25zKVxuXG4gIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIGFwcGxpY2FudFxuICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG4gIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgdXNlcklkOiBhcHBsaWNhdGlvbi5hcHBsaWNhbnRJZCxcbiAgICB0eXBlOiBcImpvYlwiLFxuICAgIHRpdGxlOiBcIkFwcGxpY2F0aW9uIFJlamVjdGVkXCIsXG4gICAgZGVzY3JpcHRpb246IGBZb3VyIGFwcGxpY2F0aW9uIGZvciBcIiR7am9iLnRpdGxlfVwiIHdhcyBub3Qgc2VsZWN0ZWQuIEtlZXAgYXBwbHlpbmcgdG8gb3RoZXIgb3Bwb3J0dW5pdGllcyFgLFxuICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvYXBwbGllZC1qb2JzYCxcbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZEFwcGxpY2F0aW9uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VySm9icyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCB1c2VySm9icyA9IGpvYnMuZmlsdGVyKChqb2IpID0+IGpvYi51c2VySWQgPT09IHVzZXJJZClcblxuICBjb25zdCBqb2JzV2l0aENvdW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHVzZXJKb2JzLm1hcChhc3luYyAoam9iKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgYXBwbGljYXRpb25zIGZvciB0aGlzIGpvYlxuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBhd2FpdCBnZXRKb2JBcHBsaWNhdGlvbnMoam9iLmlkKVxuICAgICAgICBjb25zdCBhcHBsaWNhdGlvbnNDb3VudCA9IGFwcGxpY2F0aW9ucy5sZW5ndGhcblxuICAgICAgICBjb25zb2xlLmxvZyhgW3YwXSBKb2IgJHtqb2IuaWR9ICgke2pvYi50aXRsZX0pOiBGb3VuZCAke2FwcGxpY2F0aW9uc0NvdW50fSBhcHBsaWNhdGlvbnNgKVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgam9iIHdpdGggYWN0dWFsIGNvdW50c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmpvYixcbiAgICAgICAgICBhcHBsaWNhdGlvbnNDb3VudCxcbiAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgYSBzaW1wbGUgdmlldyBjb3VudCBiYXNlZCBvbiBhcHBsaWNhdGlvbnNcbiAgICAgICAgICAvLyBJbiBhIHJlYWwgc3lzdGVtLCB0aGlzIHdvdWxkIGJlIHRyYWNrZWQgc2VwYXJhdGVseVxuICAgICAgICAgIHZpZXdzQ291bnQ6IE1hdGgubWF4KGpvYi52aWV3c0NvdW50IHx8IDAsIGFwcGxpY2F0aW9uc0NvdW50ICogMiksXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFt2MF0gRXJyb3IgY291bnRpbmcgYXBwbGljYXRpb25zIGZvciBqb2IgJHtqb2IuaWR9OmAsIGVycm9yKVxuICAgICAgICByZXR1cm4gam9iXG4gICAgICB9XG4gICAgfSksXG4gIClcblxuICByZXR1cm4gam9ic1dpdGhDb3VudHNcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5VG9Kb2IoZGF0YToge1xuICBqb2JJZDogc3RyaW5nXG4gIGFwcGxpY2FudElkOiBzdHJpbmdcbiAgY292ZXJMZXR0ZXI6IHN0cmluZ1xuICBwcm9wb3NlZEJ1ZGdldDogbnVtYmVyXG4gIGVzdGltYXRlZER1cmF0aW9uOiBzdHJpbmdcbiAgcG9ydGZvbGlvTGlua3M6IHN0cmluZ1tdXG59KTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SNIFdPUktFUiBWQUxJREFUSU9OOiBDaGVja2luZyBhcHBsaWNhdGlvbiBmb3Igam9iOlwiLCBkYXRhLmpvYklkLCBcImJ5IHdvcmtlcjpcIiwgZGF0YS5hcHBsaWNhbnRJZClcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYiA9IGpvYnMuZmluZCgoaikgPT4gai5pZCA9PT0gZGF0YS5qb2JJZClcblxuICBpZiAoIWpvYikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmRcIilcbiAgfVxuXG4gIGlmIChqb2Iuc3RhdHVzICE9PSBcImFwcHJvdmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJKb2IgaXMgbm90IGF2YWlsYWJsZSBmb3IgYXBwbGljYXRpb25zXCIpXG4gIH1cblxuICAvLyBDaGVjayBpZiB1c2VyIGFscmVhZHkgYXBwbGllZCB0byB0aGlzIGpvYlxuICBjb25zdCBleGlzdGluZ0FwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGNvbnN0IGV4aXN0aW5nQXBwbGljYXRpb24gPSBleGlzdGluZ0FwcGxpY2F0aW9ucy5maW5kKFxuICAgIChhcHApID0+IGFwcC5qb2JJZCA9PT0gZGF0YS5qb2JJZCAmJiBhcHAuYXBwbGljYW50SWQgPT09IGRhdGEuYXBwbGljYW50SWQsXG4gIClcblxuICBpZiAoZXhpc3RpbmdBcHBsaWNhdGlvbikge1xuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDimqDvuI8gV09SS0VSIFZBTElEQVRJT046IFVzZXIgYWxyZWFkeSBhcHBsaWVkIHRvIHRoaXMgam9iIC0gdHJlYXRpbmcgYXMgcmVzdWJtaXNzaW9uXCIpXG5cbiAgICAvLyBVcGRhdGUgZXhpc3RpbmcgYXBwbGljYXRpb24gaW5zdGVhZCBvZiBjcmVhdGluZyBuZXcgb25lXG4gICAgY29uc3QgYXBwbGljYXRpb25zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImpvYl9hcHBsaWNhdGlvbnNcIikgfHwgXCJbXVwiKVxuICAgIGNvbnN0IGFwcGxpY2F0aW9uSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KChhcHA6IEpvYkFwcGxpY2F0aW9uKSA9PiBhcHAuaWQgPT09IGV4aXN0aW5nQXBwbGljYXRpb24uaWQpXG5cbiAgICBpZiAoYXBwbGljYXRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgIGFwcGxpY2F0aW9uc1thcHBsaWNhdGlvbkluZGV4XSA9IHtcbiAgICAgICAgLi4uYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdLFxuICAgICAgICBjb3ZlckxldHRlcjogZGF0YS5jb3ZlckxldHRlcixcbiAgICAgICAgcHJvcG9zZWRCdWRnZXQ6IGRhdGEucHJvcG9zZWRCdWRnZXQsXG4gICAgICAgIGVzdGltYXRlZER1cmF0aW9uOiBkYXRhLmVzdGltYXRlZER1cmF0aW9uLFxuICAgICAgICBwb3J0Zm9saW9MaW5rczogZGF0YS5wb3J0Zm9saW9MaW5rcyxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHJlc3VibWlzc2lvbkNvdW50OiAoYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdLnJlc3VibWlzc2lvbkNvdW50IHx8IDApICsgMSxcbiAgICAgIH1cblxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJqb2JfYXBwbGljYXRpb25zXCIsIEpTT04uc3RyaW5naWZ5KGFwcGxpY2F0aW9ucykpXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIFdPUktFUiBWQUxJREFUSU9OOiBBcHBsaWNhdGlvbiB1cGRhdGVkIGFzIHJlc3VibWlzc2lvblwiKVxuICAgICAgcmV0dXJuIGFwcGxpY2F0aW9uc1thcHBsaWNhdGlvbkluZGV4XVxuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGlmIGpvYiBoYXMgcmVhY2hlZCB3b3JrZXIgbGltaXRcbiAgY29uc3QgYWNjZXB0ZWRBcHBsaWNhdGlvbnMgPSBleGlzdGluZ0FwcGxpY2F0aW9ucy5maWx0ZXIoKGFwcCkgPT4gYXBwLnN0YXR1cyA9PT0gXCJhY2NlcHRlZFwiKVxuICBjb25zdCB3b3JrZXJzTmVlZGVkID0gam9iLndvcmtlcnNOZWVkZWQgfHwgam9iLm1heFdvcmtlcnMgfHwgMVxuXG4gIGlmIChhY2NlcHRlZEFwcGxpY2F0aW9ucy5sZW5ndGggPj0gd29ya2Vyc05lZWRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBqb2IgaGFzIGFscmVhZHkgcmVhY2hlZCBpdHMgd29ya2VyIGxpbWl0IG9mICR7d29ya2Vyc05lZWRlZH0gd29ya2Vyc2ApXG4gIH1cblxuICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIFdPUktFUiBWQUxJREFUSU9OOiBOZXcgYXBwbGljYXRpb24gYWxsb3dlZFwiKVxuICBjb25zb2xlLmxvZyhcbiAgICBcIlt2MF0g8J+TiiBXT1JLRVIgVkFMSURBVElPTjogQ3VycmVudCBhY2NlcHRlZCB3b3JrZXJzOlwiLFxuICAgIGFjY2VwdGVkQXBwbGljYXRpb25zLmxlbmd0aCxcbiAgICBcIi8gTmVlZGVkOlwiLFxuICAgIHdvcmtlcnNOZWVkZWQsXG4gIClcblxuICAvLyBHZXQgdXNlciBkYXRhIGZvciBhcHBsaWNhdGlvblxuICBjb25zdCB7IGdldEFsbFVzZXJzIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2F1dGhcIilcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXIgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmlkID09PSBkYXRhLmFwcGxpY2FudElkKVxuXG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBuZXdBcHBsaWNhdGlvbjogSm9iQXBwbGljYXRpb24gPSB7XG4gICAgaWQ6IGBhcHBfJHtEYXRlLm5vdygpfWAsXG4gICAgam9iSWQ6IGRhdGEuam9iSWQsXG4gICAgYXBwbGljYW50SWQ6IGRhdGEuYXBwbGljYW50SWQsXG4gICAgY292ZXJMZXR0ZXI6IGRhdGEuY292ZXJMZXR0ZXIsXG4gICAgcHJvcG9zZWRCdWRnZXQ6IGRhdGEucHJvcG9zZWRCdWRnZXQsXG4gICAgZXN0aW1hdGVkRHVyYXRpb246IGRhdGEuZXN0aW1hdGVkRHVyYXRpb24sXG4gICAgcG9ydGZvbGlvTGlua3M6IGRhdGEucG9ydGZvbGlvTGlua3MsXG4gICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBhcHBsaWNhbnQ6IHtcbiAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgZmlyc3ROYW1lOiB1c2VyLmZpcnN0TmFtZSxcbiAgICAgIGxhc3ROYW1lOiB1c2VyLmxhc3ROYW1lLFxuICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXG4gICAgICBhdmF0YXI6IHVzZXIuYXZhdGFyLFxuICAgICAgcmF0aW5nOiB1c2VyLnJhdGluZyxcbiAgICAgIHRvdGFsUmV2aWV3czogdXNlci50b3RhbFJldmlld3MsXG4gICAgICBza2lsbHM6IHVzZXIuc2tpbGxzLFxuICAgIH0sXG4gIH1cblxuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICBhcHBsaWNhdGlvbnMucHVzaChuZXdBcHBsaWNhdGlvbilcbiAgc2F2ZUFwcGxpY2F0aW9ucyhhcHBsaWNhdGlvbnMpXG5cbiAgLy8gVXBkYXRlIGpvYiBhcHBsaWNhdGlvbiBjb3VudFxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBkYXRhLmpvYklkKVxuICBpZiAoam9iSW5kZXggIT09IC0xKSB7XG4gICAgam9ic1tqb2JJbmRleF0uYXBwbGljYXRpb25zQ291bnQgPSAoam9ic1tqb2JJbmRleF0uYXBwbGljYXRpb25zQ291bnQgfHwgMCkgKyAxXG4gICAgc2F2ZUpvYnMoam9icylcbiAgfVxuXG4gIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIGpvYiBwb3N0ZXJcbiAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgIHVzZXJJZDogam9iLnVzZXJJZCxcbiAgICB0eXBlOiBcImpvYlwiLFxuICAgIHRpdGxlOiBcIk5ldyBKb2IgQXBwbGljYXRpb25cIixcbiAgICBkZXNjcmlwdGlvbjogYCR7dXNlci5maXJzdE5hbWV9ICR7dXNlci5sYXN0TmFtZX0gYXBwbGllZCBmb3IgeW91ciBqb2IgXCIke2pvYi50aXRsZX1cImAsXG4gICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9qb2JzLyR7am9iLmlkfS9hcHBsaWNhdGlvbnNgLFxuICB9KVxuXG4gIHJldHVybiBuZXdBcHBsaWNhdGlvblxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlSm9iKGRhdGE6IGFueSk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBTdGFydGluZyBqb2IgY3JlYXRpb24gcHJvY2Vzc1wiKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IFdvcmtlcnMgbmVlZGVkOlwiLCBkYXRhLndvcmtlcnNOZWVkZWQpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogQnVkZ2V0IHBlciB3b3JrZXI6XCIsIGRhdGEuYnVkZ2V0TWluLCBcIi1cIiwgZGF0YS5idWRnZXRNYXgpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogU2NyZWVuc2hvdCByZXF1aXJlbWVudHM6XCIsIGRhdGEucmVxdWlyZVNjcmVlbnNob3RzIHx8IDApXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogQXBwcm92YWwgdHlwZTpcIiwgZGF0YS5hcHByb3ZhbFR5cGUpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogTWFudWFsIGFwcHJvdmFsIGRheXM6XCIsIGRhdGEubWFudWFsQXBwcm92YWxEYXlzKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IENvdW50cnkgcmVzdHJpY3Rpb25zIGVuYWJsZWQ6XCIsIGRhdGEuZW5hYmxlQ291bnRyeVJlc3RyaWN0aW9ucylcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBSZXN0cmljdGlvbiB0eXBlOlwiLCBkYXRhLnJlc3RyaWN0aW9uVHlwZSlcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBBbGxvd2VkIGNvdW50cmllczpcIiwgZGF0YS5hbGxvd2VkQ291bnRyaWVzKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IFJlc3RyaWN0ZWQgY291bnRyaWVzOlwiLCBkYXRhLnJlc3RyaWN0ZWRDb3VudHJpZXMpXG5cbiAgY29uc3QgaXNJbnN0YW50QXBwcm92YWwgPSBkYXRhLmFwcHJvdmFsVHlwZSA9PT0gXCJpbnN0YW50XCJcblxuICBjb25zdCBpc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWRtaW5faW5zdGFudF9hcHByb3ZhbF9lbmFibGVkXCIpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIElOU1RBTlQtQVBQUk9WQUw6IGxvY2FsU3RvcmFnZSBzZXR0aW5nIGZvdW5kOlwiLCBzZXR0aW5nKVxuICAgICAgICBjb25zdCBlbmFibGVkID0gc2V0dGluZyA9PT0gXCJ0cnVlXCJcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogSW5zdGFudCBhcHByb3ZhbCBlbmFibGVkOlwiLCBlbmFibGVkKVxuICAgICAgICByZXR1cm4gZW5hYmxlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT24gc2VydmVyIHNpZGUgb3Igd2hlbiBsb2NhbFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSwgZGVmYXVsdCB0byB0cnVlIGZvciBpbnN0YW50IGFwcHJvdmFsIHJlcXVlc3RzXG4gICAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIElOU1RBTlQtQVBQUk9WQUw6IFNlcnZlciBzaWRlIG9yIG5vIGxvY2FsU3RvcmFnZSwgZGVmYXVsdGluZyB0byB0cnVlIGZvciBpbnN0YW50IHJlcXVlc3RzXCIpXG4gICAgICAgIHJldHVybiBpc0luc3RhbnRBcHByb3ZhbFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDwn5SnIElOU1RBTlQtQVBQUk9WQUw6IEVycm9yIGNoZWNraW5nIHNldHRpbmc6XCIsIGVycm9yKVxuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciwgYWxsb3cgaW5zdGFudCBhcHByb3ZhbCBpZiB1c2VyIHJlcXVlc3RlZCBpdFxuICAgICAgcmV0dXJuIGlzSW5zdGFudEFwcHJvdmFsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2V0RGVmYXVsdE1hbnVhbEFwcHJvdmFsRGF5cyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBkZWZhdWx0RGF5cyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWRtaW5fZGVmYXVsdF9tYW51YWxfYXBwcm92YWxfZGF5c1wiKVxuICAgICAgICByZXR1cm4gZGVmYXVsdERheXMgPyBOdW1iZXIucGFyc2VJbnQoZGVmYXVsdERheXMpIDogM1xuICAgICAgfVxuICAgICAgcmV0dXJuIDMgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDwn5SnIERFRkFVTFQtREFZUzogRXJyb3IgZ2V0dGluZyBkZWZhdWx0IGRheXM6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIDNcbiAgICB9XG4gIH1cblxuICBjb25zdCBjYW5Vc2VJbnN0YW50QXBwcm92YWwgPSBpc0luc3RhbnRBcHByb3ZhbCAmJiBpc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQoKVxuXG4gIGNvbnN0IGV4aXN0aW5nSm9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBuZXh0Sm9iTnVtYmVyID0gZXhpc3RpbmdKb2JzLmxlbmd0aCArIDFcbiAgY29uc3QgZm9ybWF0dGVkSm9iSWQgPSBTdHJpbmcobmV4dEpvYk51bWJlcikucGFkU3RhcnQoMywgXCIwXCIpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBHZW5lcmF0ZWQgam9iIG51bWJlcjpcIiwgbmV4dEpvYk51bWJlciwgXCJmb3JtYXR0ZWQgYXM6XCIsIGZvcm1hdHRlZEpvYklkKVxuXG4gIGNvbnN0IGpvYlN0YXR1cyA9IFwiYXBwcm92ZWRcIiAvLyBBbGwgam9icyBhcmUgYXBwcm92ZWQgaW1tZWRpYXRlbHksIGluc3RhbnQgcGF5bWVudCBoYXBwZW5zIG9uIHdvcmsgc3VibWlzc2lvblxuXG4gIGNvbnN0IGZpbmFsTWFudWFsQXBwcm92YWxEYXlzID0gZGF0YS5tYW51YWxBcHByb3ZhbERheXMgfHwgZ2V0RGVmYXVsdE1hbnVhbEFwcHJvdmFsRGF5cygpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogVXNlciByZXF1ZXN0ZWQgaW5zdGFudCBhcHByb3ZhbDpcIiwgaXNJbnN0YW50QXBwcm92YWwpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIElOU1RBTlQtQVBQUk9WQUw6IENhbiB1c2UgaW5zdGFudCBhcHByb3ZhbDpcIiwgY2FuVXNlSW5zdGFudEFwcHJvdmFsKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBJTlNUQU5ULUFQUFJPVkFMOiBKb2Igc3RhdHVzIHdpbGwgYmU6XCIsIGpvYlN0YXR1cylcbiAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgTUFOVUFMLUFQUFJPVkFMOiBGaW5hbCBtYW51YWwgYXBwcm92YWwgZGF5czpcIiwgZmluYWxNYW51YWxBcHByb3ZhbERheXMpXG5cbiAgY29uc3QgYnVkZ2V0UGVyV29ya2VyID0gZGF0YS5idWRnZXRNYXggfHwgZGF0YS5idWRnZXRNaW5cbiAgY29uc3QgYmFzZUpvYkNvc3QgPSBidWRnZXRQZXJXb3JrZXIgKiBkYXRhLndvcmtlcnNOZWVkZWRcblxuICAvLyBDYWxjdWxhdGUgc2NyZWVuc2hvdCBjb3N0c1xuICBsZXQgc2NyZWVuc2hvdENvc3QgPSAwXG4gIGlmIChkYXRhLnJlcXVpcmVTY3JlZW5zaG90cyA+IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBjYWxjdWxhdGVTY3JlZW5zaG90Q29zdHMgfSA9IGF3YWl0IGltcG9ydChcIi4vc2NyZWVuc2hvdC1wcmljaW5nXCIpXG4gICAgICBjb25zdCBzY3JlZW5zaG90Q2FsY3VsYXRpb24gPSBhd2FpdCBjYWxjdWxhdGVTY3JlZW5zaG90Q29zdHMoZGF0YS5yZXF1aXJlU2NyZWVuc2hvdHMsIGJhc2VKb2JDb3N0KVxuICAgICAgc2NyZWVuc2hvdENvc3QgPSBzY3JlZW5zaG90Q2FsY3VsYXRpb24udG90YWxTY3JlZW5zaG90Q29zdFxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfk7ggSk9CIENSRUFUSU9OOiBTY3JlZW5zaG90IGNvc3QgY2FsY3VsYXRlZDpcIiwgc2NyZWVuc2hvdENvc3QpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIPCfk7ggSk9CIENSRUFUSU9OOiBFcnJvciBjYWxjdWxhdGluZyBzY3JlZW5zaG90IGNvc3RzOlwiLCBlcnJvcilcbiAgICAgIC8vIEZhbGxiYWNrIGNhbGN1bGF0aW9uXG4gICAgICBzY3JlZW5zaG90Q29zdCA9IGRhdGEucmVxdWlyZVNjcmVlbnNob3RzICogMC4wNVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN1YnRvdGFsID0gYmFzZUpvYkNvc3QgKyBzY3JlZW5zaG90Q29zdFxuXG4gIGxldCBwbGF0Zm9ybUZlZSA9IDBcbiAgbGV0IHBsYXRmb3JtRmVlUmF0ZSA9IDAuMDUgLy8gRGVmYXVsdCBmYWxsYmFja1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcGxhdGZvcm1GZWVTZXR0aW5ncyA9IGF3YWl0IGdldFBsYXRmb3JtRmVlU2V0dGluZ3MoKVxuICAgIGlmIChwbGF0Zm9ybUZlZVNldHRpbmdzKSB7XG4gICAgICBjb25zdCBmZWVDYWxjdWxhdGlvbiA9IGNhbGN1bGF0ZVBsYXRmb3JtRmVlKHN1YnRvdGFsLCBwbGF0Zm9ybUZlZVNldHRpbmdzKVxuICAgICAgcGxhdGZvcm1GZWUgPSBmZWVDYWxjdWxhdGlvbi5wbGF0Zm9ybUZlZVxuICAgICAgcGxhdGZvcm1GZWVSYXRlID0gcGxhdGZvcm1GZWVTZXR0aW5ncy5mZWVQZXJjZW50YWdlIC8gMTAwXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFVzaW5nIGNvbmZpZ3VyYWJsZSBwbGF0Zm9ybSBmZWU6XCIsIHBsYXRmb3JtRmVlU2V0dGluZ3MuZmVlUGVyY2VudGFnZSArIFwiJVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBwbGF0Zm9ybUZlZSA9IHN1YnRvdGFsICogcGxhdGZvcm1GZWVSYXRlXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFVzaW5nIGRlZmF1bHQgcGxhdGZvcm0gZmVlOiA1JVwiKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDwn5KwIEpPQiBDUkVBVElPTjogRXJyb3IgbG9hZGluZyBwbGF0Zm9ybSBmZWUgc2V0dGluZ3MsIHVzaW5nIGRlZmF1bHQ6XCIsIGVycm9yKVxuICAgIHBsYXRmb3JtRmVlID0gc3VidG90YWwgKiBwbGF0Zm9ybUZlZVJhdGVcbiAgfVxuXG4gIGNvbnN0IHRvdGFsV2l0aEZlZXMgPSBzdWJ0b3RhbCArIHBsYXRmb3JtRmVlXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSk9CIENSRUFUSU9OOiBCYXNlIGpvYiBjb3N0OlwiLCBiYXNlSm9iQ29zdClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSk9CIENSRUFUSU9OOiBTY3JlZW5zaG90IGNvc3Q6XCIsIHNjcmVlbnNob3RDb3N0KVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFN1YnRvdGFsOlwiLCBzdWJ0b3RhbClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSk9CIENSRUFUSU9OOiBQbGF0Zm9ybSBmZWU6XCIsIHBsYXRmb3JtRmVlKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFRvdGFsIHdpdGggZmVlczpcIiwgdG90YWxXaXRoRmVlcylcblxuICAvLyBDaGVjayBhbmQgZGVkdWN0IGZyb20gdXNlcidzIGRlcG9zaXQgd2FsbGV0XG4gIHRyeSB7XG4gICAgY29uc3QgeyBnZXRXYWxsZXQsIGFkZFdhbGxldFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3dhbGxldFwiKVxuICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IGdldFdhbGxldChkYXRhLnVzZXJJZClcblxuICAgIGlmICh3YWxsZXQuZGVwb3NpdEJhbGFuY2UgPCB0b3RhbFdpdGhGZWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnN1ZmZpY2llbnQgZGVwb3NpdCBiYWxhbmNlLiBSZXF1aXJlZDogJCR7dG90YWxXaXRoRmVlcy50b0ZpeGVkKDIpfSwgQXZhaWxhYmxlOiAkJHt3YWxsZXQuZGVwb3NpdEJhbGFuY2UudG9GaXhlZCgyKX1gLFxuICAgICAgKVxuICAgIH1cblxuICAgIGxldCB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uID0gYEpvYiBjcmVhdGlvbiBkZXBvc2l0IGZvcjogJHtkYXRhLnRpdGxlfSAoJHtkYXRhLndvcmtlcnNOZWVkZWR9IHdvcmtlcnMgw5cgJCR7YnVkZ2V0UGVyV29ya2VyfWBcbiAgICBpZiAoc2NyZWVuc2hvdENvc3QgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uICs9IGAgKyAkJHtzY3JlZW5zaG90Q29zdC50b0ZpeGVkKDIpfSBzY3JlZW5zaG90IGZlZWBcbiAgICB9XG4gICAgdHJhbnNhY3Rpb25EZXNjcmlwdGlvbiArPSBgICsgJCR7cGxhdGZvcm1GZWUudG9GaXhlZCgyKX0gcGxhdGZvcm0gZmVlKWBcblxuICAgIC8vIERlZHVjdCBlc3RpbWF0ZWQgY29zdCBmcm9tIGRlcG9zaXQgYmFsYW5jZVxuICAgIGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKHtcbiAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXG4gICAgICB0eXBlOiBcInBheW1lbnRcIixcbiAgICAgIGFtb3VudDogLXRvdGFsV2l0aEZlZXMsXG4gICAgICBkZXNjcmlwdGlvbjogdHJhbnNhY3Rpb25EZXNjcmlwdGlvbixcbiAgICAgIHJlZmVyZW5jZUlkOiBgam9iXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgcmVmZXJlbmNlVHlwZTogXCJqb2JfY3JlYXRpb25cIixcbiAgICAgIGJhbGFuY2VUeXBlOiBcImRlcG9zaXRcIixcbiAgICB9KVxuXG4gICAgY29uc29sZS5sb2coXCJbdjBdIOKchSBKT0IgQ1JFQVRJT046IERlcG9zaXQgZGVkdWN0ZWQgc3VjY2Vzc2Z1bGx5OlwiLCB0b3RhbFdpdGhGZWVzKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIOKdjCBKT0IgQ1JFQVRJT046IERlcG9zaXQgZGVkdWN0aW9uIGZhaWxlZDpcIiwgZXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBqb2IgY3JlYXRpb24gZGVwb3NpdDogJHtlcnJvci5tZXNzYWdlfWApXG4gIH1cblxuICBjb25zdCBuZXdKb2I6IEpvYiA9IHtcbiAgICBpZDogYGpvYl8ke0RhdGUubm93KCl9YCxcbiAgICBqb2JOdW1iZXI6IG5leHRKb2JOdW1iZXIsIC8vIEFkZGVkIHNlcXVlbnRpYWwgam9iIG51bWJlclxuICAgIGZvcm1hdHRlZEpvYklkOiBmb3JtYXR0ZWRKb2JJZCwgLy8gQWRkZWQgZm9ybWF0dGVkIGpvYiBJRCBmb3IgZGlzcGxheVxuICAgIHVzZXJJZDogZGF0YS51c2VySWQsXG4gICAgY2F0ZWdvcnlJZDogZGF0YS5jYXRlZ29yeUlkLFxuICAgIHN1YmNhdGVnb3J5SWQ6IGRhdGEuc3ViY2F0ZWdvcnlJZCxcbiAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICByZXF1aXJlbWVudHM6IGRhdGEucmVxdWlyZW1lbnRzLFxuICAgIGluc3RydWN0aW9uczogZGF0YS5pbnN0cnVjdGlvbnMsXG4gICAgYnVkZ2V0TWluOiBkYXRhLmJ1ZGdldE1pbixcbiAgICBidWRnZXRNYXg6IGRhdGEuYnVkZ2V0TWF4LFxuICAgIGRlYWRsaW5lOiBkYXRhLmRlYWRsaW5lLFxuICAgIGxvY2F0aW9uOiBkYXRhLmxvY2F0aW9uIHx8IFwiUmVtb3RlXCIsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgc3RhdHVzOiBqb2JTdGF0dXMsXG4gICAgcHJpb3JpdHk6IFwibm9ybWFsXCIsXG4gICAgc2tpbGxzUmVxdWlyZWQ6IFtdLFxuICAgIGFwcGxpY2F0aW9uc0NvdW50OiAwLFxuICAgIHZpZXdzQ291bnQ6IDAsXG4gICAgd29ya2Vyc05lZWRlZDogZGF0YS53b3JrZXJzTmVlZGVkLFxuICAgIG1heFdvcmtlcnM6IGRhdGEud29ya2Vyc05lZWRlZCxcbiAgICB0YWdzOiBkYXRhLnRhZ3MgfHwgW10sXG4gICAgYXR0YWNobWVudHM6IGRhdGEuYXR0YWNobWVudHMgfHwgW10sXG4gICAgcmVxdWlyZVNjcmVlbnNob3RzOiBkYXRhLnJlcXVpcmVTY3JlZW5zaG90cyB8fCAwLFxuICAgIHNjcmVlbnNob3RDb3N0OiAoZGF0YS5yZXF1aXJlU2NyZWVuc2hvdHMgfHwgMCkgKiAwLjA1LFxuICAgIGVzdGltYXRlZEFwcHJvdmFsRGF5czogZGF0YS5lc3RpbWF0ZWRBcHByb3ZhbERheXMgfHwgMSxcbiAgICBhcHByb3ZhbFR5cGU6IGRhdGEuYXBwcm92YWxUeXBlIHx8IFwibWFudWFsXCIsXG4gICAgbWFudWFsQXBwcm92YWxEYXlzOiBmaW5hbE1hbnVhbEFwcHJvdmFsRGF5cyxcbiAgICBpc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQ6IGNhblVzZUluc3RhbnRBcHByb3ZhbCxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBzdWJtaXR0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGFwcHJvdmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSwgLy8gQWxsIGpvYnMgYXJlIGFwcHJvdmVkIGltbWVkaWF0ZWx5XG4gICAgYXBwcm92ZWRCeTogXCJTeXN0ZW1cIixcbiAgICBhcHByb3ZhbFJlYXNvbjogXCJKb2IgYXBwcm92ZWQgZm9yIHBvc3RpbmdcIixcbiAgICBlc3RpbWF0ZWRUb3RhbENvc3Q6IHN1YnRvdGFsLFxuICAgIGRlcG9zaXREZWR1Y3RlZDogdG90YWxXaXRoRmVlcyxcbiAgICBlbmFibGVDb3VudHJ5UmVzdHJpY3Rpb25zOiBkYXRhLmVuYWJsZUNvdW50cnlSZXN0cmljdGlvbnMgfHwgZmFsc2UsXG4gICAgcmVzdHJpY3Rpb25UeXBlOiBkYXRhLnJlc3RyaWN0aW9uVHlwZSB8fCBcImluY2x1ZGVcIixcbiAgICBhbGxvd2VkQ291bnRyaWVzOiBkYXRhLmFsbG93ZWRDb3VudHJpZXMgfHwgW10sXG4gICAgcmVzdHJpY3RlZENvdW50cmllczogZGF0YS5yZXN0cmljdGVkQ291bnRyaWVzIHx8IFtdLFxuICAgIGNhdGVnb3J5OiB7XG4gICAgICBpZDogZGF0YS5jYXRlZ29yeUlkLFxuICAgICAgbmFtZTogXCJVbmtub3duIENhdGVnb3J5XCIsXG4gICAgICBzbHVnOiBcInVua25vd25cIixcbiAgICB9LFxuICB9XG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBqb2JzLnB1c2gobmV3Sm9iKVxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJldHVybiBuZXdKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZUpvYk9uKGpvYklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGpvYklkICYmIGoudXNlcklkID09PSB1c2VySWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmQgb3IgdW5hdXRob3JpemVkXCIpXG5cbiAgY29uc3Qgam9iID0gam9ic1tqb2JJbmRleF1cbiAgY29uc3Qgb2xkU3RhdHVzID0gam9iLnN0YXR1c1xuXG4gIC8vIE9ubHkgYWxsb3cgdG9nZ2xlIGlmIGpvYiB3YXMgcHJldmlvdXNseSBhcHByb3ZlZC9vcGVuIG9yIHN1c3BlbmRlZFxuICBpZiAoIVtcInN1c3BlbmRlZFwiLCBcIm9wZW5cIiwgXCJhcHByb3ZlZFwiXS5pbmNsdWRlcyhvbGRTdGF0dXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSm9iIGNhbm5vdCBiZSB0dXJuZWQgb24gZnJvbSBjdXJyZW50IHN0YXR1c1wiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJvcGVuXCIsIHVzZXJJZClcbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKGpvYklkLCBvbGRTdGF0dXMsIFwib3BlblwiLCB1c2VySWQsIFwiSm9iIHR1cm5lZCBvbiBieSBvd25lclwiLCB7XG4gICAgdXNlckFjdGlvbjogXCJ0b2dnbGVfb25cIixcbiAgICBpbnN0YW50VG9nZ2xlOiB0cnVlLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b2dnbGVKb2JPZmYoam9iSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQgJiYgai51c2VySWQgPT09IHVzZXJJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZCBvciB1bmF1dGhvcml6ZWRcIilcblxuICBjb25zdCBqb2IgPSBqb2JzW2pvYkluZGV4XVxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2Iuc3RhdHVzXG5cbiAgLy8gT25seSBhbGxvdyB0b2dnbGUgaWYgam9iIGlzIGN1cnJlbnRseSBvcGVuL2FwcHJvdmVkXG4gIGlmICghW1wib3BlblwiLCBcImFwcHJvdmVkXCJdLmluY2x1ZGVzKG9sZFN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJKb2IgY2Fubm90IGJlIHR1cm5lZCBvZmYgZnJvbSBjdXJyZW50IHN0YXR1c1wiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJzdXNwZW5kZWRcIiwgdXNlcklkKVxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZWNvcmRTdGF0dXNDaGFuZ2Uoam9iSWQsIG9sZFN0YXR1cywgXCJzdXNwZW5kZWRcIiwgdXNlcklkLCBcIkpvYiB0dXJuZWQgb2ZmIGJ5IG93bmVyXCIsIHtcbiAgICB1c2VyQWN0aW9uOiBcInRvZ2dsZV9vZmZcIixcbiAgICBpbnN0YW50VG9nZ2xlOiB0cnVlLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVKb2JXb3JrZXJzKFxuICBqb2JJZDogc3RyaW5nLFxuICBuZXdXb3JrZXJDb3VudDogbnVtYmVyLFxuICB1c2VySWQ6IHN0cmluZyxcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmc7IGFkZGl0aW9uYWxDb3N0PzogbnVtYmVyIH0+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogU3RhcnRpbmcgd29ya2VyIGNvdW50IHVwZGF0ZSBmb3Igam9iOlwiLCBqb2JJZClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IE5ldyB3b3JrZXIgY291bnQ6XCIsIG5ld1dvcmtlckNvdW50KVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoam9iKSA9PiBqb2IuaWQgPT09IGpvYklkICYmIGpvYi51c2VySWQgPT09IHVzZXJJZClcblxuICBpZiAoam9iSW5kZXggPT09IC0xKSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIOKdjCBVUERBVEUtV09SS0VSUzogSm9iIG5vdCBmb3VuZCBvciB1bmF1dGhvcml6ZWRcIilcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogXCJKb2Igbm90IGZvdW5kIG9yIHlvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gbW9kaWZ5IGl0LlwiIH1cbiAgfVxuXG4gIGNvbnN0IGpvYiA9IGpvYnNbam9iSW5kZXhdXG4gIGNvbnN0IGN1cnJlbnRXb3JrZXJDb3VudCA9IGpvYi53b3JrZXJzTmVlZGVkXG4gIGNvbnN0IHdvcmtlckRpZmZlcmVuY2UgPSBuZXdXb3JrZXJDb3VudCAtIGN1cnJlbnRXb3JrZXJDb3VudFxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBDdXJyZW50IHdvcmtlcnM6XCIsIGN1cnJlbnRXb3JrZXJDb3VudClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IFdvcmtlciBkaWZmZXJlbmNlOlwiLCB3b3JrZXJEaWZmZXJlbmNlKVxuXG4gIGlmICh3b3JrZXJEaWZmZXJlbmNlID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IE5vIGNoYW5nZSBpbiB3b3JrZXIgY291bnRcIilcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiBcIldvcmtlciBjb3VudCB1bmNoYW5nZWQuXCIgfVxuICB9XG5cbiAgaWYgKHdvcmtlckRpZmZlcmVuY2UgPCAwKSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IFJlZHVjaW5nIHdvcmtlciBjb3VudCAtIG5vIGFkZGl0aW9uYWwgcGF5bWVudCBuZWVkZWRcIilcbiAgICBqb2JzW2pvYkluZGV4XS53b3JrZXJzTmVlZGVkID0gbmV3V29ya2VyQ291bnRcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShKT0JTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShqb2JzKSlcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogVXBkYXRlZCBqb2Igc2F2ZWQgdG8gbG9jYWxTdG9yYWdlIHdpdGgga2V5OlwiLCBKT0JTX1NUT1JBR0VfS0VZKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IGBXb3JrZXIgY291bnQgcmVkdWNlZCB0byAke25ld1dvcmtlckNvdW50fS5gIH1cbiAgfVxuXG4gIGNvbnN0IGNvc3RQZXJXb3JrZXIgPSBqb2IuYnVkZ2V0TWF4IHx8IGpvYi5idWRnZXRNaW4gfHwgMFxuICBjb25zdCBhZGRpdGlvbmFsQmFzZUNvc3QgPSB3b3JrZXJEaWZmZXJlbmNlICogY29zdFBlcldvcmtlclxuXG4gIC8vIENhbGN1bGF0ZSBhZGRpdGlvbmFsIHNjcmVlbnNob3QgY29zdHMgcHJvcG9ydGlvbmFsbHlcbiAgbGV0IGFkZGl0aW9uYWxTY3JlZW5zaG90Q29zdCA9IDBcbiAgaWYgKGpvYi5yZXF1aXJlU2NyZWVuc2hvdHMgPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY2FsY3VsYXRlU2NyZWVuc2hvdENvc3RzIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3NjcmVlbnNob3QtcHJpY2luZ1wiKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgc2NyZWVuc2hvdCBjb3N0IGZvciBuZXcgdG90YWwgd29ya2Vyc1xuICAgICAgY29uc3QgbmV3VG90YWxCYXNlQ29zdCA9IG5ld1dvcmtlckNvdW50ICogY29zdFBlcldvcmtlclxuXG4gICAgICAvLyBDYWxjdWxhdGUgY3VycmVudCBzY3JlZW5zaG90IGNvc3QgZm9yIGNvbXBhcmlzb25cbiAgICAgIGNvbnN0IGN1cnJlbnRUb3RhbEJhc2VDb3N0ID0gY3VycmVudFdvcmtlckNvdW50ICogY29zdFBlcldvcmtlclxuICAgICAgY29uc3QgY3VycmVudFNjcmVlbnNob3RDb3N0ID0gKGF3YWl0IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyhqb2IucmVxdWlyZVNjcmVlbnNob3RzLCBjdXJyZW50VG90YWxCYXNlQ29zdCkpXG4gICAgICAgIC50b3RhbFNjcmVlbnNob3RDb3N0XG5cbiAgICAgIGNvbnN0IG5ld1NjcmVlbnNob3RDb3N0ID0gKGF3YWl0IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyhqb2IucmVxdWlyZVNjcmVlbnNob3RzLCBuZXdUb3RhbEJhc2VDb3N0KSlcbiAgICAgICAgLnRvdGFsU2NyZWVuc2hvdENvc3RcblxuICAgICAgYWRkaXRpb25hbFNjcmVlbnNob3RDb3N0ID0gbmV3U2NyZWVuc2hvdENvc3QgLSBjdXJyZW50U2NyZWVuc2hvdENvc3RcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBBZGRpdGlvbmFsIHNjcmVlbnNob3QgY29zdDpcIiwgYWRkaXRpb25hbFNjcmVlbnNob3RDb3N0KVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSDinYwgVVBEQVRFLVdPUktFUlM6IEVycm9yIGNhbGN1bGF0aW5nIHNjcmVlbnNob3QgY29zdHM6XCIsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBsYXRmb3JtRmVlUmF0ZSA9IDAuMDVcbiAgY29uc3Qgc3VidG90YWwgPSBhZGRpdGlvbmFsQmFzZUNvc3QgKyBhZGRpdGlvbmFsU2NyZWVuc2hvdENvc3RcbiAgY29uc3QgcGxhdGZvcm1GZWUgPSBzdWJ0b3RhbCAqIHBsYXRmb3JtRmVlUmF0ZVxuICBjb25zdCB0b3RhbEFkZGl0aW9uYWxDb3N0ID0gc3VidG90YWwgKyBwbGF0Zm9ybUZlZVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBDb3N0IGJyZWFrZG93bjpcIiwge1xuICAgIGFkZGl0aW9uYWxCYXNlQ29zdCxcbiAgICBhZGRpdGlvbmFsU2NyZWVuc2hvdENvc3QsXG4gICAgcGxhdGZvcm1GZWUsXG4gICAgdG90YWxBZGRpdGlvbmFsQ29zdCxcbiAgfSlcblxuICBjb25zdCB7IGdldFdhbGxldCB9ID0gYXdhaXQgaW1wb3J0KFwiLi93YWxsZXRcIilcbiAgLy8gQ2hlY2sgd2FsbGV0IGJhbGFuY2VcbiAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgZ2V0V2FsbGV0KHVzZXJJZClcbiAgaWYgKHdhbGxldC5kZXBvc2l0QmFsYW5jZSA8IHRvdGFsQWRkaXRpb25hbENvc3QpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g4p2MIFVQREFURS1XT1JLRVJTOiBJbnN1ZmZpY2llbnQgYmFsYW5jZVwiKVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnN1ZmZpY2llbnQgZGVwb3NpdCBiYWxhbmNlLiBSZXF1aXJlZDogJCR7dG90YWxBZGRpdGlvbmFsQ29zdC50b0ZpeGVkKDIpfSwgQXZhaWxhYmxlOiAkJHt3YWxsZXQuZGVwb3NpdEJhbGFuY2UudG9GaXhlZCgyKX1gLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgYWRkV2FsbGV0VHJhbnNhY3Rpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vd2FsbGV0XCIpXG5cbiAgbGV0IHRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBgQWRkaXRpb25hbCB3b3JrZXJzIGZvciBqb2I6ICR7am9iLnRpdGxlfSAoKyR7d29ya2VyRGlmZmVyZW5jZX0gd29ya2VycylgXG4gIGlmIChhZGRpdGlvbmFsU2NyZWVuc2hvdENvc3QgPiAwKSB7XG4gICAgdHJhbnNhY3Rpb25EZXNjcmlwdGlvbiArPSBgICsgJCR7YWRkaXRpb25hbFNjcmVlbnNob3RDb3N0LnRvRml4ZWQoMil9IHNjcmVlbnNob3QgZmVlYFxuICB9XG4gIHRyYW5zYWN0aW9uRGVzY3JpcHRpb24gKz0gYCArICQke3BsYXRmb3JtRmVlLnRvRml4ZWQoMil9IHBsYXRmb3JtIGZlZSlgXG5cbiAgLy8gRGVkdWN0IGZyb20gd2FsbGV0XG4gIGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKHtcbiAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICB0eXBlOiBcInBheW1lbnRcIixcbiAgICBhbW91bnQ6IC10b3RhbEFkZGl0aW9uYWxDb3N0LFxuICAgIGRlc2NyaXB0aW9uOiB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uLFxuICAgIHJlZmVyZW5jZUlkOiBqb2JJZCxcbiAgICByZWZlcmVuY2VUeXBlOiBcIndvcmtlcl91cGRhdGVcIixcbiAgICBiYWxhbmNlVHlwZTogXCJkZXBvc2l0XCIsXG4gIH0pXG5cbiAgY29uc3QgbmV3VG90YWxCYXNlQ29zdCA9IG5ld1dvcmtlckNvdW50ICogY29zdFBlcldvcmtlclxuICBsZXQgbmV3VG90YWxTY3JlZW5zaG90Q29zdCA9IDBcblxuICBpZiAoam9iLnJlcXVpcmVTY3JlZW5zaG90cyA+IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBjYWxjdWxhdGVTY3JlZW5zaG90Q29zdHMgfSA9IGF3YWl0IGltcG9ydChcIi4vc2NyZWVuc2hvdC1wcmljaW5nXCIpXG4gICAgICBuZXdUb3RhbFNjcmVlbnNob3RDb3N0ID0gKGF3YWl0IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyhqb2IucmVxdWlyZVNjcmVlbnNob3RzLCBuZXdUb3RhbEJhc2VDb3N0KSlcbiAgICAgICAgLnRvdGFsU2NyZWVuc2hvdENvc3RcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJyb3IgcmVjYWxjdWxhdGluZyB0b3RhbCBzY3JlZW5zaG90IGNvc3RzOlwiLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdTdWJ0b3RhbCA9IG5ld1RvdGFsQmFzZUNvc3QgKyBuZXdUb3RhbFNjcmVlbnNob3RDb3N0XG4gIGNvbnN0IG5ld1BsYXRmb3JtRmVlID0gbmV3U3VidG90YWwgKiBwbGF0Zm9ybUZlZVJhdGVcbiAgY29uc3QgbmV3VG90YWxDb3N0ID0gbmV3U3VidG90YWwgKyBuZXdQbGF0Zm9ybUZlZVxuXG4gIGpvYnNbam9iSW5kZXhdID0ge1xuICAgIC4uLmpvYixcbiAgICB3b3JrZXJzTmVlZGVkOiBuZXdXb3JrZXJDb3VudCxcbiAgICBlc3RpbWF0ZWRUb3RhbENvc3Q6IG5ld1RvdGFsQ29zdCxcbiAgfVxuXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEpPQlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpvYnMpKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogVXBkYXRlZCBqb2Igc2F2ZWQgdG8gbG9jYWxTdG9yYWdlIHdpdGgga2V5OlwiLCBKT0JTX1NUT1JBR0VfS0VZKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgVVBEQVRFLVdPUktFUlM6IFdvcmtlciBjb3VudCB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogTmV3IHRvdGFsIGNvc3Q6XCIsIG5ld1RvdGFsQ29zdC50b0ZpeGVkKDIpKVxuXG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogdHJ1ZSxcbiAgICBtZXNzYWdlOiBgV29ya2VyIGNvdW50IHVwZGF0ZWQgdG8gJHtuZXdXb3JrZXJDb3VudH0uIEFkZGl0aW9uYWwgY29zdDogJCR7dG90YWxBZGRpdGlvbmFsQ29zdC50b0ZpeGVkKDIpfWAsXG4gICAgYWRkaXRpb25hbENvc3Q6IHRvdGFsQWRkaXRpb25hbENvc3QsXG4gIH1cbn1cblxuZXhwb3J0IHsgZ2V0U3RvcmVkSm9icyB9XG4iXSwibmFtZXMiOlsiSk9CU19TVE9SQUdFX0tFWSIsIkFQUExJQ0FUSU9OU19TVE9SQUdFX0tFWSIsIldPUktfUFJPT0ZTX1NUT1JBR0VfS0VZIiwiSk9CX1JFVklFV1NfU1RPUkFHRV9LRVkiLCJKT0JfU1RBVFVTX0hJU1RPUllfU1RPUkFHRV9LRVkiLCJnZXRTdG9yZWRKb2JzIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImpvYnMiLCJKU09OIiwicGFyc2UiLCJzYXZlSm9icyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJnZXRTdG9yZWRBcHBsaWNhdGlvbnMiLCJzYXZlQXBwbGljYXRpb25zIiwiYXBwbGljYXRpb25zIiwiZ2V0U3RvcmVkV29ya1Byb29mcyIsInNhdmVXb3JrUHJvb2ZzIiwid29ya1Byb29mcyIsImdldFN0b3JlZEpvYlJldmlld3MiLCJzYXZlSm9iUmV2aWV3cyIsInJldmlld3MiLCJnZXRTdG9yZWRKb2JTdGF0dXNIaXN0b3J5Iiwic2F2ZUpvYlN0YXR1c0hpc3RvcnkiLCJoaXN0b3J5IiwicmVjb3JkU3RhdHVzQ2hhbmdlIiwiam9iSWQiLCJvbGRTdGF0dXMiLCJuZXdTdGF0dXMiLCJ1c2VySWQiLCJub3RlcyIsIm1ldGFkYXRhIiwic3RhdHVzRW50cnkiLCJpZCIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJjcmVhdGVkQXQiLCJ0b0lTT1N0cmluZyIsInB1c2giLCJsb2ciLCJnZXRTdWJjYXRlZ29yeUJ5SWQiLCJnZXRDYXRlZ29yeUJ5SWQiLCJnZXRQbGF0Zm9ybUZlZVNldHRpbmdzIiwiY2FsY3VsYXRlUGxhdGZvcm1GZWUiLCJsb2NhbFJlc2VydmF0aW9uU3RvcmFnZSIsInBvcHVsYXRlSm9iQ2F0ZWdvcnlEYXRhIiwiam9iIiwicG9wdWxhdGVkSm9iIiwidGl0bGUiLCJjYXRlZ29yeUlkIiwic3ViY2F0ZWdvcnlJZCIsImNhdGVnb3J5IiwidGh1bWJuYWlsIiwiZnVsbENhdGVnb3J5IiwibmFtZSIsInNsdWciLCJjYXRlZ29yeVRodW1ibmFpbCIsInN1YmNhdGVnb3J5Iiwic3ViY2F0ZWdvcnlUaHVtYm5haWwiLCJnZXRKb2JzIiwiZmlsdGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImZpbHRlcmVkSm9icyIsImZpbHRlciIsInN0YXR1cyIsInNlYXJjaCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJkZXNjcmlwdGlvbiIsInNraWxsc1JlcXVpcmVkIiwic29tZSIsInNraWxsIiwicmVtb3RlIiwidW5kZWZpbmVkIiwiaXNSZW1vdGUiLCJidWRnZXQiLCJidWRnZXRNYXgiLCJtaW4iLCJidWRnZXRNaW4iLCJtYXgiLCJsb2NhdGlvbiIsInNvcnRlZEpvYnMiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwicG9wdWxhdGVkSm9icyIsImFsbCIsIm1hcCIsImdldEpvYkJ5SWQiLCJmaW5kIiwidmlld3NDb3VudCIsImpvYkluZGV4IiwiZmluZEluZGV4IiwiaiIsImdldEFsbFVzZXJzIiwidXNlcnMiLCJwb3N0ZXJVc2VyIiwidSIsInBvc3RlciIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwidXNlcm5hbWUiLCJhdmF0YXIiLCJyYXRpbmciLCJ0b3RhbFJldmlld3MiLCJnZXRKb2JBcHBsaWNhdGlvbnMiLCJhcHAiLCJzdWJtaXRKb2JBcHBsaWNhdGlvbiIsImRhdGEiLCJFcnJvciIsImNvdmVyTGV0dGVyIiwidHJpbSIsInByb3Bvc2VkQnVkZ2V0IiwiZXhpc3RpbmdBcHBsaWNhdGlvbnMiLCJoYXNBcHBsaWVkIiwiYXBwbGljYW50SWQiLCJ1c2VyIiwibmV3QXBwbGljYXRpb24iLCJlc3RpbWF0ZWREdXJhdGlvbiIsInBvcnRmb2xpb0xpbmtzIiwiYXBwbGljYW50Iiwic2tpbGxzIiwiYXBwbGljYXRpb25zQ291bnQiLCJjcmVhdGVOb3RpZmljYXRpb24iLCJ0eXBlIiwiYWN0aW9uVXJsIiwic3VibWl0Sm9iRm9yQXBwcm92YWwiLCJqb2JEYXRhIiwiY2hlY2tBdXRvSm9iQXBwcm92YWwiLCJhdXRvQXBwcm92YWxTZXR0aW5nIiwic2V0dGluZyIsInNob3VsZEF1dG9BcHByb3ZlIiwiam9iU3RhdHVzIiwibmV3Sm9iIiwicmVxdWlyZW1lbnRzIiwiaW5zdHJ1Y3Rpb25zIiwiZGVhZGxpbmUiLCJzcGxpdCIsInByaW9yaXR5Iiwid29ya2Vyc05lZWRlZCIsImR1cmF0aW9uIiwiZHVyYXRpb25UeXBlIiwidGFncyIsImF0dGFjaG1lbnRzIiwicmVxdWlyZVNjcmVlbnNob3RzIiwic2NyZWVuc2hvdENvc3QiLCJlc3RpbWF0ZWRBcHByb3ZhbERheXMiLCJyZXF1aXJlZFByb29mIiwic3VibWl0dGVkQXQiLCJhcHByb3ZlZEF0IiwiYXBwcm92ZWRCeSIsImFwcHJvdmFsUmVhc29uIiwidXBkYXRlZEF0IiwiYXBwcm92ZUpvYiIsImFkbWluSWQiLCJyZWFzb24iLCJ1cGRhdGVkSm9iIiwidXBkYXRlSm9iU3RhdHVzIiwicmV2aWV3SWQiLCJkZWNpc2lvbiIsImZlZWRiYWNrIiwicmVqZWN0Sm9iIiwic3VzcGVuZEpvYiIsImdldFBlbmRpbmdKb2JzIiwiZ2V0QXBwcm92ZWRKb2JzIiwiZ2V0QWxsSm9icyIsImdldEFsbFVzZXJKb2JzIiwidXBkYXRlSm9iIiwidXBkYXRlcyIsImNhbmNlbEpvYiIsIndwIiwic3VibWl0dGVkV29ya0NvdW50IiwibGVuZ3RoIiwicmVtYWluaW5nU2xvdHMiLCJqb2JDb3N0UGVyV29ya2VyIiwicGxhdGZvcm1GZWVQZXJXb3JrZXIiLCJ0b3RhbENvc3RQZXJXb3JrZXIiLCJyZWZ1bmRBbW91bnQiLCJhZGRXYWxsZXRUcmFuc2FjdGlvbiIsImFtb3VudCIsImZvcm1hdHRlZEpvYklkIiwicmVmZXJlbmNlSWQiLCJyZWZlcmVuY2VUeXBlIiwiYmFsYW5jZVR5cGUiLCJtZXNzYWdlIiwiY2FuY2VsbGF0aW9uRGV0YWlscyIsImNhbmNlbGxlZEF0IiwiY2FuUmV2aWV3U3VibWlzc2lvbnMiLCJ1c2VyQWN0aW9uIiwicGF1c2VKb2IiLCJyZWFjdGl2YXRlSm9iIiwiZ2V0VXNlckFwcGxpY2F0aW9ucyIsInVzZXJBcHBsaWNhdGlvbnMiLCJhcHBsaWVkQXQiLCJzdWJtaXRXb3JrUHJvb2YiLCJ3b3JrZXJJZCIsIndvcmtlclVzZXIiLCJhcHByb3ZhbFR5cGUiLCJpc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQiLCJhcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uSWQiLCJwYXltZW50QW1vdW50Iiwic2hvdWxkUHJvY2Vzc0luc3RhbnRQYXltZW50IiwibmV3UHJvb2YiLCJlbXBsb3llcklkIiwic3VibWlzc2lvblRleHQiLCJwcm9vZkZpbGVzIiwicHJvb2ZMaW5rcyIsInNjcmVlbnNob3RzIiwic3VibWlzc2lvbk51bWJlciIsIndvcmtlciIsImVtcGxveWVyIiwicGxhdGZvcm1GZWVTZXR0aW5ncyIsInBsYXRmb3JtRmVlUmF0ZSIsInBsYXRmb3JtRmVlIiwiZmVlQ2FsY3VsYXRpb24iLCJmZWVQZXJjZW50YWdlIiwicm91bmQiLCJ3b3JrZXJBbW91bnQiLCJwYXltZW50UHJvY2Vzc2VkQXQiLCJ0b0ZpeGVkIiwicGF5bWVudEVycm9yIiwibWFudWFsQXBwcm92YWxEYXlzIiwiZ2V0V29ya1Byb29mc0J5Sm9iIiwicHJvb2YiLCJnZXRXb3JrUHJvb2ZzQnlXb3JrZXIiLCJnZXRXb3JrUHJvb2ZzIiwicmV2aWV3V29ya1Byb29mIiwicHJvb2ZJZCIsInJldmlld0RhdGEiLCJwcm9vZkluZGV4IiwicmV2aWV3IiwicmV2aWV3ZXJJZCIsInJldmlzaW9uTm90ZXMiLCJyZXZpZXdlZEF0IiwiYXBwSW5kZXgiLCJnZXRKb2JBcHBsaWNhdGlvbkJ5SWQiLCJjb21wbGV0ZWRBdCIsInN0YXR1c0hpc3RvcnkiLCJ0b3RhbFdvcmtlcnNDb21wbGV0ZWQiLCJhY2NlcHRlZFdvcmtlcnMiLCJKT0JfU1RBVFVTIiwiUEVORElORyIsIkFQUFJPVkVEIiwiUkVKRUNURUQiLCJTVVNQRU5ERUQiLCJPUEVOIiwiSU5fUFJPR1JFU1MiLCJDT01QTEVURUQiLCJDQU5DRUxMRUQiLCJnZXRKb2JTdGF0dXNDb2xvciIsImdldEpvYlN0YXR1c0xhYmVsIiwiY2FuQXBwbHlUb0pvYiIsImlzSm9iVmlzaWJsZSIsInVzZXJUeXBlIiwiZ2V0QXZhaWxhYmxlSm9icyIsImN1cnJlbnRVc2VySWQiLCJpc1ZhbGlkU3RhdHVzIiwibWF4V29ya2VycyIsImN1cnJlbnRBcHBsaWNhdGlvbnMiLCJyZXNlcnZhdGlvbkluZm8iLCJpc0pvYlJlc2VydmVkIiwiaXNSZXNlcnZlZCIsImdldEpvYnNGb3JEYXNoYm9hcmQiLCJnZXRKb2JTdGF0dXNIaXN0b3J5IiwiZW50cnkiLCJnZXRBbGxKb2JTdGF0dXNIaXN0b3J5IiwiYWNjZXB0Sm9iQXBwbGljYXRpb24iLCJhcHBsaWNhdGlvbkluZGV4IiwidXBkYXRlZEFwcGxpY2F0aW9uIiwiYWNjZXB0ZWRBdCIsImFzc2lnbmVkV29ya2VySWQiLCJmcm9tVXNlcklkIiwicmVqZWN0Sm9iQXBwbGljYXRpb24iLCJyZWplY3RlZEF0IiwicmVqZWN0aW9uUmVhc29uIiwiZ2V0VXNlckpvYnMiLCJ1c2VySm9icyIsImpvYnNXaXRoQ291bnRzIiwiYXBwbHlUb0pvYiIsImV4aXN0aW5nQXBwbGljYXRpb24iLCJyZXN1Ym1pc3Npb25Db3VudCIsImFjY2VwdGVkQXBwbGljYXRpb25zIiwiY3JlYXRlSm9iIiwiZW5hYmxlQ291bnRyeVJlc3RyaWN0aW9ucyIsInJlc3RyaWN0aW9uVHlwZSIsImFsbG93ZWRDb3VudHJpZXMiLCJyZXN0cmljdGVkQ291bnRyaWVzIiwiaXNJbnN0YW50QXBwcm92YWwiLCJlbmFibGVkIiwiZ2V0RGVmYXVsdE1hbnVhbEFwcHJvdmFsRGF5cyIsImRlZmF1bHREYXlzIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJjYW5Vc2VJbnN0YW50QXBwcm92YWwiLCJleGlzdGluZ0pvYnMiLCJuZXh0Sm9iTnVtYmVyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJmaW5hbE1hbnVhbEFwcHJvdmFsRGF5cyIsImJ1ZGdldFBlcldvcmtlciIsImJhc2VKb2JDb3N0IiwiY2FsY3VsYXRlU2NyZWVuc2hvdENvc3RzIiwic2NyZWVuc2hvdENhbGN1bGF0aW9uIiwidG90YWxTY3JlZW5zaG90Q29zdCIsInN1YnRvdGFsIiwidG90YWxXaXRoRmVlcyIsImdldFdhbGxldCIsIndhbGxldCIsImRlcG9zaXRCYWxhbmNlIiwidHJhbnNhY3Rpb25EZXNjcmlwdGlvbiIsImpvYk51bWJlciIsImVzdGltYXRlZFRvdGFsQ29zdCIsImRlcG9zaXREZWR1Y3RlZCIsInRvZ2dsZUpvYk9uIiwiaW5zdGFudFRvZ2dsZSIsInRvZ2dsZUpvYk9mZiIsInVwZGF0ZUpvYldvcmtlcnMiLCJuZXdXb3JrZXJDb3VudCIsInN1Y2Nlc3MiLCJjdXJyZW50V29ya2VyQ291bnQiLCJ3b3JrZXJEaWZmZXJlbmNlIiwiY29zdFBlcldvcmtlciIsImFkZGl0aW9uYWxCYXNlQ29zdCIsImFkZGl0aW9uYWxTY3JlZW5zaG90Q29zdCIsIm5ld1RvdGFsQmFzZUNvc3QiLCJjdXJyZW50VG90YWxCYXNlQ29zdCIsImN1cnJlbnRTY3JlZW5zaG90Q29zdCIsIm5ld1NjcmVlbnNob3RDb3N0IiwidG90YWxBZGRpdGlvbmFsQ29zdCIsIm5ld1RvdGFsU2NyZWVuc2hvdENvc3QiLCJuZXdTdWJ0b3RhbCIsIm5ld1BsYXRmb3JtRmVlIiwibmV3VG90YWxDb3N0IiwiYWRkaXRpb25hbENvc3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/jobs.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/local-reservation-storage.ts":
/*!******************************************!*\
  !*** ./lib/local-reservation-storage.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localReservationStorage: () => (/* binding */ localReservationStorage)\n/* harmony export */ });\nclass LocalReservationStorage {\n    // Get all reservations from localStorage\n    getReservations() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(this.RESERVATIONS_KEY);\n            return stored ? JSON.parse(stored) : [];\n        } catch (error) {\n            console.error(\"Error loading reservations from localStorage:\", error);\n            return [];\n        }\n    }\n    // Save reservations to localStorage\n    saveReservations(reservations) {\n        if (false) {}\n        try {\n            localStorage.setItem(this.RESERVATIONS_KEY, JSON.stringify(reservations));\n            this.dispatchStorageEvent(this.RESERVATIONS_KEY, reservations);\n        } catch (error) {\n            console.error(\"Error saving reservations to localStorage:\", error);\n        }\n    }\n    // Get reservation settings\n    getSettings() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(this.SETTINGS_KEY);\n            return stored ? JSON.parse(stored) : this.getDefaultSettings();\n        } catch (error) {\n            console.error(\"Error loading settings from localStorage:\", error);\n            return this.getDefaultSettings();\n        }\n    }\n    // Save reservation settings\n    saveSettings(settings) {\n        if (false) {}\n        try {\n            localStorage.setItem(this.SETTINGS_KEY, JSON.stringify(settings));\n        } catch (error) {\n            console.error(\"Error saving settings to localStorage:\", error);\n        }\n    }\n    // Get job reservation status (which jobs are reserved)\n    getJobReservations() {\n        if (false) {}\n        try {\n            const stored = localStorage.getItem(this.JOB_RESERVATIONS_KEY);\n            return stored ? JSON.parse(stored) : {};\n        } catch (error) {\n            console.error(\"Error loading job reservations from localStorage:\", error);\n            return {};\n        }\n    }\n    // Save job reservation status\n    saveJobReservations(jobReservations) {\n        if (false) {}\n        try {\n            localStorage.setItem(this.JOB_RESERVATIONS_KEY, JSON.stringify(jobReservations));\n            this.dispatchStorageEvent(this.JOB_RESERVATIONS_KEY, jobReservations);\n        } catch (error) {\n            console.error(\"Error saving job reservations to localStorage:\", error);\n        }\n    }\n    // Create a new reservation\n    createReservation(jobId, userId, reservationMinutes) {\n        const now = new Date();\n        const expiresAt = new Date(now.getTime() + reservationMinutes * 60 * 1000);\n        const reservation = {\n            id: this.generateId(),\n            jobId,\n            userId,\n            reservedAt: now.toISOString(),\n            expiresAt: expiresAt.toISOString(),\n            status: \"active\",\n            createdAt: now.toISOString(),\n            updatedAt: now.toISOString()\n        };\n        // Add to reservations list\n        const reservations = this.getReservations();\n        reservations.push(reservation);\n        this.saveReservations(reservations);\n        // Update job reservations mapping\n        const jobReservations = this.getJobReservations();\n        jobReservations[jobId] = {\n            userId,\n            expiresAt: expiresAt.toISOString()\n        };\n        this.saveJobReservations(jobReservations);\n        return reservation;\n    }\n    // Cancel a reservation\n    cancelReservation(reservationId) {\n        const reservations = this.getReservations();\n        const reservationIndex = reservations.findIndex((r)=>r.id === reservationId);\n        if (reservationIndex === -1) return false;\n        const reservation = reservations[reservationIndex];\n        reservation.status = \"cancelled\";\n        reservation.updatedAt = new Date().toISOString();\n        this.saveReservations(reservations);\n        // Remove from job reservations\n        const jobReservations = this.getJobReservations();\n        delete jobReservations[reservation.jobId];\n        this.saveJobReservations(jobReservations);\n        return true;\n    }\n    // Check and expire old reservations\n    expireOldReservations() {\n        const now = new Date();\n        const reservations = this.getReservations();\n        const jobReservations = this.getJobReservations();\n        const expiredReservations = [];\n        let hasChanges = false;\n        reservations.forEach((reservation)=>{\n            if (reservation.status === \"active\" && new Date(reservation.expiresAt) < now) {\n                reservation.status = \"expired\";\n                reservation.updatedAt = now.toISOString();\n                expiredReservations.push(reservation);\n                // Remove from job reservations\n                delete jobReservations[reservation.jobId];\n                hasChanges = true;\n            }\n        });\n        if (hasChanges) {\n            this.saveReservations(reservations);\n            this.saveJobReservations(jobReservations);\n        }\n        return expiredReservations;\n    }\n    // Get user's active reservations\n    getUserActiveReservations(userId) {\n        const reservations = this.getReservations();\n        return reservations.filter((r)=>r.userId === userId && r.status === \"active\");\n    }\n    // Check if job is reserved\n    isJobReserved(jobId) {\n        const jobReservations = this.getJobReservations();\n        const reservation = jobReservations[jobId];\n        if (!reservation) {\n            return {\n                isReserved: false\n            };\n        }\n        // Check if expired\n        if (new Date(reservation.expiresAt) < new Date()) {\n            // Clean up expired reservation\n            delete jobReservations[jobId];\n            this.saveJobReservations(jobReservations);\n            return {\n                isReserved: false\n            };\n        }\n        return {\n            isReserved: true,\n            userId: reservation.userId,\n            expiresAt: reservation.expiresAt\n        };\n    }\n    // Get default settings\n    getDefaultSettings() {\n        return {\n            id: \"default\",\n            isEnabled: true,\n            defaultReservationMinutes: 60,\n            maxReservationMinutes: 1440,\n            maxConcurrentReservations: 5,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n    }\n    // Generate a simple ID\n    generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    // Clear all data (for testing/reset)\n    clearAll() {\n        if (false) {}\n        localStorage.removeItem(this.RESERVATIONS_KEY);\n        localStorage.removeItem(this.SETTINGS_KEY);\n        localStorage.removeItem(this.JOB_RESERVATIONS_KEY);\n    }\n    dispatchStorageEvent(key, data) {\n        if (true) {\n            window.dispatchEvent(new CustomEvent(\"reservationStorageChange\", {\n                detail: {\n                    key,\n                    data\n                }\n            }));\n        }\n    }\n    constructor(){\n        this.RESERVATIONS_KEY = \"microjob_reservations\";\n        this.SETTINGS_KEY = \"microjob_reservation_settings\";\n        this.JOB_RESERVATIONS_KEY = \"microjob_job_reservations\";\n    }\n}\n// Export singleton instance\nconst localReservationStorage = new LocalReservationStorage();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9sb2NhbC1yZXNlcnZhdGlvbi1zdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFxQkEsTUFBTUE7SUFLSix5Q0FBeUM7SUFDekNDLGtCQUFzQztRQUNwQyxJQUFJLEtBQTZCLEVBQUUsRUFBUztRQUU1QyxJQUFJO1lBQ0YsTUFBTUMsU0FBU0MsYUFBYUMsT0FBTyxDQUFDLElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ3pELE9BQU9ILFNBQVNJLEtBQUtDLEtBQUssQ0FBQ0wsVUFBVSxFQUFFO1FBQ3pDLEVBQUUsT0FBT00sT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsaURBQWlEQTtZQUMvRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsb0NBQW9DO0lBQ3BDRSxpQkFBaUJDLFlBQWdDLEVBQVE7UUFDdkQsSUFBSSxLQUE2QixFQUFFO1FBRW5DLElBQUk7WUFDRlIsYUFBYVMsT0FBTyxDQUFDLElBQUksQ0FBQ1AsZ0JBQWdCLEVBQUVDLEtBQUtPLFNBQVMsQ0FBQ0Y7WUFDM0QsSUFBSSxDQUFDRyxvQkFBb0IsQ0FBQyxJQUFJLENBQUNULGdCQUFnQixFQUFFTTtRQUNuRCxFQUFFLE9BQU9ILE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhDQUE4Q0E7UUFDOUQ7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQk8sY0FBd0M7UUFDdEMsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsSUFBSTtZQUNGLE1BQU1iLFNBQVNDLGFBQWFDLE9BQU8sQ0FBQyxJQUFJLENBQUNhLFlBQVk7WUFDckQsT0FBT2YsU0FBU0ksS0FBS0MsS0FBSyxDQUFDTCxVQUFVLElBQUksQ0FBQ2Msa0JBQWtCO1FBQzlELEVBQUUsT0FBT1IsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsNkNBQTZDQTtZQUMzRCxPQUFPLElBQUksQ0FBQ1Esa0JBQWtCO1FBQ2hDO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUJFLGFBQWFDLFFBQWtDLEVBQVE7UUFDckQsSUFB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WTtZQUNaM0IsUUFBUU0sWUFBWU4sTUFBTTtZQUMxQkksV0FBV0UsWUFBWUYsU0FBUztRQUNsQztJQUNGO0lBRUEsdUJBQXVCO0lBQ2ZkLHFCQUErQztRQUNyRCxPQUFPO1lBQ0xpQixJQUFJO1lBQ0pxQixXQUFXO1lBQ1hDLDJCQUEyQjtZQUMzQkMsdUJBQXVCO1lBQ3ZCQywyQkFBMkI7WUFDM0JuQixXQUFXLElBQUlULE9BQU9PLFdBQVc7WUFDakNHLFdBQVcsSUFBSVYsT0FBT08sV0FBVztRQUNuQztJQUNGO0lBRUEsdUJBQXVCO0lBQ2ZGLGFBQXFCO1FBQzNCLE9BQU9MLEtBQUtELEdBQUcsR0FBRzhCLFFBQVEsQ0FBQyxNQUFNQyxLQUFLQyxNQUFNLEdBQUdGLFFBQVEsQ0FBQyxJQUFJRyxNQUFNLENBQUM7SUFDckU7SUFFQSxxQ0FBcUM7SUFDckNDLFdBQWlCO1FBQ2YsSUFBSSxLQUE2QixFQUFFO1FBRW5DM0QsYUFBYTRELFVBQVUsQ0FBQyxJQUFJLENBQUMxRCxnQkFBZ0I7UUFDN0NGLGFBQWE0RCxVQUFVLENBQUMsSUFBSSxDQUFDOUMsWUFBWTtRQUN6Q2QsYUFBYTRELFVBQVUsQ0FBQyxJQUFJLENBQUMxQyxvQkFBb0I7SUFDbkQ7SUFFUVAscUJBQXFCa0QsR0FBVyxFQUFFQyxJQUFTLEVBQUU7UUFDbkQsSUFBSSxJQUE2QixFQUFFO1lBQ2pDQyxPQUFPQyxhQUFhLENBQ2xCLElBQUlDLFlBQVksNEJBQTRCO2dCQUMxQ0MsUUFBUTtvQkFBRUw7b0JBQUtDO2dCQUFLO1lBQ3RCO1FBRUo7SUFDRjs7YUFuT2lCNUQsbUJBQW1CO2FBQ25CWSxlQUFlO2FBQ2ZJLHVCQUF1Qjs7QUFrTzFDO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1pRCwwQkFBMEIsSUFBSXRFLDBCQUF5QiIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9saWIvbG9jYWwtcmVzZXJ2YXRpb24tc3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIExvY2FsUmVzZXJ2YXRpb24ge1xuICBpZDogc3RyaW5nXG4gIGpvYklkOiBzdHJpbmdcbiAgdXNlcklkOiBzdHJpbmdcbiAgcmVzZXJ2ZWRBdDogc3RyaW5nXG4gIGV4cGlyZXNBdDogc3RyaW5nXG4gIHN0YXR1czogXCJhY3RpdmVcIiB8IFwiZXhwaXJlZFwiIHwgXCJjb21wbGV0ZWRcIiB8IFwiY2FuY2VsbGVkXCJcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgdXBkYXRlZEF0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbFJlc2VydmF0aW9uU2V0dGluZ3Mge1xuICBpZDogc3RyaW5nXG4gIGlzRW5hYmxlZDogYm9vbGVhblxuICBkZWZhdWx0UmVzZXJ2YXRpb25NaW51dGVzOiBudW1iZXJcbiAgbWF4UmVzZXJ2YXRpb25NaW51dGVzOiBudW1iZXJcbiAgbWF4Q29uY3VycmVudFJlc2VydmF0aW9uczogbnVtYmVyXG4gIGNyZWF0ZWRBdDogc3RyaW5nXG4gIHVwZGF0ZWRBdDogc3RyaW5nXG59XG5cbmNsYXNzIExvY2FsUmVzZXJ2YXRpb25TdG9yYWdlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBSRVNFUlZBVElPTlNfS0VZID0gXCJtaWNyb2pvYl9yZXNlcnZhdGlvbnNcIlxuICBwcml2YXRlIHJlYWRvbmx5IFNFVFRJTkdTX0tFWSA9IFwibWljcm9qb2JfcmVzZXJ2YXRpb25fc2V0dGluZ3NcIlxuICBwcml2YXRlIHJlYWRvbmx5IEpPQl9SRVNFUlZBVElPTlNfS0VZID0gXCJtaWNyb2pvYl9qb2JfcmVzZXJ2YXRpb25zXCJcblxuICAvLyBHZXQgYWxsIHJlc2VydmF0aW9ucyBmcm9tIGxvY2FsU3RvcmFnZVxuICBnZXRSZXNlcnZhdGlvbnMoKTogTG9jYWxSZXNlcnZhdGlvbltdIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFtdXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5SRVNFUlZBVElPTlNfS0VZKVxuICAgICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHJlc2VydmF0aW9ucyBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvLyBTYXZlIHJlc2VydmF0aW9ucyB0byBsb2NhbFN0b3JhZ2VcbiAgc2F2ZVJlc2VydmF0aW9ucyhyZXNlcnZhdGlvbnM6IExvY2FsUmVzZXJ2YXRpb25bXSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlJFU0VSVkFUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KHJlc2VydmF0aW9ucykpXG4gICAgICB0aGlzLmRpc3BhdGNoU3RvcmFnZUV2ZW50KHRoaXMuUkVTRVJWQVRJT05TX0tFWSwgcmVzZXJ2YXRpb25zKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHJlc2VydmF0aW9ucyB0byBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCByZXNlcnZhdGlvbiBzZXR0aW5nc1xuICBnZXRTZXR0aW5ncygpOiBMb2NhbFJlc2VydmF0aW9uU2V0dGluZ3Mge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0U2V0dGluZ3MoKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNFVFRJTkdTX0tFWSlcbiAgICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcilcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgfVxuICB9XG5cbiAgLy8gU2F2ZSByZXNlcnZhdGlvbiBzZXR0aW5nc1xuICBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IExvY2FsUmVzZXJ2YXRpb25TZXR0aW5ncyk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLlNFVFRJTkdTX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGpvYiByZXNlcnZhdGlvbiBzdGF0dXMgKHdoaWNoIGpvYnMgYXJlIHJlc2VydmVkKVxuICBnZXRKb2JSZXNlcnZhdGlvbnMoKTogUmVjb3JkPHN0cmluZywgeyB1c2VySWQ6IHN0cmluZzsgZXhwaXJlc0F0OiBzdHJpbmcgfT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4ge31cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLkpPQl9SRVNFUlZBVElPTlNfS0VZKVxuICAgICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IHt9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGpvYiByZXNlcnZhdGlvbnMgZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICB9XG5cbiAgLy8gU2F2ZSBqb2IgcmVzZXJ2YXRpb24gc3RhdHVzXG4gIHNhdmVKb2JSZXNlcnZhdGlvbnMoam9iUmVzZXJ2YXRpb25zOiBSZWNvcmQ8c3RyaW5nLCB7IHVzZXJJZDogc3RyaW5nOyBleHBpcmVzQXQ6IHN0cmluZyB9Pik6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLkpPQl9SRVNFUlZBVElPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShqb2JSZXNlcnZhdGlvbnMpKVxuICAgICAgdGhpcy5kaXNwYXRjaFN0b3JhZ2VFdmVudCh0aGlzLkpPQl9SRVNFUlZBVElPTlNfS0VZLCBqb2JSZXNlcnZhdGlvbnMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgam9iIHJlc2VydmF0aW9ucyB0byBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyByZXNlcnZhdGlvblxuICBjcmVhdGVSZXNlcnZhdGlvbihqb2JJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZywgcmVzZXJ2YXRpb25NaW51dGVzOiBudW1iZXIpOiBMb2NhbFJlc2VydmF0aW9uIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIHJlc2VydmF0aW9uTWludXRlcyAqIDYwICogMTAwMClcblxuICAgIGNvbnN0IHJlc2VydmF0aW9uOiBMb2NhbFJlc2VydmF0aW9uID0ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgam9iSWQsXG4gICAgICB1c2VySWQsXG4gICAgICByZXNlcnZlZEF0OiBub3cudG9JU09TdHJpbmcoKSxcbiAgICAgIGV4cGlyZXNBdDogZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgICBzdGF0dXM6IFwiYWN0aXZlXCIsXG4gICAgICBjcmVhdGVkQXQ6IG5vdy50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBub3cudG9JU09TdHJpbmcoKSxcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gcmVzZXJ2YXRpb25zIGxpc3RcbiAgICBjb25zdCByZXNlcnZhdGlvbnMgPSB0aGlzLmdldFJlc2VydmF0aW9ucygpXG4gICAgcmVzZXJ2YXRpb25zLnB1c2gocmVzZXJ2YXRpb24pXG4gICAgdGhpcy5zYXZlUmVzZXJ2YXRpb25zKHJlc2VydmF0aW9ucylcblxuICAgIC8vIFVwZGF0ZSBqb2IgcmVzZXJ2YXRpb25zIG1hcHBpbmdcbiAgICBjb25zdCBqb2JSZXNlcnZhdGlvbnMgPSB0aGlzLmdldEpvYlJlc2VydmF0aW9ucygpXG4gICAgam9iUmVzZXJ2YXRpb25zW2pvYklkXSA9IHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIGV4cGlyZXNBdDogZXhwaXJlc0F0LnRvSVNPU3RyaW5nKCksXG4gICAgfVxuICAgIHRoaXMuc2F2ZUpvYlJlc2VydmF0aW9ucyhqb2JSZXNlcnZhdGlvbnMpXG5cbiAgICByZXR1cm4gcmVzZXJ2YXRpb25cbiAgfVxuXG4gIC8vIENhbmNlbCBhIHJlc2VydmF0aW9uXG4gIGNhbmNlbFJlc2VydmF0aW9uKHJlc2VydmF0aW9uSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0UmVzZXJ2YXRpb25zKClcbiAgICBjb25zdCByZXNlcnZhdGlvbkluZGV4ID0gcmVzZXJ2YXRpb25zLmZpbmRJbmRleCgocikgPT4gci5pZCA9PT0gcmVzZXJ2YXRpb25JZClcblxuICAgIGlmIChyZXNlcnZhdGlvbkluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCByZXNlcnZhdGlvbiA9IHJlc2VydmF0aW9uc1tyZXNlcnZhdGlvbkluZGV4XVxuICAgIHJlc2VydmF0aW9uLnN0YXR1cyA9IFwiY2FuY2VsbGVkXCJcbiAgICByZXNlcnZhdGlvbi51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblxuICAgIHRoaXMuc2F2ZVJlc2VydmF0aW9ucyhyZXNlcnZhdGlvbnMpXG5cbiAgICAvLyBSZW1vdmUgZnJvbSBqb2IgcmVzZXJ2YXRpb25zXG4gICAgY29uc3Qgam9iUmVzZXJ2YXRpb25zID0gdGhpcy5nZXRKb2JSZXNlcnZhdGlvbnMoKVxuICAgIGRlbGV0ZSBqb2JSZXNlcnZhdGlvbnNbcmVzZXJ2YXRpb24uam9iSWRdXG4gICAgdGhpcy5zYXZlSm9iUmVzZXJ2YXRpb25zKGpvYlJlc2VydmF0aW9ucylcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBDaGVjayBhbmQgZXhwaXJlIG9sZCByZXNlcnZhdGlvbnNcbiAgZXhwaXJlT2xkUmVzZXJ2YXRpb25zKCk6IExvY2FsUmVzZXJ2YXRpb25bXSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIGNvbnN0IHJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0UmVzZXJ2YXRpb25zKClcbiAgICBjb25zdCBqb2JSZXNlcnZhdGlvbnMgPSB0aGlzLmdldEpvYlJlc2VydmF0aW9ucygpXG4gICAgY29uc3QgZXhwaXJlZFJlc2VydmF0aW9uczogTG9jYWxSZXNlcnZhdGlvbltdID0gW11cblxuICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2VcblxuICAgIHJlc2VydmF0aW9ucy5mb3JFYWNoKChyZXNlcnZhdGlvbikgPT4ge1xuICAgICAgaWYgKHJlc2VydmF0aW9uLnN0YXR1cyA9PT0gXCJhY3RpdmVcIiAmJiBuZXcgRGF0ZShyZXNlcnZhdGlvbi5leHBpcmVzQXQpIDwgbm93KSB7XG4gICAgICAgIHJlc2VydmF0aW9uLnN0YXR1cyA9IFwiZXhwaXJlZFwiXG4gICAgICAgIHJlc2VydmF0aW9uLnVwZGF0ZWRBdCA9IG5vdy50b0lTT1N0cmluZygpXG4gICAgICAgIGV4cGlyZWRSZXNlcnZhdGlvbnMucHVzaChyZXNlcnZhdGlvbilcblxuICAgICAgICAvLyBSZW1vdmUgZnJvbSBqb2IgcmVzZXJ2YXRpb25zXG4gICAgICAgIGRlbGV0ZSBqb2JSZXNlcnZhdGlvbnNbcmVzZXJ2YXRpb24uam9iSWRdXG4gICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICB0aGlzLnNhdmVSZXNlcnZhdGlvbnMocmVzZXJ2YXRpb25zKVxuICAgICAgdGhpcy5zYXZlSm9iUmVzZXJ2YXRpb25zKGpvYlJlc2VydmF0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwaXJlZFJlc2VydmF0aW9uc1xuICB9XG5cbiAgLy8gR2V0IHVzZXIncyBhY3RpdmUgcmVzZXJ2YXRpb25zXG4gIGdldFVzZXJBY3RpdmVSZXNlcnZhdGlvbnModXNlcklkOiBzdHJpbmcpOiBMb2NhbFJlc2VydmF0aW9uW10ge1xuICAgIGNvbnN0IHJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0UmVzZXJ2YXRpb25zKClcbiAgICByZXR1cm4gcmVzZXJ2YXRpb25zLmZpbHRlcigocikgPT4gci51c2VySWQgPT09IHVzZXJJZCAmJiByLnN0YXR1cyA9PT0gXCJhY3RpdmVcIilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGpvYiBpcyByZXNlcnZlZFxuICBpc0pvYlJlc2VydmVkKGpvYklkOiBzdHJpbmcpOiB7IGlzUmVzZXJ2ZWQ6IGJvb2xlYW47IHVzZXJJZD86IHN0cmluZzsgZXhwaXJlc0F0Pzogc3RyaW5nIH0ge1xuICAgIGNvbnN0IGpvYlJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0Sm9iUmVzZXJ2YXRpb25zKClcbiAgICBjb25zdCByZXNlcnZhdGlvbiA9IGpvYlJlc2VydmF0aW9uc1tqb2JJZF1cblxuICAgIGlmICghcmVzZXJ2YXRpb24pIHtcbiAgICAgIHJldHVybiB7IGlzUmVzZXJ2ZWQ6IGZhbHNlIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBleHBpcmVkXG4gICAgaWYgKG5ldyBEYXRlKHJlc2VydmF0aW9uLmV4cGlyZXNBdCkgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAvLyBDbGVhbiB1cCBleHBpcmVkIHJlc2VydmF0aW9uXG4gICAgICBkZWxldGUgam9iUmVzZXJ2YXRpb25zW2pvYklkXVxuICAgICAgdGhpcy5zYXZlSm9iUmVzZXJ2YXRpb25zKGpvYlJlc2VydmF0aW9ucylcbiAgICAgIHJldHVybiB7IGlzUmVzZXJ2ZWQ6IGZhbHNlIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNSZXNlcnZlZDogdHJ1ZSxcbiAgICAgIHVzZXJJZDogcmVzZXJ2YXRpb24udXNlcklkLFxuICAgICAgZXhwaXJlc0F0OiByZXNlcnZhdGlvbi5leHBpcmVzQXQsXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGRlZmF1bHQgc2V0dGluZ3NcbiAgcHJpdmF0ZSBnZXREZWZhdWx0U2V0dGluZ3MoKTogTG9jYWxSZXNlcnZhdGlvblNldHRpbmdzIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IFwiZGVmYXVsdFwiLFxuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgZGVmYXVsdFJlc2VydmF0aW9uTWludXRlczogNjAsIC8vIDEgaG91ciBkZWZhdWx0XG4gICAgICBtYXhSZXNlcnZhdGlvbk1pbnV0ZXM6IDE0NDAsIC8vIDI0IGhvdXJzIG1heFxuICAgICAgbWF4Q29uY3VycmVudFJlc2VydmF0aW9uczogNSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgYSBzaW1wbGUgSURcbiAgcHJpdmF0ZSBnZW5lcmF0ZUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIERhdGUubm93KCkudG9TdHJpbmcoMzYpICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpXG4gIH1cblxuICAvLyBDbGVhciBhbGwgZGF0YSAoZm9yIHRlc3RpbmcvcmVzZXQpXG4gIGNsZWFyQWxsKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuUkVTRVJWQVRJT05TX0tFWSlcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLlNFVFRJTkdTX0tFWSlcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLkpPQl9SRVNFUlZBVElPTlNfS0VZKVxuICB9XG5cbiAgcHJpdmF0ZSBkaXNwYXRjaFN0b3JhZ2VFdmVudChrZXk6IHN0cmluZywgZGF0YTogYW55KSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJyZXNlcnZhdGlvblN0b3JhZ2VDaGFuZ2VcIiwge1xuICAgICAgICAgIGRldGFpbDogeyBrZXksIGRhdGEgfSxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBsb2NhbFJlc2VydmF0aW9uU3RvcmFnZSA9IG5ldyBMb2NhbFJlc2VydmF0aW9uU3RvcmFnZSgpXG4iXSwibmFtZXMiOlsiTG9jYWxSZXNlcnZhdGlvblN0b3JhZ2UiLCJnZXRSZXNlcnZhdGlvbnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiUkVTRVJWQVRJT05TX0tFWSIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsInNhdmVSZXNlcnZhdGlvbnMiLCJyZXNlcnZhdGlvbnMiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZGlzcGF0Y2hTdG9yYWdlRXZlbnQiLCJnZXRTZXR0aW5ncyIsImdldERlZmF1bHRTZXR0aW5ncyIsIlNFVFRJTkdTX0tFWSIsInNhdmVTZXR0aW5ncyIsInNldHRpbmdzIiwiZ2V0Sm9iUmVzZXJ2YXRpb25zIiwiSk9CX1JFU0VSVkFUSU9OU19LRVkiLCJzYXZlSm9iUmVzZXJ2YXRpb25zIiwiam9iUmVzZXJ2YXRpb25zIiwiY3JlYXRlUmVzZXJ2YXRpb24iLCJqb2JJZCIsInVzZXJJZCIsInJlc2VydmF0aW9uTWludXRlcyIsIm5vdyIsIkRhdGUiLCJleHBpcmVzQXQiLCJnZXRUaW1lIiwicmVzZXJ2YXRpb24iLCJpZCIsImdlbmVyYXRlSWQiLCJyZXNlcnZlZEF0IiwidG9JU09TdHJpbmciLCJzdGF0dXMiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJwdXNoIiwiY2FuY2VsUmVzZXJ2YXRpb24iLCJyZXNlcnZhdGlvbklkIiwicmVzZXJ2YXRpb25JbmRleCIsImZpbmRJbmRleCIsInIiLCJleHBpcmVPbGRSZXNlcnZhdGlvbnMiLCJleHBpcmVkUmVzZXJ2YXRpb25zIiwiaGFzQ2hhbmdlcyIsImZvckVhY2giLCJnZXRVc2VyQWN0aXZlUmVzZXJ2YXRpb25zIiwiZmlsdGVyIiwiaXNKb2JSZXNlcnZlZCIsImlzUmVzZXJ2ZWQiLCJpc0VuYWJsZWQiLCJkZWZhdWx0UmVzZXJ2YXRpb25NaW51dGVzIiwibWF4UmVzZXJ2YXRpb25NaW51dGVzIiwibWF4Q29uY3VycmVudFJlc2VydmF0aW9ucyIsInRvU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsImNsZWFyQWxsIiwicmVtb3ZlSXRlbSIsImtleSIsImRhdGEiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJsb2NhbFJlc2VydmF0aW9uU3RvcmFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/local-reservation-storage.ts\n"));

/***/ })

}]);