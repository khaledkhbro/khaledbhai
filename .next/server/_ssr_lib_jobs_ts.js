"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_jobs_ts";
exports.ids = ["_ssr_lib_jobs_ts"];
exports.modules = {

/***/ "(ssr)/./lib/auth.ts":
/*!*********************!*\
  !*** ./lib/auth.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activateUser: () => (/* binding */ activateUser),\n/* harmony export */   clearStoredUser: () => (/* binding */ clearStoredUser),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getNextUserId: () => (/* binding */ getNextUserId),\n/* harmony export */   getStoredUser: () => (/* binding */ getStoredUser),\n/* harmony export */   getUser: () => (/* binding */ getUser),\n/* harmony export */   initializeDefaultUsers: () => (/* binding */ initializeDefaultUsers),\n/* harmony export */   saveUserToDatabase: () => (/* binding */ saveUserToDatabase),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   signUp: () => (/* binding */ signUp),\n/* harmony export */   storeUser: () => (/* binding */ storeUser),\n/* harmony export */   suspendUserWithReason: () => (/* binding */ suspendUserWithReason),\n/* harmony export */   toggleUserSuspension: () => (/* binding */ toggleUserSuspension),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n// Authentication utilities and types\nfunction getAllUsers() {\n    if (true) return [];\n    const stored = localStorage.getItem(\"users_database\");\n    return stored ? JSON.parse(stored) : [];\n}\nfunction saveUserToDatabase(user) {\n    if (true) return;\n    const users = getAllUsers();\n    const existingIndex = users.findIndex((u)=>u.email === user.email);\n    if (existingIndex >= 0) {\n        users[existingIndex] = user;\n    } else {\n        users.push(user);\n    }\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n}\nfunction getNextUserId() {\n    const users = getAllUsers();\n    const maxId = users.reduce((max, user)=>{\n        const numId = Number.parseInt(user.id);\n        return isNaN(numId) ? max : Math.max(max, numId);\n    }, 0);\n    return String(maxId + 1).padStart(2, \"0\");\n}\nfunction initializeDefaultUsers() {\n    const users = getAllUsers();\n    if (users.length === 0) {\n        const defaultUsers = [\n            {\n                id: \"01\",\n                email: \"admin@marketplace.com\",\n                firstName: \"Admin\",\n                lastName: \"User\",\n                username: \"admin\",\n                userType: \"admin\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"02\",\n                email: \"worker1@marketplace.com\",\n                firstName: \"John\",\n                lastName: \"Worker\",\n                username: \"johnworker\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 0,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            },\n            {\n                id: \"03\",\n                email: \"employer1@marketplace.com\",\n                firstName: \"Jane\",\n                lastName: \"Employer\",\n                username: \"janeemployer\",\n                userType: \"user\",\n                isVerified: true,\n                deposit: 100,\n                earning: 0,\n                country: \"United States\",\n                createdAt: new Date().toISOString()\n            }\n        ];\n        defaultUsers.forEach((user)=>saveUserToDatabase(user));\n        console.log(\"[v0] âœ… Initialized default users:\", defaultUsers.map((u)=>`${u.firstName} ${u.lastName} (ID: ${u.id})`));\n    }\n}\n// Mock authentication functions (replace with real API calls when database is connected)\nasync function signIn(email, password) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.email === email);\n    if (!user) {\n        throw new Error(\"Invalid email or password\");\n    }\n    if (user.userType === \"suspended\") {\n        const reason = user.suspensionReason || \"No reason provided\";\n        throw new Error(`Your account has been suspended. Reason: ${reason}`);\n    }\n    if (email === \"admin@marketplace.com\" && password === \"admin123\") {\n        console.log(\"[v0] Admin login successful for:\", user.email);\n        return user;\n    }\n    if (password === \"password123\" || password.length >= 8) {\n        console.log(\"[v0] User login successful for:\", user.email);\n        return user;\n    }\n    throw new Error(\"Invalid email or password\");\n}\nasync function signUp(data) {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 1000));\n    if (!isValidEmail(data.email)) {\n        throw new Error(\"Please enter a valid email address\");\n    }\n    if (data.password.length < 8) {\n        throw new Error(\"Password must be at least 8 characters long\");\n    }\n    if (!isValidPassword(data.password)) {\n        throw new Error(\"Password must contain at least one uppercase letter, one lowercase letter, and one number\");\n    }\n    if (data.username.length < 3) {\n        throw new Error(\"Username must be at least 3 characters long\");\n    }\n    if (!/^[a-zA-Z0-9_]+$/.test(data.username)) {\n        throw new Error(\"Username can only contain letters, numbers, and underscores\");\n    }\n    const users = getAllUsers();\n    const existingUser = users.find((u)=>u.email === data.email || u.username === data.username);\n    if (existingUser) {\n        if (existingUser.email === data.email) {\n            throw new Error(\"An account with this email already exists\");\n        } else {\n            throw new Error(\"This username is already taken\");\n        }\n    }\n    const newUser = {\n        id: getNextUserId(),\n        email: data.email,\n        firstName: data.firstName,\n        lastName: data.lastName,\n        username: data.username,\n        userType: \"user\",\n        isVerified: false,\n        deposit: 0,\n        earning: 0,\n        country: \"United States\",\n        createdAt: new Date().toISOString()\n    };\n    saveUserToDatabase(newUser);\n    return newUser;\n}\nasync function signOut() {\n    // Simulate API call\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n}\nfunction getStoredUser() {\n    if (true) return null;\n    const stored = localStorage.getItem(\"user\");\n    return stored ? JSON.parse(stored) : null;\n}\nfunction storeUser(user) {\n    if (true) return;\n    localStorage.setItem(\"user\", JSON.stringify(user));\n}\nfunction clearStoredUser() {\n    if (true) return;\n    localStorage.removeItem(\"user\");\n}\nfunction isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\nfunction isValidPassword(password) {\n    // At least 8 characters, one uppercase, one lowercase, one number\n    const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\n    return passwordRegex.test(password);\n}\nfunction updateUser(userId, updates) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        ...updates\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction toggleUserSuspension(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const user = users[userIndex];\n    // Toggle between user and suspended status (using a custom field)\n    const updatedUser = {\n        ...user,\n        isSuspended: !user.isSuspended\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction suspendUserWithReason(userId, reason, suspendedBy) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"suspended\",\n        suspensionReason: reason,\n        suspendedAt: new Date().toISOString(),\n        suspendedBy: suspendedBy\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nfunction activateUser(userId) {\n    const users = getAllUsers();\n    const userIndex = users.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) {\n        throw new Error(\"User not found\");\n    }\n    const updatedUser = {\n        ...users[userIndex],\n        userType: \"user\",\n        suspensionReason: undefined,\n        suspendedAt: undefined,\n        suspendedBy: undefined\n    };\n    users[userIndex] = updatedUser;\n    localStorage.setItem(\"users_database\", JSON.stringify(users));\n    return updatedUser;\n}\nasync function getUser() {\n    // In a real implementation, this would validate JWT tokens or session cookies\n    // For now, we'll simulate getting the current user from localStorage on the client\n    // or return null on the server (since we don't have real session management)\n    if (true) {\n        // Server-side: In a real app, you'd validate session tokens here\n        // For demo purposes, return a mock admin user for API calls\n        return {\n            id: \"01\",\n            email: \"admin@marketplace.com\",\n            firstName: \"Admin\",\n            lastName: \"User\",\n            username: \"admin\",\n            userType: \"admin\",\n            isVerified: true,\n            deposit: 0,\n            earning: 0,\n            country: \"United States\",\n            createdAt: new Date().toISOString()\n        };\n    }\n    // Client-side: Get user from localStorage\n    return getStoredUser();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cHJvamVjdC9saWIvYXV0aC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBdXRoZW50aWNhdGlvbiB1dGlsaXRpZXMgYW5kIHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZmlyc3ROYW1lOiBzdHJpbmdcbiAgbGFzdE5hbWU6IHN0cmluZ1xuICB1c2VybmFtZTogc3RyaW5nXG4gIGF2YXRhcj86IHN0cmluZ1xuICB1c2VyVHlwZTogXCJ1c2VyXCIgfCBcImFkbWluXCIgfCBcInN1c3BlbmRlZFwiXG4gIGlzVmVyaWZpZWQ6IGJvb2xlYW5cbiAgZGVwb3NpdDogbnVtYmVyXG4gIGVhcm5pbmc6IG51bWJlclxuICBjb3VudHJ5OiBzdHJpbmdcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgaXNTdXNwZW5kZWQ/OiBib29sZWFuXG4gIHN1c3BlbnNpb25SZWFzb24/OiBzdHJpbmdcbiAgc3VzcGVuZGVkQXQ/OiBzdHJpbmdcbiAgc3VzcGVuZGVkQnk/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRoU3RhdGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbFxuICBpc0xvYWRpbmc6IGJvb2xlYW5cbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxVc2VycygpOiBVc2VyW10ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFtdXG5cbiAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiKVxuICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVVc2VyVG9EYXRhYmFzZSh1c2VyOiBVc2VyKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cblxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgZXhpc3RpbmdJbmRleCA9IHVzZXJzLmZpbmRJbmRleCgodSkgPT4gdS5lbWFpbCA9PT0gdXNlci5lbWFpbClcblxuICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgdXNlcnNbZXhpc3RpbmdJbmRleF0gPSB1c2VyXG4gIH0gZWxzZSB7XG4gICAgdXNlcnMucHVzaCh1c2VyKVxuICB9XG5cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0VXNlcklkKCk6IHN0cmluZyB7XG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCBtYXhJZCA9IHVzZXJzLnJlZHVjZSgobWF4LCB1c2VyKSA9PiB7XG4gICAgY29uc3QgbnVtSWQgPSBOdW1iZXIucGFyc2VJbnQodXNlci5pZClcbiAgICByZXR1cm4gaXNOYU4obnVtSWQpID8gbWF4IDogTWF0aC5tYXgobWF4LCBudW1JZClcbiAgfSwgMClcblxuICByZXR1cm4gU3RyaW5nKG1heElkICsgMSkucGFkU3RhcnQoMiwgXCIwXCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRGVmYXVsdFVzZXJzKCk6IHZvaWQge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcblxuICBpZiAodXNlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgZGVmYXVsdFVzZXJzOiBVc2VyW10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiBcIjAxXCIsXG4gICAgICAgIGVtYWlsOiBcImFkbWluQG1hcmtldHBsYWNlLmNvbVwiLFxuICAgICAgICBmaXJzdE5hbWU6IFwiQWRtaW5cIixcbiAgICAgICAgbGFzdE5hbWU6IFwiVXNlclwiLFxuICAgICAgICB1c2VybmFtZTogXCJhZG1pblwiLFxuICAgICAgICB1c2VyVHlwZTogXCJhZG1pblwiLFxuICAgICAgICBpc1ZlcmlmaWVkOiB0cnVlLFxuICAgICAgICBkZXBvc2l0OiAwLFxuICAgICAgICBlYXJuaW5nOiAwLFxuICAgICAgICBjb3VudHJ5OiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogXCIwMlwiLFxuICAgICAgICBlbWFpbDogXCJ3b3JrZXIxQG1hcmtldHBsYWNlLmNvbVwiLFxuICAgICAgICBmaXJzdE5hbWU6IFwiSm9oblwiLFxuICAgICAgICBsYXN0TmFtZTogXCJXb3JrZXJcIixcbiAgICAgICAgdXNlcm5hbWU6IFwiam9obndvcmtlclwiLFxuICAgICAgICB1c2VyVHlwZTogXCJ1c2VyXCIsXG4gICAgICAgIGlzVmVyaWZpZWQ6IHRydWUsXG4gICAgICAgIGRlcG9zaXQ6IDAsXG4gICAgICAgIGVhcm5pbmc6IDAsXG4gICAgICAgIGNvdW50cnk6IFwiVW5pdGVkIFN0YXRlc1wiLFxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiBcIjAzXCIsXG4gICAgICAgIGVtYWlsOiBcImVtcGxveWVyMUBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgICAgZmlyc3ROYW1lOiBcIkphbmVcIixcbiAgICAgICAgbGFzdE5hbWU6IFwiRW1wbG95ZXJcIixcbiAgICAgICAgdXNlcm5hbWU6IFwiamFuZWVtcGxveWVyXCIsXG4gICAgICAgIHVzZXJUeXBlOiBcInVzZXJcIixcbiAgICAgICAgaXNWZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgZGVwb3NpdDogMTAwLFxuICAgICAgICBlYXJuaW5nOiAwLFxuICAgICAgICBjb3VudHJ5OiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9LFxuICAgIF1cblxuICAgIGRlZmF1bHRVc2Vycy5mb3JFYWNoKCh1c2VyKSA9PiBzYXZlVXNlclRvRGF0YWJhc2UodXNlcikpXG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIlt2MF0g4pyFIEluaXRpYWxpemVkIGRlZmF1bHQgdXNlcnM6XCIsXG4gICAgICBkZWZhdWx0VXNlcnMubWFwKCh1KSA9PiBgJHt1LmZpcnN0TmFtZX0gJHt1Lmxhc3ROYW1lfSAoSUQ6ICR7dS5pZH0pYCksXG4gICAgKVxuICB9XG59XG5cbi8vIE1vY2sgYXV0aGVudGljYXRpb24gZnVuY3Rpb25zIChyZXBsYWNlIHdpdGggcmVhbCBBUEkgY2FsbHMgd2hlbiBkYXRhYmFzZSBpcyBjb25uZWN0ZWQpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbkluKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXI+IHtcbiAgLy8gU2ltdWxhdGUgQVBJIGNhbGxcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpXG5cbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXIgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmVtYWlsID09PSBlbWFpbClcblxuICBpZiAoIXVzZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkXCIpXG4gIH1cblxuICBpZiAodXNlci51c2VyVHlwZSA9PT0gXCJzdXNwZW5kZWRcIikge1xuICAgIGNvbnN0IHJlYXNvbiA9IHVzZXIuc3VzcGVuc2lvblJlYXNvbiB8fCBcIk5vIHJlYXNvbiBwcm92aWRlZFwiXG4gICAgdGhyb3cgbmV3IEVycm9yKGBZb3VyIGFjY291bnQgaGFzIGJlZW4gc3VzcGVuZGVkLiBSZWFzb246ICR7cmVhc29ufWApXG4gIH1cblxuICBpZiAoZW1haWwgPT09IFwiYWRtaW5AbWFya2V0cGxhY2UuY29tXCIgJiYgcGFzc3dvcmQgPT09IFwiYWRtaW4xMjNcIikge1xuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBBZG1pbiBsb2dpbiBzdWNjZXNzZnVsIGZvcjpcIiwgdXNlci5lbWFpbClcbiAgICByZXR1cm4gdXNlclxuICB9XG5cbiAgaWYgKHBhc3N3b3JkID09PSBcInBhc3N3b3JkMTIzXCIgfHwgcGFzc3dvcmQubGVuZ3RoID49IDgpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0gVXNlciBsb2dpbiBzdWNjZXNzZnVsIGZvcjpcIiwgdXNlci5lbWFpbClcbiAgICByZXR1cm4gdXNlclxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZFwiKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnblVwKGRhdGE6IHtcbiAgZW1haWw6IHN0cmluZ1xuICBwYXNzd29yZDogc3RyaW5nXG4gIGZpcnN0TmFtZTogc3RyaW5nXG4gIGxhc3ROYW1lOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xufSk6IFByb21pc2U8VXNlcj4ge1xuICAvLyBTaW11bGF0ZSBBUEkgY2FsbFxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSlcblxuICBpZiAoIWlzVmFsaWRFbWFpbChkYXRhLmVtYWlsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIilcbiAgfVxuXG4gIGlmIChkYXRhLnBhc3N3b3JkLmxlbmd0aCA8IDgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXNzd29yZCBtdXN0IGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBsb25nXCIpXG4gIH1cblxuICBpZiAoIWlzVmFsaWRQYXNzd29yZChkYXRhLnBhc3N3b3JkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3N3b3JkIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdXBwZXJjYXNlIGxldHRlciwgb25lIGxvd2VyY2FzZSBsZXR0ZXIsIGFuZCBvbmUgbnVtYmVyXCIpXG4gIH1cblxuICBpZiAoZGF0YS51c2VybmFtZS5sZW5ndGggPCAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlcm5hbWUgbXVzdCBiZSBhdCBsZWFzdCAzIGNoYXJhY3RlcnMgbG9uZ1wiKVxuICB9XG5cbiAgaWYgKCEvXlthLXpBLVowLTlfXSskLy50ZXN0KGRhdGEudXNlcm5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlcm5hbWUgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdW5kZXJzY29yZXNcIilcbiAgfVxuXG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCBleGlzdGluZ1VzZXIgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmVtYWlsID09PSBkYXRhLmVtYWlsIHx8IHUudXNlcm5hbWUgPT09IGRhdGEudXNlcm5hbWUpXG5cbiAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgIGlmIChleGlzdGluZ1VzZXIuZW1haWwgPT09IGRhdGEuZW1haWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGFjY291bnQgd2l0aCB0aGlzIGVtYWlsIGFscmVhZHkgZXhpc3RzXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgdXNlcm5hbWUgaXMgYWxyZWFkeSB0YWtlblwiKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5ld1VzZXI6IFVzZXIgPSB7XG4gICAgaWQ6IGdldE5leHRVc2VySWQoKSxcbiAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICBmaXJzdE5hbWU6IGRhdGEuZmlyc3ROYW1lLFxuICAgIGxhc3ROYW1lOiBkYXRhLmxhc3ROYW1lLFxuICAgIHVzZXJuYW1lOiBkYXRhLnVzZXJuYW1lLFxuICAgIHVzZXJUeXBlOiBcInVzZXJcIixcbiAgICBpc1ZlcmlmaWVkOiBmYWxzZSxcbiAgICBkZXBvc2l0OiAwLFxuICAgIGVhcm5pbmc6IDAsXG4gICAgY291bnRyeTogXCJVbml0ZWQgU3RhdGVzXCIsIC8vIERlZmF1bHQgdG8gVVMgaW5zdGVhZCBvZiBoYXJkY29kZWQgQmFuZ2xhZGVzaFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgc2F2ZVVzZXJUb0RhdGFiYXNlKG5ld1VzZXIpXG5cbiAgcmV0dXJuIG5ld1VzZXJcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25PdXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFNpbXVsYXRlIEFQSSBjYWxsXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZWRVc2VyKCk6IFVzZXIgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsXG5cbiAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyXCIpXG4gIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9yZVVzZXIodXNlcjogVXNlcik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlclwiLCBKU09OLnN0cmluZ2lmeSh1c2VyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyU3RvcmVkVXNlcigpOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInVzZXJcIilcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVtYWlsKGVtYWlsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvXG4gIHJldHVybiBlbWFpbFJlZ2V4LnRlc3QoZW1haWwpXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQYXNzd29yZChwYXNzd29yZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIEF0IGxlYXN0IDggY2hhcmFjdGVycywgb25lIHVwcGVyY2FzZSwgb25lIGxvd2VyY2FzZSwgb25lIG51bWJlclxuICBjb25zdCBwYXNzd29yZFJlZ2V4ID0gL14oPz0uKlthLXpdKSg/PS4qW0EtWl0pKD89LipcXGQpLns4LH0kL1xuICByZXR1cm4gcGFzc3dvcmRSZWdleC50ZXN0KHBhc3N3b3JkKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVXNlcih1c2VySWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxVc2VyPik6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZFVzZXIgPSB7IC4uLnVzZXJzW3VzZXJJbmRleF0sIC4uLnVwZGF0ZXMgfVxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcblxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJzX2RhdGFiYXNlXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJzKSlcblxuICByZXR1cm4gdXBkYXRlZFVzZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZVVzZXJTdXNwZW5zaW9uKHVzZXJJZDogc3RyaW5nKTogVXNlciB7XG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB1c2VySW5kZXggPSB1c2Vycy5maW5kSW5kZXgoKHUpID0+IHUuaWQgPT09IHVzZXJJZClcblxuICBpZiAodXNlckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCB1c2VyID0gdXNlcnNbdXNlckluZGV4XVxuICAvLyBUb2dnbGUgYmV0d2VlbiB1c2VyIGFuZCBzdXNwZW5kZWQgc3RhdHVzICh1c2luZyBhIGN1c3RvbSBmaWVsZClcbiAgY29uc3QgdXBkYXRlZFVzZXIgPSB7XG4gICAgLi4udXNlcixcbiAgICBpc1N1c3BlbmRlZDogIXVzZXIuaXNTdXNwZW5kZWQsXG4gIH1cblxuICB1c2Vyc1t1c2VySW5kZXhdID0gdXBkYXRlZFVzZXJcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2Vyc19kYXRhYmFzZVwiLCBKU09OLnN0cmluZ2lmeSh1c2VycykpXG5cbiAgcmV0dXJuIHVwZGF0ZWRVc2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kVXNlcldpdGhSZWFzb24odXNlcklkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nLCBzdXNwZW5kZWRCeTogc3RyaW5nKTogVXNlciB7XG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB1c2VySW5kZXggPSB1c2Vycy5maW5kSW5kZXgoKHUpID0+IHUuaWQgPT09IHVzZXJJZClcblxuICBpZiAodXNlckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCB1cGRhdGVkVXNlciA9IHtcbiAgICAuLi51c2Vyc1t1c2VySW5kZXhdLFxuICAgIHVzZXJUeXBlOiBcInN1c3BlbmRlZFwiIGFzIGNvbnN0LFxuICAgIHN1c3BlbnNpb25SZWFzb246IHJlYXNvbixcbiAgICBzdXNwZW5kZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHN1c3BlbmRlZEJ5OiBzdXNwZW5kZWRCeSxcbiAgfVxuXG4gIHVzZXJzW3VzZXJJbmRleF0gPSB1cGRhdGVkVXNlclxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJzX2RhdGFiYXNlXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJzKSlcblxuICByZXR1cm4gdXBkYXRlZFVzZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjdGl2YXRlVXNlcih1c2VySWQ6IHN0cmluZyk6IFVzZXIge1xuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlckluZGV4ID0gdXNlcnMuZmluZEluZGV4KCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc3QgdXBkYXRlZFVzZXIgPSB7XG4gICAgLi4udXNlcnNbdXNlckluZGV4XSxcbiAgICB1c2VyVHlwZTogXCJ1c2VyXCIgYXMgY29uc3QsXG4gICAgc3VzcGVuc2lvblJlYXNvbjogdW5kZWZpbmVkLFxuICAgIHN1c3BlbmRlZEF0OiB1bmRlZmluZWQsXG4gICAgc3VzcGVuZGVkQnk6IHVuZGVmaW5lZCxcbiAgfVxuXG4gIHVzZXJzW3VzZXJJbmRleF0gPSB1cGRhdGVkVXNlclxuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJzX2RhdGFiYXNlXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJzKSlcblxuICByZXR1cm4gdXBkYXRlZFVzZXJcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXIoKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgdmFsaWRhdGUgSldUIHRva2VucyBvciBzZXNzaW9uIGNvb2tpZXNcbiAgLy8gRm9yIG5vdywgd2UnbGwgc2ltdWxhdGUgZ2V0dGluZyB0aGUgY3VycmVudCB1c2VyIGZyb20gbG9jYWxTdG9yYWdlIG9uIHRoZSBjbGllbnRcbiAgLy8gb3IgcmV0dXJuIG51bGwgb24gdGhlIHNlcnZlciAoc2luY2Ugd2UgZG9uJ3QgaGF2ZSByZWFsIHNlc3Npb24gbWFuYWdlbWVudClcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIFNlcnZlci1zaWRlOiBJbiBhIHJlYWwgYXBwLCB5b3UnZCB2YWxpZGF0ZSBzZXNzaW9uIHRva2VucyBoZXJlXG4gICAgLy8gRm9yIGRlbW8gcHVycG9zZXMsIHJldHVybiBhIG1vY2sgYWRtaW4gdXNlciBmb3IgQVBJIGNhbGxzXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBcIjAxXCIsXG4gICAgICBlbWFpbDogXCJhZG1pbkBtYXJrZXRwbGFjZS5jb21cIixcbiAgICAgIGZpcnN0TmFtZTogXCJBZG1pblwiLFxuICAgICAgbGFzdE5hbWU6IFwiVXNlclwiLFxuICAgICAgdXNlcm5hbWU6IFwiYWRtaW5cIixcbiAgICAgIHVzZXJUeXBlOiBcImFkbWluXCIsXG4gICAgICBpc1ZlcmlmaWVkOiB0cnVlLFxuICAgICAgZGVwb3NpdDogMCxcbiAgICAgIGVhcm5pbmc6IDAsXG4gICAgICBjb3VudHJ5OiBcIlVuaXRlZCBTdGF0ZXNcIixcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cbiAgfVxuXG4gIC8vIENsaWVudC1zaWRlOiBHZXQgdXNlciBmcm9tIGxvY2FsU3RvcmFnZVxuICByZXR1cm4gZ2V0U3RvcmVkVXNlcigpXG59XG4iXSwibmFtZXMiOlsiZ2V0QWxsVXNlcnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2F2ZVVzZXJUb0RhdGFiYXNlIiwidXNlciIsInVzZXJzIiwiZXhpc3RpbmdJbmRleCIsImZpbmRJbmRleCIsInUiLCJlbWFpbCIsInB1c2giLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiZ2V0TmV4dFVzZXJJZCIsIm1heElkIiwicmVkdWNlIiwibWF4IiwibnVtSWQiLCJOdW1iZXIiLCJwYXJzZUludCIsImlkIiwiaXNOYU4iLCJNYXRoIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJpbml0aWFsaXplRGVmYXVsdFVzZXJzIiwibGVuZ3RoIiwiZGVmYXVsdFVzZXJzIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJ1c2VybmFtZSIsInVzZXJUeXBlIiwiaXNWZXJpZmllZCIsImRlcG9zaXQiLCJlYXJuaW5nIiwiY291bnRyeSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImZvckVhY2giLCJjb25zb2xlIiwibG9nIiwibWFwIiwic2lnbkluIiwicGFzc3dvcmQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJmaW5kIiwiRXJyb3IiLCJyZWFzb24iLCJzdXNwZW5zaW9uUmVhc29uIiwic2lnblVwIiwiZGF0YSIsImlzVmFsaWRFbWFpbCIsImlzVmFsaWRQYXNzd29yZCIsInRlc3QiLCJleGlzdGluZ1VzZXIiLCJuZXdVc2VyIiwic2lnbk91dCIsImdldFN0b3JlZFVzZXIiLCJzdG9yZVVzZXIiLCJjbGVhclN0b3JlZFVzZXIiLCJyZW1vdmVJdGVtIiwiZW1haWxSZWdleCIsInBhc3N3b3JkUmVnZXgiLCJ1cGRhdGVVc2VyIiwidXNlcklkIiwidXBkYXRlcyIsInVzZXJJbmRleCIsInVwZGF0ZWRVc2VyIiwidG9nZ2xlVXNlclN1c3BlbnNpb24iLCJpc1N1c3BlbmRlZCIsInN1c3BlbmRVc2VyV2l0aFJlYXNvbiIsInN1c3BlbmRlZEJ5Iiwic3VzcGVuZGVkQXQiLCJhY3RpdmF0ZVVzZXIiLCJ1bmRlZmluZWQiLCJnZXRVc2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./lib/auth.ts\n");

/***/ }),

/***/ "(ssr)/./lib/jobs.ts":
/*!*********************!*\
  !*** ./lib/jobs.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JOB_STATUS: () => (/* binding */ JOB_STATUS),\n/* harmony export */   acceptJobApplication: () => (/* binding */ acceptJobApplication),\n/* harmony export */   applyToJob: () => (/* binding */ applyToJob),\n/* harmony export */   approveJob: () => (/* binding */ approveJob),\n/* harmony export */   canApplyToJob: () => (/* binding */ canApplyToJob),\n/* harmony export */   cancelJob: () => (/* binding */ cancelJob),\n/* harmony export */   createJob: () => (/* binding */ createJob),\n/* harmony export */   getAllJobStatusHistory: () => (/* binding */ getAllJobStatusHistory),\n/* harmony export */   getAllJobs: () => (/* binding */ getAllJobs),\n/* harmony export */   getAllUserJobs: () => (/* binding */ getAllUserJobs),\n/* harmony export */   getApprovedJobs: () => (/* binding */ getApprovedJobs),\n/* harmony export */   getAvailableJobs: () => (/* binding */ getAvailableJobs),\n/* harmony export */   getJobApplicationById: () => (/* binding */ getJobApplicationById),\n/* harmony export */   getJobApplications: () => (/* binding */ getJobApplications),\n/* harmony export */   getJobById: () => (/* binding */ getJobById),\n/* harmony export */   getJobStatusColor: () => (/* binding */ getJobStatusColor),\n/* harmony export */   getJobStatusHistory: () => (/* binding */ getJobStatusHistory),\n/* harmony export */   getJobStatusLabel: () => (/* binding */ getJobStatusLabel),\n/* harmony export */   getJobs: () => (/* binding */ getJobs),\n/* harmony export */   getJobsForDashboard: () => (/* binding */ getJobsForDashboard),\n/* harmony export */   getPendingJobs: () => (/* binding */ getPendingJobs),\n/* harmony export */   getStoredJobs: () => (/* binding */ getStoredJobs),\n/* harmony export */   getUserApplications: () => (/* binding */ getUserApplications),\n/* harmony export */   getUserJobs: () => (/* binding */ getUserJobs),\n/* harmony export */   getWorkProofs: () => (/* binding */ getWorkProofs),\n/* harmony export */   getWorkProofsByJob: () => (/* binding */ getWorkProofsByJob),\n/* harmony export */   getWorkProofsByWorker: () => (/* binding */ getWorkProofsByWorker),\n/* harmony export */   isJobVisible: () => (/* binding */ isJobVisible),\n/* harmony export */   pauseJob: () => (/* binding */ pauseJob),\n/* harmony export */   reactivateJob: () => (/* binding */ reactivateJob),\n/* harmony export */   rejectJob: () => (/* binding */ rejectJob),\n/* harmony export */   rejectJobApplication: () => (/* binding */ rejectJobApplication),\n/* harmony export */   reviewWorkProof: () => (/* binding */ reviewWorkProof),\n/* harmony export */   submitJobApplication: () => (/* binding */ submitJobApplication),\n/* harmony export */   submitJobForApproval: () => (/* binding */ submitJobForApproval),\n/* harmony export */   submitWorkProof: () => (/* binding */ submitWorkProof),\n/* harmony export */   suspendJob: () => (/* binding */ suspendJob),\n/* harmony export */   toggleJobOff: () => (/* binding */ toggleJobOff),\n/* harmony export */   toggleJobOn: () => (/* binding */ toggleJobOn),\n/* harmony export */   updateJob: () => (/* binding */ updateJob),\n/* harmony export */   updateJobStatus: () => (/* binding */ updateJobStatus),\n/* harmony export */   updateJobWorkers: () => (/* binding */ updateJobWorkers)\n/* harmony export */ });\n/* harmony import */ var _categories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./categories */ \"(ssr)/./lib/categories.ts\");\n/* harmony import */ var _platform_fee__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./platform-fee */ \"(ssr)/./lib/platform-fee.ts\");\n/* harmony import */ var _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./local-reservation-storage */ \"(ssr)/./lib/local-reservation-storage.ts\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./auth */ \"(ssr)/./lib/auth.ts\");\n// Job-related types and mock data\nconst JOBS_STORAGE_KEY = \"marketplace-jobs\";\nconst APPLICATIONS_STORAGE_KEY = \"marketplace-applications\";\nconst WORK_PROOFS_STORAGE_KEY = \"marketplace-work-proofs\";\nconst JOB_REVIEWS_STORAGE_KEY = \"marketplace-job-reviews\";\nconst JOB_STATUS_HISTORY_STORAGE_KEY = \"marketplace-job-status-history\";\nconst getStoredJobs = ()=>{\n    if (true) return [];\n    try {\n        const stored = localStorage.getItem(JOBS_STORAGE_KEY);\n        if (stored) {\n            const jobs = JSON.parse(stored);\n            return jobs;\n        }\n        return [];\n    } catch  {\n        return [];\n    }\n};\nconst saveJobs = (jobs)=>{\n    if (true) return;\n    try {\n        localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n    } catch (error) {\n        console.error(\"Failed to save jobs:\", error);\n    }\n};\nconst getStoredApplications = ()=>{\n    if (true) return [];\n    try {\n        const stored = localStorage.getItem(APPLICATIONS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch  {\n        return [];\n    }\n};\nconst saveApplications = (applications)=>{\n    if (true) return;\n    try {\n        localStorage.setItem(APPLICATIONS_STORAGE_KEY, JSON.stringify(applications));\n    } catch (error) {\n        console.error(\"Failed to save applications:\", error);\n    }\n};\nconst getStoredWorkProofs = ()=>{\n    if (true) return [];\n    try {\n        const stored = localStorage.getItem(WORK_PROOFS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch  {\n        return [];\n    }\n};\nconst saveWorkProofs = (workProofs)=>{\n    if (true) return;\n    try {\n        localStorage.setItem(WORK_PROOFS_STORAGE_KEY, JSON.stringify(workProofs));\n    } catch (error) {\n        console.error(\"Failed to save work proofs:\", error);\n    }\n};\nconst getStoredJobReviews = ()=>{\n    if (true) return [];\n    try {\n        const stored = localStorage.getItem(JOB_REVIEWS_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch  {\n        return [];\n    }\n};\nconst saveJobReviews = (reviews)=>{\n    if (true) return;\n    try {\n        localStorage.setItem(JOB_REVIEWS_STORAGE_KEY, JSON.stringify(reviews));\n    } catch (error) {\n        console.error(\"Failed to save job reviews:\", error);\n    }\n};\n// Storage functions for job status history\nconst getStoredJobStatusHistory = ()=>{\n    if (true) return [];\n    try {\n        const stored = localStorage.getItem(JOB_STATUS_HISTORY_STORAGE_KEY);\n        return stored ? JSON.parse(stored) : [];\n    } catch  {\n        return [];\n    }\n};\nconst saveJobStatusHistory = (history)=>{\n    if (true) return;\n    try {\n        localStorage.setItem(JOB_STATUS_HISTORY_STORAGE_KEY, JSON.stringify(history));\n    } catch (error) {\n        console.error(\"Failed to save job status history:\", error);\n    }\n};\n// Function to record status changes\nconst recordStatusChange = (jobId, oldStatus, newStatus, userId, notes, metadata)=>{\n    const history = getStoredJobStatusHistory();\n    const statusEntry = {\n        id: `status_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        jobId,\n        userId,\n        oldStatus,\n        newStatus,\n        notes,\n        metadata,\n        createdAt: new Date().toISOString()\n    };\n    history.push(statusEntry);\n    saveJobStatusHistory(history);\n    console.log(`[v0] Status change recorded for job ${jobId}: ${oldStatus} -> ${newStatus}`);\n};\n\n\n\nasync function populateJobCategoryData(job) {\n    console.log(\"[v0] Populating category data for job:\", job.title, \"categoryId:\", job.categoryId, \"subcategoryId:\", job.subcategoryId);\n    const populatedJob = {\n        ...job\n    };\n    if (!populatedJob.category?.thumbnail && populatedJob.categoryId) {\n        const fullCategory = await (0,_categories__WEBPACK_IMPORTED_MODULE_0__.getCategoryById)(populatedJob.categoryId);\n        console.log(\"[v0] Loaded category:\", fullCategory?.name, \"thumbnail:\", fullCategory?.thumbnail);\n        if (fullCategory) {\n            populatedJob.category = {\n                id: fullCategory.id,\n                name: fullCategory.name,\n                slug: fullCategory.slug,\n                thumbnail: fullCategory.thumbnail\n            };\n            populatedJob.categoryThumbnail = fullCategory.thumbnail;\n        }\n    }\n    // Load subcategory data if subcategoryId exists\n    if (populatedJob.subcategoryId) {\n        const subcategory = await (0,_categories__WEBPACK_IMPORTED_MODULE_0__.getSubcategoryById)(populatedJob.subcategoryId);\n        console.log(\"[v0] Loaded subcategory:\", subcategory?.name, \"thumbnail:\", subcategory?.thumbnail);\n        if (subcategory) {\n            populatedJob.subcategory = subcategory;\n        }\n    }\n    console.log(\"[v0] Final job data:\", {\n        title: populatedJob.title,\n        categoryThumbnail: populatedJob.categoryThumbnail,\n        subcategory: populatedJob.subcategory?.name,\n        subcategoryThumbnail: populatedJob.subcategory?.thumbnail\n    });\n    return populatedJob;\n}\nasync function getJobs(filters) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    let filteredJobs = getStoredJobs().filter((job)=>job.status === \"approved\" || job.status === \"open\");\n    if (filters?.search) {\n        filteredJobs = filteredJobs.filter((job)=>job.title.toLowerCase().includes(filters.search.toLowerCase()) || job.description.toLowerCase().includes(filters.search.toLowerCase()) || job.skillsRequired.some((skill)=>skill.toLowerCase().includes(filters.search.toLowerCase())));\n    }\n    if (filters?.category) {\n        filteredJobs = filteredJobs.filter((job)=>job.category.slug === filters.category);\n    }\n    if (filters?.remote !== undefined) {\n        filteredJobs = filteredJobs.filter((job)=>job.isRemote === filters.remote);\n    }\n    if (filters?.budget) {\n        filteredJobs = filteredJobs.filter((job)=>job.budgetMax >= filters.budget.min && job.budgetMin <= filters.budget.max);\n    }\n    if (filters?.location && filters.location !== \"all\") {\n        filteredJobs = filteredJobs.filter((job)=>job.location.toLowerCase().includes(filters.location.toLowerCase()));\n    }\n    const sortedJobs = filteredJobs.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n    const populatedJobs = await Promise.all(sortedJobs.map(populateJobCategoryData));\n    return populatedJobs;\n}\nasync function getJobById(id) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const job = jobs.find((job)=>job.id === id);\n    if (job) {\n        // Increment view count\n        job.viewsCount = (job.viewsCount || 0) + 1;\n        const jobIndex = jobs.findIndex((j)=>j.id === id);\n        if (jobIndex !== -1) {\n            jobs[jobIndex] = job;\n            saveJobs(jobs);\n        }\n        const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(ssr)/./lib/auth.ts\"));\n        const users = getAllUsers();\n        const posterUser = users.find((u)=>u.id === job.userId);\n        if (posterUser) {\n            job.poster = {\n                id: posterUser.id,\n                firstName: posterUser.firstName,\n                lastName: posterUser.lastName,\n                username: posterUser.username,\n                avatar: posterUser.avatar,\n                rating: 4.5,\n                totalReviews: 0\n            };\n        }\n        return await populateJobCategoryData(job);\n    }\n    return null;\n}\nasync function getJobApplications(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    return applications.filter((app)=>app.jobId === jobId);\n}\nasync function submitJobApplication(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    if (!data.userId) {\n        throw new Error(\"User ID is required to submit application\");\n    }\n    if (!data.coverLetter.trim()) {\n        throw new Error(\"Cover letter is required\");\n    }\n    if (data.proposedBudget <= 0) {\n        throw new Error(\"Proposed budget must be greater than 0\");\n    }\n    // Check if user already applied\n    const existingApplications = getStoredApplications();\n    const hasApplied = existingApplications.some((app)=>app.jobId === data.jobId && app.applicantId === data.userId);\n    if (hasApplied) {\n        throw new Error(\"You have already applied to this job\");\n    }\n    // Get user data for application\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(ssr)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === data.userId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const newApplication = {\n        id: `app_${Date.now()}`,\n        jobId: data.jobId,\n        applicantId: data.userId,\n        coverLetter: data.coverLetter,\n        proposedBudget: data.proposedBudget,\n        estimatedDuration: data.estimatedDuration,\n        portfolioLinks: data.portfolioLinks,\n        status: \"pending\",\n        createdAt: new Date().toISOString(),\n        applicant: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            rating: 4.5,\n            totalReviews: 0,\n            skills: [\n                \"General\"\n            ]\n        }\n    };\n    const applications = getStoredApplications();\n    applications.push(newApplication);\n    saveApplications(applications);\n    // Update job application count\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === data.jobId);\n    if (jobIndex !== -1) {\n        jobs[jobIndex].applicationsCount = (jobs[jobIndex].applicationsCount || 0) + 1;\n        saveJobs(jobs);\n    }\n    // Create notification for job poster\n    const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (job) {\n        await createNotification({\n            userId: job.userId,\n            type: \"job\",\n            title: \"New Job Application\",\n            description: `${user.firstName} ${user.lastName} applied for your job \"${job.title}\"`,\n            actionUrl: `/dashboard/jobs/${job.id}/applications`\n        });\n    }\n    return newApplication;\n}\nasync function submitJobForApproval(jobData, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    if (!userId) {\n        throw new Error(\"User ID is required to submit job\");\n    }\n    if (!jobData.title?.trim()) {\n        throw new Error(\"Job title is required\");\n    }\n    if (!jobData.description?.trim()) {\n        throw new Error(\"Job description is required\");\n    }\n    if (!jobData.budgetMin || jobData.budgetMin <= 0) {\n        throw new Error(\"Valid budget is required\");\n    }\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(ssr)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === userId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const { getCategoryById } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./categories */ \"(ssr)/./lib/categories.ts\"));\n    const category = await getCategoryById(jobData.categoryId || \"\");\n    const { getSubcategoryById } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./categories */ \"(ssr)/./lib/categories.ts\"));\n    const subcategory = jobData.subcategoryId ? await getSubcategoryById(jobData.subcategoryId) : null;\n    const checkAutoJobApproval = ()=>{\n        console.log(\"[v0] ðŸ”§ AUTO-APPROVAL CHECK: Starting auto-approval check...\");\n        // For server-side execution, we need to pass the setting from client\n        // Default to MANUAL APPROVAL (false) for security\n        let autoApprovalSetting = false;\n        try {\n            // Check if we're in browser environment\n            if (false) {} else {\n                console.log(\"[v0] ðŸ”§ AUTO-APPROVAL CHECK: Server-side execution - defaulting to MANUAL APPROVAL\");\n                autoApprovalSetting = false;\n            }\n        } catch (error) {\n            console.error(\"[v0] ðŸ”§ AUTO-APPROVAL CHECK: Error accessing localStorage:\", error);\n            autoApprovalSetting = false;\n        }\n        console.log(\"[v0] ðŸ”§ AUTO-APPROVAL CHECK: Final decision:\", autoApprovalSetting ? \"AUTO-APPROVE\" : \"MANUAL APPROVAL\");\n        return autoApprovalSetting;\n    };\n    const shouldAutoApprove = checkAutoJobApproval();\n    const jobStatus = shouldAutoApprove ? \"approved\" : \"pending\";\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Starting job creation process\");\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Auto-approval enabled:\", shouldAutoApprove);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Job status will be:\", jobStatus);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Job title:\", jobData.title);\n    const newJob = {\n        id: `job_${Date.now()}`,\n        userId,\n        categoryId: jobData.categoryId || \"\",\n        subcategoryId: jobData.subcategoryId,\n        title: jobData.title,\n        description: jobData.description,\n        requirements: jobData.requirements,\n        instructions: jobData.instructions,\n        budgetMin: jobData.budgetMin,\n        budgetMax: jobData.budgetMax || jobData.budgetMin,\n        deadline: jobData.deadline || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString().split(\"T\")[0],\n        location: jobData.location || \"Remote\",\n        isRemote: jobData.isRemote ?? true,\n        status: jobStatus,\n        priority: jobData.priority || \"normal\",\n        skillsRequired: jobData.skillsRequired || [],\n        applicationsCount: 0,\n        viewsCount: 0,\n        workersNeeded: jobData.workersNeeded || 1,\n        duration: jobData.duration,\n        durationType: jobData.durationType,\n        tags: jobData.tags || [],\n        attachments: jobData.attachments || [],\n        requireScreenshots: jobData.requireScreenshots || 0,\n        screenshotCost: (jobData.requireScreenshots || 0) * 0.05,\n        estimatedApprovalDays: jobData.estimatedApprovalDays || 1,\n        requiredProof: jobData.requirements,\n        submittedAt: new Date().toISOString(),\n        approvedAt: shouldAutoApprove ? new Date().toISOString() : undefined,\n        approvedBy: shouldAutoApprove ? \"System (Auto-approval)\" : undefined,\n        approvalReason: shouldAutoApprove ? \"Automatically approved - Auto-approval is enabled\" : undefined,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        category: category || {\n            id: jobData.categoryId || \"\",\n            name: \"General\",\n            slug: \"general\"\n        },\n        subcategory: subcategory ? {\n            id: subcategory.id,\n            name: subcategory.name,\n            slug: subcategory.slug,\n            thumbnail: subcategory.thumbnail\n        } : undefined,\n        poster: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            rating: 4.5,\n            totalReviews: 0\n        }\n    };\n    const jobs = getStoredJobs();\n    jobs.push(newJob);\n    saveJobs(jobs);\n    const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n    await createNotification({\n        userId,\n        type: \"job\",\n        title: shouldAutoApprove ? \"Job Approved\" : \"Job Submitted for Review\",\n        description: shouldAutoApprove ? `Your job \"${newJob.title}\" has been automatically approved and is now live` : `Your job \"${newJob.title}\" has been submitted and is pending admin review`,\n        actionUrl: `/dashboard/jobs`\n    });\n    console.log(\"[v0] âœ… JOB CREATION: Job created successfully with ID:\", newJob.id);\n    console.log(\"[v0] âœ… JOB CREATION: Final job status:\", newJob.status);\n    console.log(\"[v0] âœ… JOB CREATION: Auto-approved:\", shouldAutoApprove);\n    return newJob;\n}\nasync function approveJob(jobId, adminId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"approved\", adminId, reason);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"open\", adminId, reason || \"Job approved by admin\", {\n        reviewId: `review-${Date.now()}`,\n        decision: \"accepted\",\n        feedback: reason\n    });\n    return updatedJob;\n}\nasync function rejectJob(jobId, adminId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"rejected\", adminId, reason);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"rejected\", adminId, reason, {\n        reviewId: `review-${Date.now()}`,\n        decision: \"rejected\",\n        feedback: reason\n    });\n    return updatedJob;\n}\nasync function suspendJob(jobId, adminId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", adminId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", adminId, \"Job suspended by admin\", {\n        reviewId: `review-${Date.now()}`,\n        decision: \"revision_requested\",\n        feedback: \"Job suspended by admin\"\n    });\n    return updatedJob;\n}\nasync function getPendingJobs() {\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.status === \"pending\");\n}\nasync function getApprovedJobs() {\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.status === \"approved\" || job.status === \"open\");\n}\nasync function getAllJobs() {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const populatedJobs = await Promise.all(jobs.map(populateJobCategoryData));\n    return populatedJobs;\n}\nasync function getAllUserJobs(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>job.userId === userId);\n}\nasync function updateJob(jobId, updates) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const updatedJob = {\n        ...jobs[jobIndex],\n        ...updates,\n        updatedAt: new Date().toISOString(),\n        // If job is edited, it needs re-approval\n        status: updates.status || \"pending\"\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    return updatedJob;\n}\nasync function cancelJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Get work proofs to see how many workers have submitted work\n    const workProofs = getStoredWorkProofs().filter((wp)=>wp.jobId === jobId);\n    const submittedWorkCount = workProofs.length;\n    const remainingSlots = job.workersNeeded - submittedWorkCount;\n    const jobCostPerWorker = job.budgetMax;\n    const platformFeePerWorker = jobCostPerWorker * 0.05;\n    const totalCostPerWorker = jobCostPerWorker + platformFeePerWorker;\n    const refundAmount = remainingSlots > 0 ? remainingSlots * totalCostPerWorker : 0;\n    if (refundAmount > 0) {\n        try {\n            const { addWalletTransaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n            await addWalletTransaction({\n                userId,\n                type: \"refund\",\n                amount: refundAmount,\n                description: `Refund for cancelled job: \"${job.title}\" (Job #${job.formattedJobId || job.id}) - ${remainingSlots} remaining slots + platform fees`,\n                referenceId: jobId,\n                referenceType: \"job_cancellation\",\n                balanceType: \"deposit\"\n            });\n            console.log(`[v0] âœ… Job cancellation refund processed: $${refundAmount}`);\n        } catch (error) {\n            if (error instanceof Error && error.message.includes(\"already exists\")) {\n                console.log(`[v0] âš ï¸ Job cancellation refund already processed for job: ${jobId}`);\n            } else {\n                console.error(`[v0] âŒ Failed to process job cancellation refund:`, error);\n                throw error;\n            }\n        }\n    }\n    // Update job status to cancelled but keep it accessible for submitted work review\n    const updatedJob = {\n        ...job,\n        status: \"cancelled\",\n        updatedAt: new Date().toISOString(),\n        cancellationDetails: {\n            cancelledAt: new Date().toISOString(),\n            submittedWorkCount,\n            remainingSlots,\n            refundAmount,\n            canReviewSubmissions: submittedWorkCount > 0\n        }\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"cancelled\", userId, `Job cancelled. ${submittedWorkCount} work submissions can still be reviewed. ${remainingSlots} slots refunded including platform fee.`, {\n        userAction: \"cancel\",\n        submittedWorkCount,\n        remainingSlots,\n        refundAmount,\n        canReviewSubmissions: submittedWorkCount > 0\n    });\n    console.log(`[v0] Job ${jobId} cancelled. Refund: $${refundAmount} (including platform fee), Submitted work: ${submittedWorkCount}`);\n    return {\n        job: updatedJob,\n        refundAmount\n    };\n}\nasync function pauseJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const oldStatus = jobs[jobIndex].status;\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", userId, \"Job paused by owner\", {\n        userAction: \"pause\"\n    });\n    return updatedJob;\n}\nasync function reactivateJob(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const oldStatus = jobs[jobIndex].status;\n    // Reactivated jobs need re-approval\n    const updatedJob = await updateJobStatus(jobId, \"pending\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"pending\", userId, \"Job reactivated and resubmitted for approval\", {\n        userAction: \"reactivate\"\n    });\n    return updatedJob;\n}\nasync function getUserApplications(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const jobs = getStoredJobs();\n    // Filter applications by user and add job details\n    const userApplications = applications.filter((app)=>app.applicantId === userId).map((app)=>{\n        const job = jobs.find((j)=>j.id === app.jobId);\n        return {\n            ...app,\n            job: job || null,\n            appliedAt: app.createdAt\n        };\n    });\n    return userApplications;\n}\n\nasync function submitWorkProof(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] ðŸ“ WORK PROOF: Starting work proof submission\");\n    console.log(\"[v0] ðŸ“ WORK PROOF: Job ID:\", data.jobId);\n    console.log(\"[v0] ðŸ“ WORK PROOF: Worker ID:\", data.workerId);\n    const users = (0,_auth__WEBPACK_IMPORTED_MODULE_3__.getAllUsers)();\n    const workerUser = users.find((u)=>u.id === data.workerId);\n    console.log(\"[v0] ðŸ‘¤ Found worker user:\", workerUser?.firstName, workerUser?.lastName, workerUser?.username);\n    // Get job details to check approval type\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (!job) {\n        throw new Error(\"Job not found\");\n    }\n    console.log(\"[v0] ðŸ“ WORK PROOF: Job approval type:\", job.approvalType);\n    console.log(\"[v0] ðŸ“ WORK PROOF: Instant approval enabled:\", job.isInstantApprovalEnabled);\n    // Get application details\n    const applications = getStoredApplications();\n    const application = applications.find((app)=>app.id === data.applicationId);\n    if (!application) {\n        throw new Error(\"Application not found\");\n    }\n    const paymentAmount = application.proposedBudget || job.budgetMax || job.budgetMin;\n    const shouldProcessInstantPayment = job.approvalType === \"instant\" && job.isInstantApprovalEnabled === true;\n    console.log(\"[v0] ðŸ“ WORK PROOF: Should process instant payment:\", shouldProcessInstantPayment);\n    console.log(\"[v0] ðŸ“ WORK PROOF: Payment amount:\", paymentAmount);\n    const newProof = {\n        id: Date.now().toString(),\n        jobId: data.jobId,\n        applicationId: data.applicationId,\n        workerId: data.workerId,\n        employerId: job.userId,\n        title: data.title,\n        description: data.description,\n        submissionText: data.submissionText,\n        proofFiles: data.proofFiles || [],\n        proofLinks: data.proofLinks || [],\n        screenshots: data.screenshots || [],\n        attachments: data.attachments || [],\n        status: shouldProcessInstantPayment ? \"approved\" : \"submitted\",\n        submittedAt: new Date().toISOString(),\n        approvedAt: shouldProcessInstantPayment ? new Date().toISOString() : undefined,\n        paymentAmount,\n        submissionNumber: 1,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        worker: {\n            id: data.workerId,\n            firstName: workerUser?.firstName || \"Unknown\",\n            lastName: workerUser?.lastName || \"Worker\",\n            username: workerUser?.username || `user${data.workerId}`,\n            avatar: workerUser?.avatar\n        },\n        employer: {\n            id: job.userId,\n            firstName: users.find((u)=>u.id === job.userId)?.firstName || \"Job\",\n            lastName: users.find((u)=>u.id === job.userId)?.lastName || \"Poster\",\n            username: users.find((u)=>u.id === job.userId)?.username || \"jobposter\"\n        }\n    };\n    if (shouldProcessInstantPayment) {\n        try {\n            console.log(\"[v0] ðŸ’° INSTANT PAYMENT: Processing instant payment for work proof\");\n            const { addWalletTransaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n            // Calculate platform fee (5% default)\n            const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n            let platformFeeRate = 0.05 // Default fallback\n            ;\n            let platformFee = 0;\n            if (platformFeeSettings) {\n                const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(paymentAmount, platformFeeSettings);\n                platformFee = feeCalculation.platformFee;\n                platformFeeRate = platformFeeSettings.feePercentage / 100;\n            } else {\n                platformFee = Math.round(paymentAmount * platformFeeRate * 100) / 100;\n            }\n            const workerAmount = Math.round((paymentAmount - platformFee) * 100) / 100;\n            console.log(\"[v0] ðŸ’° INSTANT PAYMENT: Total amount:\", paymentAmount);\n            console.log(\"[v0] ðŸ’° INSTANT PAYMENT: Platform fee:\", platformFee);\n            console.log(\"[v0] ðŸ’° INSTANT PAYMENT: Worker receives:\", workerAmount);\n            // Add money to worker's withdrawal balance\n            await addWalletTransaction({\n                userId: data.workerId,\n                type: \"job_payment\",\n                amount: workerAmount,\n                description: `Instant payment for job: ${job.title}`,\n                referenceId: data.jobId,\n                referenceType: \"job_payment\",\n                balanceType: \"withdrawal\"\n            });\n            // Record platform fee\n            await addWalletTransaction({\n                userId: \"platform\",\n                type: \"platform_fee\",\n                amount: platformFee,\n                description: `Platform fee for job: ${job.title}`,\n                referenceId: data.jobId,\n                referenceType: \"platform_fee\",\n                balanceType: \"withdrawal\"\n            });\n            newProof.approvedAt = new Date().toISOString();\n            newProof.approvedBy = \"System (Instant Approval)\";\n            newProof.paymentProcessedAt = new Date().toISOString();\n            console.log(\"[v0] âœ… INSTANT PAYMENT: Payment processed successfully\");\n            // Create notification for worker\n            const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n            await createNotification({\n                userId: data.workerId,\n                type: \"payment\",\n                title: \"Instant Payment Received! ðŸ’°\",\n                description: `You received $${workerAmount.toFixed(2)} for completing \"${job.title}\". Payment has been added to your withdrawal balance.`,\n                actionUrl: `/dashboard/wallet`\n            });\n            // Create notification for employer\n            await createNotification({\n                userId: job.userId,\n                type: \"job\",\n                title: \"Work Submitted & Payment Released\",\n                description: `Work has been submitted for \"${job.title}\" and instant payment of $${paymentAmount.toFixed(2)} has been released to the worker.`,\n                actionUrl: `/dashboard/jobs/${data.jobId}`\n            });\n            console.log(\"[v0] âœ… INSTANT PAYMENT: Notifications sent successfully\");\n        } catch (error) {\n            console.error(\"[v0] âŒ INSTANT PAYMENT: Error processing instant payment:\", error);\n            // Don't fail the work proof submission, just log the error\n            newProof.status = \"submitted\";\n            newProof.paymentError = error.message;\n        }\n    } else {\n        console.log(\"[v0] ðŸ“ WORK PROOF: Manual approval required, creating notification for employer\");\n        const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n        await createNotification({\n            userId: job.userId,\n            type: \"job\",\n            title: \"Work Submitted for Review\",\n            description: `Work has been submitted for \"${job.title}\". Please review and approve within ${job.manualApprovalDays || 3} days.`,\n            actionUrl: `/dashboard/jobs/${data.jobId}`\n        });\n    }\n    const workProofs = getStoredWorkProofs();\n    workProofs.push(newProof);\n    saveWorkProofs(workProofs);\n    console.log(\"[v0] âœ… WORK PROOF: Work proof saved successfully with status:\", newProof.status);\n    return newProof;\n}\nasync function getWorkProofsByJob(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const workProofs = getStoredWorkProofs();\n    return workProofs.filter((proof)=>proof.jobId === jobId);\n}\nasync function getWorkProofsByWorker(workerId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const workProofs = getStoredWorkProofs();\n    return workProofs.filter((proof)=>proof.workerId === workerId);\n}\nasync function getWorkProofs(jobId) {\n    return await getWorkProofsByJob(jobId);\n}\nasync function reviewWorkProof(proofId, reviewData) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    const workProofs = getStoredWorkProofs();\n    const proofIndex = workProofs.findIndex((proof)=>proof.id === proofId);\n    if (proofIndex === -1) {\n        throw new Error(\"Work proof not found\");\n    }\n    const proof = workProofs[proofIndex];\n    // Update proof status\n    workProofs[proofIndex] = {\n        ...proof,\n        status: reviewData.decision === \"accepted\" ? \"accepted\" : reviewData.decision === \"rejected\" ? \"rejected\" : \"revision_requested\",\n        updatedAt: new Date().toISOString()\n    };\n    saveWorkProofs(workProofs);\n    // Create review record\n    const review = {\n        id: `review-${Date.now()}`,\n        jobId: proof.jobId,\n        proofId: proofId,\n        reviewerId: reviewData.reviewerId,\n        decision: reviewData.decision,\n        feedback: reviewData.feedback,\n        revisionNotes: reviewData.revisionNotes,\n        reviewedAt: new Date().toISOString()\n    };\n    // Store review (in real app, this would go to database)\n    const reviews = getStoredJobReviews();\n    reviews.push(review);\n    saveJobReviews(reviews);\n    // Update job and application status based on decision\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === proof.jobId);\n    if (jobIndex !== -1) {\n        const oldStatus = jobs[jobIndex].status;\n        let newStatus = oldStatus;\n        if (reviewData.decision === \"accepted\") {\n            // Update job to completed\n            newStatus = \"completed\";\n            jobs[jobIndex] = {\n                ...jobs[jobIndex],\n                status: \"completed\",\n                updatedAt: new Date().toISOString()\n            };\n            recordStatusChange(proof.jobId, oldStatus, \"completed\", reviewData.reviewerId, \"Work proof accepted - job completed\", {\n                reviewId: review.id,\n                decision: \"accepted\",\n                feedback: reviewData.feedback\n            });\n        } else if (reviewData.decision === \"rejected\") {\n            recordStatusChange(proof.jobId, oldStatus, oldStatus, reviewData.reviewerId, \"Work proof rejected - awaiting rework or dispute\", {\n                reviewId: review.id,\n                decision: \"rejected\",\n                feedback: reviewData.feedback,\n                revisionNotes: reviewData.revisionNotes\n            });\n        } else {\n            recordStatusChange(proof.jobId, oldStatus, oldStatus, reviewData.reviewerId, \"Revision requested on work proof\", {\n                reviewId: review.id,\n                decision: \"revision_requested\",\n                revisionNotes: reviewData.revisionNotes\n            });\n        }\n        saveJobs(jobs);\n        // Update application to completed if accepted\n        if (reviewData.decision === \"accepted\") {\n            const applications = getStoredApplications();\n            const appIndex = applications.findIndex((app)=>app.jobId === proof.jobId && app.applicantId === proof.workerId);\n            if (appIndex !== -1) {\n                applications[appIndex] = {\n                    ...applications[appIndex],\n                    status: \"completed\"\n                };\n                saveApplications(applications);\n            }\n        }\n    }\n    return review;\n}\nasync function getJobApplicationById(applicationId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    return applications.find((app)=>app.id === applicationId) || null;\n}\nasync function updateJobStatus(jobId, newStatus, userId, metadata) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === jobId);\n    if (jobIndex === -1) throw new Error(\"Job not found\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    const updatedJob = {\n        ...job,\n        status: newStatus,\n        updatedAt: new Date().toISOString(),\n        ...newStatus === \"completed\" && {\n            completedAt: new Date().toISOString()\n        }\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    // Add to status history\n    const statusHistory = getStoredJobStatusHistory();\n    statusHistory.push({\n        id: `status_${Date.now()}`,\n        jobId,\n        userId,\n        oldStatus,\n        newStatus,\n        notes: metadata?.notes || `Status changed from ${oldStatus} to ${newStatus}`,\n        metadata,\n        createdAt: new Date().toISOString()\n    });\n    saveJobStatusHistory(statusHistory);\n    console.log(\"[v0] Job status updated:\", jobId, \"from\", oldStatus, \"to\", newStatus);\n    if (newStatus === \"completed\") {\n        try {\n            const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n            // Notify job poster\n            await createNotification({\n                userId: job.userId,\n                type: \"job\",\n                title: \"Job Completed Successfully\",\n                description: `Your job \"${job.title}\" has been completed by all required workers.`,\n                actionUrl: `/dashboard/jobs/${jobId}`\n            });\n            // If there are multiple workers, notify them all\n            if (metadata?.totalWorkersCompleted && metadata.totalWorkersCompleted > 1) {\n                const { getJobApplications } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./jobs */ \"(ssr)/./lib/jobs.ts\"));\n                const applications = await getJobApplications(jobId);\n                const acceptedWorkers = applications.filter((app)=>app.status === \"accepted\");\n                for (const app of acceptedWorkers){\n                    await createNotification({\n                        userId: app.applicantId,\n                        type: \"job\",\n                        title: \"Job Fully Completed\",\n                        description: `The job \"${job.title}\" has been completed by all required workers.`,\n                        actionUrl: `/dashboard/applied-jobs`\n                    });\n                }\n            }\n        } catch (error) {\n            console.error(\"[v0] Failed to send completion notifications:\", error);\n        }\n    }\n    return updatedJob;\n}\nconst JOB_STATUS = {\n    PENDING: \"pending\",\n    APPROVED: \"approved\",\n    REJECTED: \"rejected\",\n    SUSPENDED: \"suspended\",\n    OPEN: \"open\",\n    IN_PROGRESS: \"in_progress\",\n    COMPLETED: \"completed\",\n    CANCELLED: \"cancelled\"\n};\nconst getJobStatusColor = (status)=>{\n    switch(status){\n        case JOB_STATUS.PENDING:\n            return \"bg-yellow-100 text-yellow-800\";\n        case JOB_STATUS.APPROVED:\n        case JOB_STATUS.OPEN:\n            return \"bg-green-100 text-green-800\";\n        case JOB_STATUS.REJECTED:\n            return \"bg-red-100 text-red-800\";\n        case JOB_STATUS.SUSPENDED:\n            return \"bg-gray-100 text-gray-800\";\n        case JOB_STATUS.IN_PROGRESS:\n            return \"bg-blue-100 text-blue-800\";\n        case JOB_STATUS.COMPLETED:\n            return \"bg-purple-100 text-purple-800\";\n        case JOB_STATUS.CANCELLED:\n            return \"bg-orange-100 text-orange-800\";\n        default:\n            return \"bg-gray-100 text-gray-800\";\n    }\n};\nconst getJobStatusLabel = (status)=>{\n    switch(status){\n        case JOB_STATUS.PENDING:\n            return \"Pending Review\";\n        case JOB_STATUS.APPROVED:\n            return \"Approved\";\n        case JOB_STATUS.REJECTED:\n            return \"Rejected\";\n        case JOB_STATUS.SUSPENDED:\n            return \"Suspended\";\n        case JOB_STATUS.OPEN:\n            return \"Open\";\n        case JOB_STATUS.IN_PROGRESS:\n            return \"In Progress\";\n        case JOB_STATUS.COMPLETED:\n            return \"Completed\";\n        case JOB_STATUS.CANCELLED:\n            return \"Cancelled\";\n        default:\n            return status;\n    }\n};\nconst canApplyToJob = (job)=>{\n    return job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN;\n};\nconst isJobVisible = (job, userType = \"user\")=>{\n    if (userType === \"admin\") {\n        return true // Admins can see all jobs\n        ;\n    }\n    // Regular users can only see approved/open jobs\n    return job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN;\n};\nconst getAvailableJobs = async (currentUserId)=>{\n    const jobs = getStoredJobs();\n    return jobs.filter((job)=>{\n        // Basic status filter - only show approved/open jobs that aren't completed\n        const isValidStatus = (job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN) && job.status !== JOB_STATUS.COMPLETED;\n        if (!isValidStatus) return false;\n        const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n        const currentApplications = job.applicationsCount || 0;\n        // If job has reached its worker limit, don't show it as available\n        if (currentApplications >= workersNeeded) {\n            console.log(\"[v0] Job\", job.id, \"at capacity:\", currentApplications, \"of\", workersNeeded, \"workers\");\n            return false;\n        }\n        const reservationInfo = _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__.localReservationStorage.isJobReserved(job.id);\n        // If job is not reserved, show it to everyone\n        if (!reservationInfo.isReserved) return true;\n        // If job needs multiple workers, show it even when reserved (partial reservation)\n        if (job.workersNeeded > 1) return true;\n        // For single-worker jobs that are reserved:\n        // Only show to the user who reserved it, hide from others\n        if (job.workersNeeded === 1 && reservationInfo.isReserved) {\n            return currentUserId === reservationInfo.userId;\n        }\n        return true;\n    });\n};\nconst getJobsForDashboard = (jobs, currentUserId)=>{\n    return jobs.filter((job)=>{\n        // Basic status filter\n        const isValidStatus = (job.status === JOB_STATUS.APPROVED || job.status === JOB_STATUS.OPEN) && job.status !== JOB_STATUS.COMPLETED;\n        if (!isValidStatus) return false;\n        const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n        const currentApplications = job.applicationsCount || 0;\n        // If job has reached its worker limit, don't show it as available\n        if (currentApplications >= workersNeeded) {\n            console.log(\"[v0] Dashboard job\", job.id, \"at capacity:\", currentApplications, \"of\", workersNeeded, \"workers\");\n            return false;\n        }\n        const reservationInfo = _local_reservation_storage__WEBPACK_IMPORTED_MODULE_2__.localReservationStorage.isJobReserved(job.id);\n        // If job is not reserved, show it to everyone\n        if (!reservationInfo.isReserved) return true;\n        // If job needs multiple workers, show it even when reserved\n        if (job.workersNeeded > 1) return true;\n        // For single-worker jobs that are reserved:\n        // Only show to the user who reserved it\n        if (job.workersNeeded === 1 && reservationInfo.isReserved) {\n            return currentUserId === reservationInfo.userId;\n        }\n        return true;\n    });\n};\n// Function to get job status history\nasync function getJobStatusHistory(jobId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const history = getStoredJobStatusHistory();\n    return history.filter((entry)=>entry.jobId === jobId).sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n}\n// Function to get all status history for admin\nasync function getAllJobStatusHistory() {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const history = getStoredJobStatusHistory();\n    return history.sort((a, b)=>new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n}\nasync function acceptJobApplication(applicationId, employerId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const applicationIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (applicationIndex === -1) {\n        throw new Error(\"Application not found\");\n    }\n    const application = applications[applicationIndex];\n    // Verify employer owns the job\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === application.jobId);\n    const job = jobs[jobIndex];\n    if (!job || job.userId !== employerId) {\n        throw new Error(\"You don't have permission to accept this application\");\n    }\n    const updatedApplication = {\n        ...application,\n        status: \"accepted\",\n        acceptedAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    applications[applicationIndex] = updatedApplication;\n    saveApplications(applications);\n    const updatedJob = {\n        ...job,\n        status: \"completed\",\n        assignedWorkerId: application.applicantId,\n        completedAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n    };\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    try {\n        const { addWalletTransaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n        const paymentAmount = application.proposedBudget;\n        if (!paymentAmount || paymentAmount <= 0) {\n            throw new Error(`Invalid payment amount: ${paymentAmount}`);\n        }\n        // Calculate platform fee (5% default)\n        const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n        let platformFeeRate = 0.05 // Default fallback\n        ;\n        let platformFee = 0;\n        if (platformFeeSettings) {\n            const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(paymentAmount, platformFeeSettings);\n            platformFee = feeCalculation.platformFee;\n            platformFeeRate = platformFeeSettings.feePercentage / 100;\n        } else {\n            platformFee = Math.round(paymentAmount * platformFeeRate * 100) / 100;\n        }\n        const workerAmount = Math.round((paymentAmount - platformFee) * 100) / 100 // Round to 2 decimals\n        ;\n        console.log(`[v0] ðŸ’° Processing instant payment:`);\n        console.log(`[v0] - Total job amount: $${paymentAmount}`);\n        console.log(`[v0] - Platform fee (5%): $${platformFee}`);\n        console.log(`[v0] - Worker receives: $${workerAmount}`);\n        console.log(`[v0] - Worker ID: ${application.applicantId}`);\n        // Add money to worker's withdrawal balance\n        await addWalletTransaction(application.applicantId, {\n            type: \"job_payment\",\n            amount: workerAmount,\n            description: `Payment for job: ${job.title}`,\n            jobId: job.id,\n            fromUserId: employerId\n        });\n        console.log(`[v0] âœ… Payment successfully added to worker ${application.applicantId} wallet: $${workerAmount}`);\n        // Record platform fee\n        await addWalletTransaction(\"platform\", {\n            type: \"platform_fee\",\n            amount: platformFee,\n            description: `Platform fee for job: ${job.title}`,\n            jobId: job.id,\n            fromUserId: employerId\n        });\n        console.log(`[v0] âœ… Platform fee recorded: $${platformFee}`);\n    } catch (error) {\n        console.error(\"[v0] âŒ Error processing instant payment:\", error);\n        throw new Error(`Payment processing failed: ${error.message}`);\n    }\n    // Create notification for applicant\n    const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: application.applicantId,\n        type: \"job\",\n        title: \"Job Accepted & Payment Released!\",\n        description: `Your application for \"${job.title}\" has been accepted and payment of $${application.proposedBudget - application.proposedBudget * 0.05} has been added to your withdrawal balance!`,\n        actionUrl: `/dashboard/wallet`\n    });\n    // Create notification for employer\n    await createNotification({\n        userId: employerId,\n        type: \"job\",\n        title: \"Job Completed\",\n        description: `Job \"${job.title}\" has been completed and payment has been released to the worker.`,\n        actionUrl: `/dashboard/jobs`\n    });\n    return updatedApplication;\n}\nasync function rejectJobApplication(applicationId, employerId, reason) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const applications = getStoredApplications();\n    const applicationIndex = applications.findIndex((app)=>app.id === applicationId);\n    if (applicationIndex === -1) {\n        throw new Error(\"Application not found\");\n    }\n    const application = applications[applicationIndex];\n    // Verify employer owns the job\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === application.jobId);\n    if (!job || job.userId !== employerId) {\n        throw new Error(\"You don't have permission to reject this application\");\n    }\n    const updatedApplication = {\n        ...application,\n        status: \"rejected\",\n        rejectedAt: new Date().toISOString(),\n        rejectionReason: reason,\n        updatedAt: new Date().toISOString()\n    };\n    applications[applicationIndex] = updatedApplication;\n    saveApplications(applications);\n    // Create notification for applicant\n    const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: application.applicantId,\n        type: \"job\",\n        title: \"Application Rejected\",\n        description: `Your application for \"${job.title}\" was not selected. Keep applying to other opportunities!`,\n        actionUrl: `/dashboard/applied-jobs`\n    });\n    return updatedApplication;\n}\nasync function getUserJobs(userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const userJobs = jobs.filter((job)=>job.userId === userId);\n    const jobsWithCounts = await Promise.all(userJobs.map(async (job)=>{\n        try {\n            // Get applications for this job\n            const applications = await getJobApplications(job.id);\n            const applicationsCount = applications.length;\n            console.log(`[v0] Job ${job.id} (${job.title}): Found ${applicationsCount} applications`);\n            // Update the job with actual counts\n            return {\n                ...job,\n                applicationsCount,\n                // For now, we'll use a simple view count based on applications\n                // In a real system, this would be tracked separately\n                viewsCount: Math.max(job.viewsCount || 0, applicationsCount * 2)\n            };\n        } catch (error) {\n            console.error(`[v0] Error counting applications for job ${job.id}:`, error);\n            return job;\n        }\n    }));\n    return jobsWithCounts;\n}\nasync function applyToJob(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] ðŸ” WORKER VALIDATION: Checking application for job:\", data.jobId, \"by worker:\", data.applicantId);\n    const jobs = getStoredJobs();\n    const job = jobs.find((j)=>j.id === data.jobId);\n    if (!job) {\n        throw new Error(\"Job not found\");\n    }\n    if (job.status !== \"approved\") {\n        throw new Error(\"Job is not available for applications\");\n    }\n    // Check if user already applied to this job\n    const existingApplications = getStoredApplications();\n    const existingApplication = existingApplications.find((app)=>app.jobId === data.jobId && app.applicantId === data.applicantId);\n    if (existingApplication) {\n        console.log(\"[v0] âš ï¸ WORKER VALIDATION: User already applied to this job - treating as resubmission\");\n        // Update existing application instead of creating new one\n        const applications = JSON.parse(localStorage.getItem(\"job_applications\") || \"[]\");\n        const applicationIndex = applications.findIndex((app)=>app.id === existingApplication.id);\n        if (applicationIndex !== -1) {\n            applications[applicationIndex] = {\n                ...applications[applicationIndex],\n                coverLetter: data.coverLetter,\n                proposedBudget: data.proposedBudget,\n                estimatedDuration: data.estimatedDuration,\n                portfolioLinks: data.portfolioLinks,\n                updatedAt: new Date().toISOString(),\n                resubmissionCount: (applications[applicationIndex].resubmissionCount || 0) + 1\n            };\n            localStorage.setItem(\"job_applications\", JSON.stringify(applications));\n            console.log(\"[v0] âœ… WORKER VALIDATION: Application updated as resubmission\");\n            return applications[applicationIndex];\n        }\n    }\n    // Check if job has reached worker limit\n    const acceptedApplications = existingApplications.filter((app)=>app.status === \"accepted\");\n    const workersNeeded = job.workersNeeded || job.maxWorkers || 1;\n    if (acceptedApplications.length >= workersNeeded) {\n        throw new Error(`This job has already reached its worker limit of ${workersNeeded} workers`);\n    }\n    console.log(\"[v0] âœ… WORKER VALIDATION: New application allowed\");\n    console.log(\"[v0] ðŸ“Š WORKER VALIDATION: Current accepted workers:\", acceptedApplications.length, \"/ Needed:\", workersNeeded);\n    // Get user data for application\n    const { getAllUsers } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./auth */ \"(ssr)/./lib/auth.ts\"));\n    const users = getAllUsers();\n    const user = users.find((u)=>u.id === data.applicantId);\n    if (!user) {\n        throw new Error(\"User not found\");\n    }\n    const newApplication = {\n        id: `app_${Date.now()}`,\n        jobId: data.jobId,\n        applicantId: data.applicantId,\n        coverLetter: data.coverLetter,\n        proposedBudget: data.proposedBudget,\n        estimatedDuration: data.estimatedDuration,\n        portfolioLinks: data.portfolioLinks,\n        status: \"pending\",\n        createdAt: new Date().toISOString(),\n        applicant: {\n            id: user.id,\n            firstName: user.firstName,\n            lastName: user.lastName,\n            username: user.username,\n            avatar: user.avatar,\n            rating: user.rating,\n            totalReviews: user.totalReviews,\n            skills: user.skills\n        }\n    };\n    const applications = getStoredApplications();\n    applications.push(newApplication);\n    saveApplications(applications);\n    // Update job application count\n    const jobIndex = jobs.findIndex((j)=>j.id === data.jobId);\n    if (jobIndex !== -1) {\n        jobs[jobIndex].applicationsCount = (jobs[jobIndex].applicationsCount || 0) + 1;\n        saveJobs(jobs);\n    }\n    // Create notification for job poster\n    const { createNotification } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./notifications */ \"(ssr)/./lib/notifications.ts\"));\n    await createNotification({\n        userId: job.userId,\n        type: \"job\",\n        title: \"New Job Application\",\n        description: `${user.firstName} ${user.lastName} applied for your job \"${job.title}\"`,\n        actionUrl: `/dashboard/jobs/${job.id}/applications`\n    });\n    return newApplication;\n}\nasync function createJob(data) {\n    await new Promise((resolve)=>setTimeout(resolve, 800));\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Starting job creation process\");\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Workers needed:\", data.workersNeeded);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Budget per worker:\", data.budgetMin, \"-\", data.budgetMax);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Screenshot requirements:\", data.requireScreenshots || 0);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Approval type:\", data.approvalType);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Manual approval days:\", data.manualApprovalDays);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Country restrictions enabled:\", data.enableCountryRestrictions);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Restriction type:\", data.restrictionType);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Allowed countries:\", data.allowedCountries);\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Restricted countries:\", data.restrictedCountries);\n    const isInstantApproval = data.approvalType === \"instant\";\n    const isInstantApprovalEnabled = ()=>{\n        try {\n            // Check if we're in browser environment\n            if (false) {} else {\n                // On server side or when localStorage is not available, default to true for instant approval requests\n                console.log(\"[v0] ðŸ”§ INSTANT-APPROVAL: Server side or no localStorage, defaulting to true for instant requests\");\n                return isInstantApproval;\n            }\n        } catch (error) {\n            console.error(\"[v0] ðŸ”§ INSTANT-APPROVAL: Error checking setting:\", error);\n            // If there's an error, allow instant approval if user requested it\n            return isInstantApproval;\n        }\n    };\n    const getDefaultManualApprovalDays = ()=>{\n        try {\n            if (false) {}\n            return 3 // Default fallback\n            ;\n        } catch (error) {\n            console.error(\"[v0] ðŸ”§ DEFAULT-DAYS: Error getting default days:\", error);\n            return 3;\n        }\n    };\n    const canUseInstantApproval = isInstantApproval && isInstantApprovalEnabled();\n    const existingJobs = getStoredJobs();\n    const nextJobNumber = existingJobs.length + 1;\n    const formattedJobId = String(nextJobNumber).padStart(3, \"0\");\n    console.log(\"[v0] ðŸ’¼ JOB CREATION: Generated job number:\", nextJobNumber, \"formatted as:\", formattedJobId);\n    const jobStatus = \"approved\" // All jobs are approved immediately, instant payment happens on work submission\n    ;\n    const finalManualApprovalDays = data.manualApprovalDays || getDefaultManualApprovalDays();\n    console.log(\"[v0] ðŸ”§ INSTANT-APPROVAL: User requested instant approval:\", isInstantApproval);\n    console.log(\"[v0] ðŸ”§ INSTANT-APPROVAL: Can use instant approval:\", canUseInstantApproval);\n    console.log(\"[v0] ðŸ”§ INSTANT-APPROVAL: Job status will be:\", jobStatus);\n    console.log(\"[v0] ðŸ”§ MANUAL-APPROVAL: Final manual approval days:\", finalManualApprovalDays);\n    const budgetPerWorker = data.budgetMax || data.budgetMin;\n    const baseJobCost = budgetPerWorker * data.workersNeeded;\n    // Calculate screenshot costs\n    let screenshotCost = 0;\n    if (data.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(ssr)/./lib/screenshot-pricing.ts\"));\n            const screenshotCalculation = await calculateScreenshotCosts(data.requireScreenshots, baseJobCost);\n            screenshotCost = screenshotCalculation.totalScreenshotCost;\n            console.log(\"[v0] ðŸ“¸ JOB CREATION: Screenshot cost calculated:\", screenshotCost);\n        } catch (error) {\n            console.error(\"[v0] ðŸ“¸ JOB CREATION: Error calculating screenshot costs:\", error);\n            // Fallback calculation\n            screenshotCost = data.requireScreenshots * 0.05;\n        }\n    }\n    const subtotal = baseJobCost + screenshotCost;\n    let platformFee = 0;\n    let platformFeeRate = 0.05 // Default fallback\n    ;\n    try {\n        const platformFeeSettings = await (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.getPlatformFeeSettings)();\n        if (platformFeeSettings) {\n            const feeCalculation = (0,_platform_fee__WEBPACK_IMPORTED_MODULE_1__.calculatePlatformFee)(subtotal, platformFeeSettings);\n            platformFee = feeCalculation.platformFee;\n            platformFeeRate = platformFeeSettings.feePercentage / 100;\n            console.log(\"[v0] ðŸ’° JOB CREATION: Using configurable platform fee:\", platformFeeSettings.feePercentage + \"%\");\n        } else {\n            platformFee = subtotal * platformFeeRate;\n            console.log(\"[v0] ðŸ’° JOB CREATION: Using default platform fee: 5%\");\n        }\n    } catch (error) {\n        console.error(\"[v0] ðŸ’° JOB CREATION: Error loading platform fee settings, using default:\", error);\n        platformFee = subtotal * platformFeeRate;\n    }\n    const totalWithFees = subtotal + platformFee;\n    console.log(\"[v0] ðŸ’° JOB CREATION: Base job cost:\", baseJobCost);\n    console.log(\"[v0] ðŸ’° JOB CREATION: Screenshot cost:\", screenshotCost);\n    console.log(\"[v0] ðŸ’° JOB CREATION: Subtotal:\", subtotal);\n    console.log(\"[v0] ðŸ’° JOB CREATION: Platform fee:\", platformFee);\n    console.log(\"[v0] ðŸ’° JOB CREATION: Total with fees:\", totalWithFees);\n    // Check and deduct from user's deposit wallet\n    try {\n        const { getWallet, addWalletTransaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n        const wallet = await getWallet(data.userId);\n        if (wallet.depositBalance < totalWithFees) {\n            throw new Error(`Insufficient deposit balance. Required: $${totalWithFees.toFixed(2)}, Available: $${wallet.depositBalance.toFixed(2)}`);\n        }\n        let transactionDescription = `Job creation deposit for: ${data.title} (${data.workersNeeded} workers Ã— $${budgetPerWorker}`;\n        if (screenshotCost > 0) {\n            transactionDescription += ` + $${screenshotCost.toFixed(2)} screenshot fee`;\n        }\n        transactionDescription += ` + $${platformFee.toFixed(2)} platform fee)`;\n        // Deduct estimated cost from deposit balance\n        await addWalletTransaction({\n            userId: data.userId,\n            type: \"payment\",\n            amount: -totalWithFees,\n            description: transactionDescription,\n            referenceId: `job_${Date.now()}`,\n            referenceType: \"job_creation\",\n            balanceType: \"deposit\"\n        });\n        console.log(\"[v0] âœ… JOB CREATION: Deposit deducted successfully:\", totalWithFees);\n    } catch (error) {\n        console.error(\"[v0] âŒ JOB CREATION: Deposit deduction failed:\", error);\n        throw new Error(`Failed to process job creation deposit: ${error.message}`);\n    }\n    const newJob = {\n        id: `job_${Date.now()}`,\n        jobNumber: nextJobNumber,\n        formattedJobId: formattedJobId,\n        userId: data.userId,\n        categoryId: data.categoryId,\n        subcategoryId: data.subcategoryId,\n        title: data.title,\n        description: data.description,\n        requirements: data.requirements,\n        instructions: data.instructions,\n        budgetMin: data.budgetMin,\n        budgetMax: data.budgetMax,\n        deadline: data.deadline,\n        location: data.location || \"Remote\",\n        isRemote: true,\n        status: jobStatus,\n        priority: \"normal\",\n        skillsRequired: [],\n        applicationsCount: 0,\n        viewsCount: 0,\n        workersNeeded: data.workersNeeded,\n        maxWorkers: data.workersNeeded,\n        tags: data.tags || [],\n        attachments: data.attachments || [],\n        requireScreenshots: data.requireScreenshots || 0,\n        screenshotCost: (data.requireScreenshots || 0) * 0.05,\n        estimatedApprovalDays: data.estimatedApprovalDays || 1,\n        approvalType: data.approvalType || \"manual\",\n        manualApprovalDays: finalManualApprovalDays,\n        isInstantApprovalEnabled: canUseInstantApproval,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        submittedAt: new Date().toISOString(),\n        approvedAt: new Date().toISOString(),\n        approvedBy: \"System\",\n        approvalReason: \"Job approved for posting\",\n        estimatedTotalCost: subtotal,\n        depositDeducted: totalWithFees,\n        enableCountryRestrictions: data.enableCountryRestrictions || false,\n        restrictionType: data.restrictionType || \"include\",\n        allowedCountries: data.allowedCountries || [],\n        restrictedCountries: data.restrictedCountries || [],\n        category: {\n            id: data.categoryId,\n            name: \"Unknown Category\",\n            slug: \"unknown\"\n        }\n    };\n    const jobs = getStoredJobs();\n    jobs.push(newJob);\n    saveJobs(jobs);\n    return newJob;\n}\nasync function toggleJobOn(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Only allow toggle if job was previously approved/open or suspended\n    if (![\n        \"suspended\",\n        \"open\",\n        \"approved\"\n    ].includes(oldStatus)) {\n        throw new Error(\"Job cannot be turned on from current status\");\n    }\n    const updatedJob = await updateJobStatus(jobId, \"open\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"open\", userId, \"Job turned on by owner\", {\n        userAction: \"toggle_on\",\n        instantToggle: true\n    });\n    return updatedJob;\n}\nasync function toggleJobOff(jobId, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 300));\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((j)=>j.id === jobId && j.userId === userId);\n    if (jobIndex === -1) throw new Error(\"Job not found or unauthorized\");\n    const job = jobs[jobIndex];\n    const oldStatus = job.status;\n    // Only allow toggle if job is currently open/approved\n    if (![\n        \"open\",\n        \"approved\"\n    ].includes(oldStatus)) {\n        throw new Error(\"Job cannot be turned off from current status\");\n    }\n    const updatedJob = await updateJobStatus(jobId, \"suspended\", userId);\n    jobs[jobIndex] = updatedJob;\n    saveJobs(jobs);\n    recordStatusChange(jobId, oldStatus, \"suspended\", userId, \"Job turned off by owner\", {\n        userAction: \"toggle_off\",\n        instantToggle: true\n    });\n    return updatedJob;\n}\nasync function updateJobWorkers(jobId, newWorkerCount, userId) {\n    await new Promise((resolve)=>setTimeout(resolve, 500));\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Starting worker count update for job:\", jobId);\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: New worker count:\", newWorkerCount);\n    const jobs = getStoredJobs();\n    const jobIndex = jobs.findIndex((job)=>job.id === jobId && job.userId === userId);\n    if (jobIndex === -1) {\n        console.log(\"[v0] âŒ UPDATE-WORKERS: Job not found or unauthorized\");\n        return {\n            success: false,\n            message: \"Job not found or you don't have permission to modify it.\"\n        };\n    }\n    const job = jobs[jobIndex];\n    const currentWorkerCount = job.workersNeeded;\n    const workerDifference = newWorkerCount - currentWorkerCount;\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Current workers:\", currentWorkerCount);\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Worker difference:\", workerDifference);\n    if (workerDifference === 0) {\n        console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: No change in worker count\");\n        return {\n            success: true,\n            message: \"Worker count unchanged.\"\n        };\n    }\n    if (workerDifference < 0) {\n        console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Reducing worker count - no additional payment needed\");\n        jobs[jobIndex].workersNeeded = newWorkerCount;\n        localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n        console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Updated job saved to localStorage with key:\", JOBS_STORAGE_KEY);\n        return {\n            success: true,\n            message: `Worker count reduced to ${newWorkerCount}.`\n        };\n    }\n    const costPerWorker = job.budgetMax || job.budgetMin || 0;\n    const additionalBaseCost = workerDifference * costPerWorker;\n    // Calculate additional screenshot costs proportionally\n    let additionalScreenshotCost = 0;\n    if (job.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(ssr)/./lib/screenshot-pricing.ts\"));\n            // Calculate screenshot cost for new total workers\n            const newTotalBaseCost = newWorkerCount * costPerWorker;\n            // Calculate current screenshot cost for comparison\n            const currentTotalBaseCost = currentWorkerCount * costPerWorker;\n            const currentScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, currentTotalBaseCost)).totalScreenshotCost;\n            const newScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, newTotalBaseCost)).totalScreenshotCost;\n            additionalScreenshotCost = newScreenshotCost - currentScreenshotCost;\n            console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Additional screenshot cost:\", additionalScreenshotCost);\n        } catch (error) {\n            console.error(\"[v0] âŒ UPDATE-WORKERS: Error calculating screenshot costs:\", error);\n        }\n    }\n    const platformFeeRate = 0.05;\n    const subtotal = additionalBaseCost + additionalScreenshotCost;\n    const platformFee = subtotal * platformFeeRate;\n    const totalAdditionalCost = subtotal + platformFee;\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Cost breakdown:\", {\n        additionalBaseCost,\n        additionalScreenshotCost,\n        platformFee,\n        totalAdditionalCost\n    });\n    const { getWallet } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n    // Check wallet balance\n    const wallet = await getWallet(userId);\n    if (wallet.depositBalance < totalAdditionalCost) {\n        console.log(\"[v0] âŒ UPDATE-WORKERS: Insufficient balance\");\n        return {\n            success: false,\n            message: `Insufficient deposit balance. Required: $${totalAdditionalCost.toFixed(2)}, Available: $${wallet.depositBalance.toFixed(2)}`\n        };\n    }\n    const { addWalletTransaction } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./wallet */ \"(ssr)/./lib/wallet.ts\"));\n    let transactionDescription = `Additional workers for job: ${job.title} (+${workerDifference} workers)`;\n    if (additionalScreenshotCost > 0) {\n        transactionDescription += ` + $${additionalScreenshotCost.toFixed(2)} screenshot fee`;\n    }\n    transactionDescription += ` + $${platformFee.toFixed(2)} platform fee)`;\n    // Deduct from wallet\n    await addWalletTransaction({\n        userId: userId,\n        type: \"payment\",\n        amount: -totalAdditionalCost,\n        description: transactionDescription,\n        referenceId: jobId,\n        referenceType: \"worker_update\",\n        balanceType: \"deposit\"\n    });\n    const newTotalBaseCost = newWorkerCount * costPerWorker;\n    let newTotalScreenshotCost = 0;\n    if (job.requireScreenshots > 0) {\n        try {\n            const { calculateScreenshotCosts } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./screenshot-pricing */ \"(ssr)/./lib/screenshot-pricing.ts\"));\n            newTotalScreenshotCost = (await calculateScreenshotCosts(job.requireScreenshots, newTotalBaseCost)).totalScreenshotCost;\n        } catch (error) {\n            console.error(\"[v0] Error recalculating total screenshot costs:\", error);\n        }\n    }\n    const newSubtotal = newTotalBaseCost + newTotalScreenshotCost;\n    const newPlatformFee = newSubtotal * platformFeeRate;\n    const newTotalCost = newSubtotal + newPlatformFee;\n    jobs[jobIndex] = {\n        ...job,\n        workersNeeded: newWorkerCount,\n        estimatedTotalCost: newTotalCost\n    };\n    localStorage.setItem(JOBS_STORAGE_KEY, JSON.stringify(jobs));\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: Updated job saved to localStorage with key:\", JOBS_STORAGE_KEY);\n    console.log(\"[v0] âœ… UPDATE-WORKERS: Worker count updated successfully\");\n    console.log(\"[v0] ðŸ‘¥ UPDATE-WORKERS: New total cost:\", newTotalCost.toFixed(2));\n    return {\n        success: true,\n        message: `Worker count updated to ${newWorkerCount}. Additional cost: $${totalAdditionalCost.toFixed(2)}`,\n        additionalCost: totalAdditionalCost\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OlsiL2hvbWUvcHJvamVjdC9saWIvam9icy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBKb2ItcmVsYXRlZCB0eXBlcyBhbmQgbW9jayBkYXRhXG5leHBvcnQgaW50ZXJmYWNlIEpvYiB7XG4gIGlkOiBzdHJpbmdcbiAgdXNlcklkOiBzdHJpbmdcbiAgY2F0ZWdvcnlJZDogc3RyaW5nXG4gIHN1YmNhdGVnb3J5SWQ/OiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHJlcXVpcmVtZW50cz86IHN0cmluZ1xuICBpbnN0cnVjdGlvbnM/OiBzdHJpbmdcbiAgYnVkZ2V0TWluOiBudW1iZXJcbiAgYnVkZ2V0TWF4OiBudW1iZXJcbiAgZGVhZGxpbmU6IHN0cmluZ1xuICBsb2NhdGlvbjogc3RyaW5nXG4gIGlzUmVtb3RlOiBib29sZWFuXG4gIHN0YXR1czogXCJwZW5kaW5nXCIgfCBcImFwcHJvdmVkXCIgfCBcInJlamVjdGVkXCIgfCBcInN1c3BlbmRlZFwiIHwgXCJvcGVuXCIgfCBcImluX3Byb2dyZXNzXCIgfCBcImNvbXBsZXRlZFwiIHwgXCJjYW5jZWxsZWRcIlxuICBwcmlvcml0eTogXCJsb3dcIiB8IFwibm9ybWFsXCIgfCBcImhpZ2hcIiB8IFwidXJnZW50XCJcbiAgc2tpbGxzUmVxdWlyZWQ6IHN0cmluZ1tdXG4gIGFwcGxpY2F0aW9uc0NvdW50OiBudW1iZXJcbiAgdmlld3NDb3VudDogbnVtYmVyXG4gIHdvcmtlcnNOZWVkZWQ/OiBudW1iZXJcbiAgZHVyYXRpb24/OiBzdHJpbmdcbiAgZHVyYXRpb25UeXBlPzogc3RyaW5nXG4gIHRhZ3M/OiBzdHJpbmdbXVxuICBhdHRhY2htZW50cz86IHN0cmluZ1tdXG4gIHRodW1ibmFpbD86IHN0cmluZ1xuICByZXF1aXJlU2NyZWVuc2hvdHM/OiBudW1iZXJcbiAgc2NyZWVuc2hvdENvc3Q/OiBudW1iZXJcbiAgZXN0aW1hdGVkQXBwcm92YWxEYXlzPzogbnVtYmVyXG4gIHJlcXVpcmVkUHJvb2Y/OiBzdHJpbmdcbiAgc3VibWl0dGVkQXQ6IHN0cmluZ1xuICBhcHByb3ZlZEF0Pzogc3RyaW5nXG4gIGFwcHJvdmVkQnk/OiBzdHJpbmdcbiAgYXBwcm92YWxSZWFzb24/OiBzdHJpbmdcbiAgcmVqZWN0ZWRBdD86IHN0cmluZ1xuICByZWplY3RlZEJ5Pzogc3RyaW5nXG4gIHJlamVjdGlvblJlYXNvbj86IHN0cmluZ1xuICBzdXNwZW5kZWRBdD86IHN0cmluZ1xuICBzdXNwZW5kZWRCeT86IHN0cmluZ1xuICBjb21wbGV0ZWRBdD86IHN0cmluZ1xuICBjcmVhdGVkQXQ6IHN0cmluZ1xuICB1cGRhdGVkQXQ6IHN0cmluZ1xuICBlbmFibGVDb3VudHJ5UmVzdHJpY3Rpb25zPzogYm9vbGVhblxuICByZXN0cmljdGlvblR5cGU/OiBcImluY2x1ZGVcIiB8IFwiZXhjbHVkZVwiXG4gIGFsbG93ZWRDb3VudHJpZXM/OiBzdHJpbmdbXVxuICByZXN0cmljdGVkQ291bnRyaWVzPzogc3RyaW5nW11cbiAgY2F0ZWdvcnk6IHtcbiAgICBpZDogc3RyaW5nXG4gICAgbmFtZTogc3RyaW5nXG4gICAgc2x1Zzogc3RyaW5nXG4gIH1cbiAgc3ViY2F0ZWdvcnk/OiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNsdWc6IHN0cmluZ1xuICAgIHRodW1ibmFpbD86IHN0cmluZ1xuICB9XG4gIHBvc3Rlcjoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gICAgYXZhdGFyPzogc3RyaW5nXG4gICAgcmF0aW5nOiBudW1iZXJcbiAgICB0b3RhbFJldmlld3M6IG51bWJlclxuICB9XG4gIGFzc2lnbmVkV29ya2VySWQ/OiBzdHJpbmcgLy8gTmV3IGZpZWxkIGZvciBhc3NpZ25lZCB3b3JrZXIgSURcbiAgcGF5bWVudFR5cGU/OiBzdHJpbmdcbiAgY2F0ZWdvcnlUaHVtYm5haWw/OiBzdHJpbmdcbiAgYXBwcm92YWxUeXBlPzogc3RyaW5nXG4gIG1hbnVhbEFwcHJvdmFsRGF5cz86IG51bWJlclxuICBpc0luc3RhbnRBcHByb3ZhbEVuYWJsZWQ/OiBib29sZWFuXG4gIGVzdGltYXRlZFRvdGFsQ29zdD86IG51bWJlclxuICBkZXBvc2l0RGVkdWN0ZWQ/OiBudW1iZXJcbiAgY2FuY2VsbGF0aW9uRGV0YWlscz86IHtcbiAgICBjYW5jZWxsZWRBdDogc3RyaW5nXG4gICAgc3VibWl0dGVkV29ya0NvdW50OiBudW1iZXJcbiAgICByZW1haW5pbmdTbG90czogbnVtYmVyXG4gICAgcmVmdW5kQW1vdW50OiBudW1iZXJcbiAgICBjYW5SZXZpZXdTdWJtaXNzaW9uczogYm9vbGVhblxuICB9XG4gIGpvYk51bWJlcj86IG51bWJlclxuICBmb3JtYXR0ZWRKb2JJZD86IHN0cmluZ1xuICBtYXhXb3JrZXJzPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9iQXBwbGljYXRpb24ge1xuICBpZDogc3RyaW5nXG4gIGpvYklkOiBzdHJpbmdcbiAgYXBwbGljYW50SWQ6IHN0cmluZ1xuICBjb3ZlckxldHRlcjogc3RyaW5nXG4gIHByb3Bvc2VkQnVkZ2V0OiBudW1iZXJcbiAgZXN0aW1hdGVkRHVyYXRpb246IHN0cmluZ1xuICBwb3J0Zm9saW9MaW5rczogc3RyaW5nW11cbiAgc3RhdHVzOiBcInBlbmRpbmdcIiB8IFwiYWNjZXB0ZWRcIiB8IFwicmVqZWN0ZWRcIiB8IFwiY29tcGxldGVkXCJcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgYXBwbGljYW50OiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgIHVzZXJuYW1lOiBzdHJpbmdcbiAgICBhdmF0YXI/OiBzdHJpbmdcbiAgICByYXRpbmc6IG51bWJlclxuICAgIHRvdGFsUmV2aWV3czogbnVtYmVyXG4gICAgc2tpbGxzOiBzdHJpbmdbXVxuICB9XG4gIGpvYj86IEpvYlxuICBhcHBsaWVkQXQ/OiBzdHJpbmdcbiAgYWNjZXB0ZWRBdD86IHN0cmluZ1xuICBhY2NlcHRlZEJ5Pzogc3RyaW5nXG4gIHJlamVjdGVkQXQ/OiBzdHJpbmdcbiAgcmVqZWN0ZWRCeT86IHN0cmluZ1xuICByZWplY3Rpb25SZWFzb24/OiBzdHJpbmdcbiAgcmVzdWJtaXNzaW9uQ291bnQ/OiBudW1iZXJcbn1cblxuLy8gTmV3IGludGVyZmFjZXMgZm9yIGVuaGFuY2VkIHdvcmsgcHJvb2Ygc3lzdGVtXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtQcm9vZiB7XG4gIGlkOiBzdHJpbmdcbiAgam9iSWQ6IHN0cmluZ1xuICBhcHBsaWNhdGlvbklkOiBzdHJpbmdcbiAgd29ya2VySWQ6IHN0cmluZ1xuICBlbXBsb3llcklkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIHN1Ym1pc3Npb25UZXh0OiBzdHJpbmdcbiAgcHJvb2ZGaWxlczogc3RyaW5nW10gLy8gVVJMcyB0byB1cGxvYWRlZCBmaWxlc1xuICBwcm9vZkxpbmtzOiBzdHJpbmdbXSAvLyBFeHRlcm5hbCBVUkxzIChZb3VUdWJlLCBzb2NpYWwgbWVkaWEsIGV0Yy4pXG4gIHNjcmVlbnNob3RzOiBzdHJpbmdbXVxuICBhdHRhY2htZW50czogc3RyaW5nW11cbiAgYWRkaXRpb25hbE5vdGVzPzogc3RyaW5nXG4gIHN1Ym1pc3Npb25OdW1iZXI6IG51bWJlclxuICBzdGF0dXM6IFwic3VibWl0dGVkXCIgfCBcInVuZGVyX3Jldmlld1wiIHwgXCJhY2NlcHRlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJyZXZpc2lvbl9yZXF1ZXN0ZWRcIiB8IFwiYXBwcm92ZWRcIlxuICBzdWJtaXR0ZWRBdDogc3RyaW5nXG4gIGFwcHJvdmVkQXQ/OiBzdHJpbmdcbiAgYXBwcm92ZWRCeT86IHN0cmluZ1xuICBwYXltZW50QW1vdW50PzogbnVtYmVyXG4gIHBheW1lbnRQcm9jZXNzZWRBdD86IHN0cmluZ1xuICBwYXltZW50RXJyb3I/OiBzdHJpbmdcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgdXBkYXRlZEF0OiBzdHJpbmdcbiAgd29ya2VyPzoge1xuICAgIGlkOiBzdHJpbmdcbiAgICBmaXJzdE5hbWU6IHN0cmluZ1xuICAgIGxhc3ROYW1lOiBzdHJpbmdcbiAgICB1c2VybmFtZTogc3RyaW5nXG4gICAgYXZhdGFyPzogc3RyaW5nXG4gIH1cbiAgZW1wbG95ZXI/OiB7XG4gICAgaWQ6IHN0cmluZ1xuICAgIGZpcnN0TmFtZTogc3RyaW5nXG4gICAgbGFzdE5hbWU6IHN0cmluZ1xuICAgIHVzZXJuYW1lOiBzdHJpbmdcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpvYlJldmlldyB7XG4gIGlkOiBzdHJpbmdcbiAgam9iSWQ6IHN0cmluZ1xuICBwcm9vZklkOiBzdHJpbmdcbiAgcmV2aWV3ZXJJZDogc3RyaW5nXG4gIGRlY2lzaW9uOiBcImFjY2VwdGVkXCIgfCBcInJlamVjdGVkXCIgfCBcInJldmlzaW9uX3JlcXVlc3RlZFwiXG4gIGZlZWRiYWNrPzogc3RyaW5nXG4gIHJldmlzaW9uTm90ZXM/OiBzdHJpbmdcbiAgcmV2aWV3ZWRBdDogc3RyaW5nXG59XG5cbi8vIEpvYiBzdGF0dXMgaGlzdG9yeSBpbnRlcmZhY2UgZm9yIHRyYWNraW5nIHdvcmtmbG93IGNoYW5nZXNcbmV4cG9ydCBpbnRlcmZhY2UgSm9iU3RhdHVzSGlzdG9yeSB7XG4gIGlkOiBzdHJpbmdcbiAgam9iSWQ6IHN0cmluZ1xuICB1c2VySWQ/OiBzdHJpbmdcbiAgb2xkU3RhdHVzPzogc3RyaW5nXG4gIG5ld1N0YXR1czogc3RyaW5nXG4gIG5vdGVzPzogc3RyaW5nXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBjcmVhdGVkQXQ6IHN0cmluZ1xufVxuXG5jb25zdCBKT0JTX1NUT1JBR0VfS0VZID0gXCJtYXJrZXRwbGFjZS1qb2JzXCJcbmNvbnN0IEFQUExJQ0FUSU9OU19TVE9SQUdFX0tFWSA9IFwibWFya2V0cGxhY2UtYXBwbGljYXRpb25zXCJcbmNvbnN0IFdPUktfUFJPT0ZTX1NUT1JBR0VfS0VZID0gXCJtYXJrZXRwbGFjZS13b3JrLXByb29mc1wiXG5jb25zdCBKT0JfUkVWSUVXU19TVE9SQUdFX0tFWSA9IFwibWFya2V0cGxhY2Utam9iLXJldmlld3NcIlxuY29uc3QgSk9CX1NUQVRVU19ISVNUT1JZX1NUT1JBR0VfS0VZID0gXCJtYXJrZXRwbGFjZS1qb2Itc3RhdHVzLWhpc3RvcnlcIlxuXG5jb25zdCBnZXRTdG9yZWRKb2JzID0gKCk6IEpvYltdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEpPQlNfU1RPUkFHRV9LRVkpXG4gICAgaWYgKHN0b3JlZCkge1xuICAgICAgY29uc3Qgam9icyA9IEpTT04ucGFyc2Uoc3RvcmVkKVxuICAgICAgcmV0dXJuIGpvYnNcbiAgICB9XG4gICAgcmV0dXJuIFtdXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmNvbnN0IHNhdmVKb2JzID0gKGpvYnM6IEpvYltdKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShKT0JTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShqb2JzKSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgam9iczpcIiwgZXJyb3IpXG4gIH1cbn1cblxuY29uc3QgZ2V0U3RvcmVkQXBwbGljYXRpb25zID0gKCk6IEpvYkFwcGxpY2F0aW9uW10gPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFtdXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oQVBQTElDQVRJT05TX1NUT1JBR0VfS0VZKVxuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBzYXZlQXBwbGljYXRpb25zID0gKGFwcGxpY2F0aW9uczogSm9iQXBwbGljYXRpb25bXSk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQVBQTElDQVRJT05TX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShhcHBsaWNhdGlvbnMpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBhcHBsaWNhdGlvbnM6XCIsIGVycm9yKVxuICB9XG59XG5cbmNvbnN0IGdldFN0b3JlZFdvcmtQcm9vZnMgPSAoKTogV29ya1Byb29mW10gPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFtdXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oV09SS19QUk9PRlNfU1RPUkFHRV9LRVkpXG4gICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IFtdXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmNvbnN0IHNhdmVXb3JrUHJvb2ZzID0gKHdvcmtQcm9vZnM6IFdvcmtQcm9vZltdKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm5cbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShXT1JLX1BST09GU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkod29ya1Byb29mcykpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHdvcmsgcHJvb2ZzOlwiLCBlcnJvcilcbiAgfVxufVxuXG5jb25zdCBnZXRTdG9yZWRKb2JSZXZpZXdzID0gKCk6IEpvYlJldmlld1tdID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBbXVxuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKEpPQl9SRVZJRVdTX1NUT1JBR0VfS0VZKVxuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBzYXZlSm9iUmV2aWV3cyA9IChyZXZpZXdzOiBKb2JSZXZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oSk9CX1JFVklFV1NfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHJldmlld3MpKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBqb2IgcmV2aWV3czpcIiwgZXJyb3IpXG4gIH1cbn1cblxuLy8gU3RvcmFnZSBmdW5jdGlvbnMgZm9yIGpvYiBzdGF0dXMgaGlzdG9yeVxuY29uc3QgZ2V0U3RvcmVkSm9iU3RhdHVzSGlzdG9yeSA9ICgpOiBKb2JTdGF0dXNIaXN0b3J5W10gPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIFtdXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oSk9CX1NUQVRVU19ISVNUT1JZX1NUT1JBR0VfS0VZKVxuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiBbXVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5jb25zdCBzYXZlSm9iU3RhdHVzSGlzdG9yeSA9IChoaXN0b3J5OiBKb2JTdGF0dXNIaXN0b3J5W10pOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEpPQl9TVEFUVVNfSElTVE9SWV9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIGpvYiBzdGF0dXMgaGlzdG9yeTpcIiwgZXJyb3IpXG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gcmVjb3JkIHN0YXR1cyBjaGFuZ2VzXG5jb25zdCByZWNvcmRTdGF0dXNDaGFuZ2UgPSAoXG4gIGpvYklkOiBzdHJpbmcsXG4gIG9sZFN0YXR1czogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBuZXdTdGF0dXM6IHN0cmluZyxcbiAgdXNlcklkPzogc3RyaW5nLFxuICBub3Rlcz86IHN0cmluZyxcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuKTogdm9pZCA9PiB7XG4gIGNvbnN0IGhpc3RvcnkgPSBnZXRTdG9yZWRKb2JTdGF0dXNIaXN0b3J5KClcbiAgY29uc3Qgc3RhdHVzRW50cnk6IEpvYlN0YXR1c0hpc3RvcnkgPSB7XG4gICAgaWQ6IGBzdGF0dXNfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgIGpvYklkLFxuICAgIHVzZXJJZCxcbiAgICBvbGRTdGF0dXMsXG4gICAgbmV3U3RhdHVzLFxuICAgIG5vdGVzLFxuICAgIG1ldGFkYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgaGlzdG9yeS5wdXNoKHN0YXR1c0VudHJ5KVxuICBzYXZlSm9iU3RhdHVzSGlzdG9yeShoaXN0b3J5KVxuXG4gIGNvbnNvbGUubG9nKGBbdjBdIFN0YXR1cyBjaGFuZ2UgcmVjb3JkZWQgZm9yIGpvYiAke2pvYklkfTogJHtvbGRTdGF0dXN9IC0+ICR7bmV3U3RhdHVzfWApXG59XG5cbmltcG9ydCB7IGdldFN1YmNhdGVnb3J5QnlJZCwgZ2V0Q2F0ZWdvcnlCeUlkIH0gZnJvbSBcIi4vY2F0ZWdvcmllc1wiXG5pbXBvcnQgeyBnZXRQbGF0Zm9ybUZlZVNldHRpbmdzLCBjYWxjdWxhdGVQbGF0Zm9ybUZlZSB9IGZyb20gXCIuL3BsYXRmb3JtLWZlZVwiXG5cbmltcG9ydCB7IGxvY2FsUmVzZXJ2YXRpb25TdG9yYWdlIH0gZnJvbSBcIi4vbG9jYWwtcmVzZXJ2YXRpb24tc3RvcmFnZVwiXG5cbmFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlSm9iQ2F0ZWdvcnlEYXRhKGpvYjogSm9iKTogUHJvbWlzZTxKb2I+IHtcbiAgY29uc29sZS5sb2coXG4gICAgXCJbdjBdIFBvcHVsYXRpbmcgY2F0ZWdvcnkgZGF0YSBmb3Igam9iOlwiLFxuICAgIGpvYi50aXRsZSxcbiAgICBcImNhdGVnb3J5SWQ6XCIsXG4gICAgam9iLmNhdGVnb3J5SWQsXG4gICAgXCJzdWJjYXRlZ29yeUlkOlwiLFxuICAgIGpvYi5zdWJjYXRlZ29yeUlkLFxuICApXG4gIGNvbnN0IHBvcHVsYXRlZEpvYiA9IHsgLi4uam9iIH1cblxuICBpZiAoIXBvcHVsYXRlZEpvYi5jYXRlZ29yeT8udGh1bWJuYWlsICYmIHBvcHVsYXRlZEpvYi5jYXRlZ29yeUlkKSB7XG4gICAgY29uc3QgZnVsbENhdGVnb3J5ID0gYXdhaXQgZ2V0Q2F0ZWdvcnlCeUlkKHBvcHVsYXRlZEpvYi5jYXRlZ29yeUlkKVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBMb2FkZWQgY2F0ZWdvcnk6XCIsIGZ1bGxDYXRlZ29yeT8ubmFtZSwgXCJ0aHVtYm5haWw6XCIsIGZ1bGxDYXRlZ29yeT8udGh1bWJuYWlsKVxuICAgIGlmIChmdWxsQ2F0ZWdvcnkpIHtcbiAgICAgIHBvcHVsYXRlZEpvYi5jYXRlZ29yeSA9IHtcbiAgICAgICAgaWQ6IGZ1bGxDYXRlZ29yeS5pZCxcbiAgICAgICAgbmFtZTogZnVsbENhdGVnb3J5Lm5hbWUsXG4gICAgICAgIHNsdWc6IGZ1bGxDYXRlZ29yeS5zbHVnLFxuICAgICAgICB0aHVtYm5haWw6IGZ1bGxDYXRlZ29yeS50aHVtYm5haWwsXG4gICAgICB9XG4gICAgICBwb3B1bGF0ZWRKb2IuY2F0ZWdvcnlUaHVtYm5haWwgPSBmdWxsQ2F0ZWdvcnkudGh1bWJuYWlsXG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBzdWJjYXRlZ29yeSBkYXRhIGlmIHN1YmNhdGVnb3J5SWQgZXhpc3RzXG4gIGlmIChwb3B1bGF0ZWRKb2Iuc3ViY2F0ZWdvcnlJZCkge1xuICAgIGNvbnN0IHN1YmNhdGVnb3J5ID0gYXdhaXQgZ2V0U3ViY2F0ZWdvcnlCeUlkKHBvcHVsYXRlZEpvYi5zdWJjYXRlZ29yeUlkKVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSBMb2FkZWQgc3ViY2F0ZWdvcnk6XCIsIHN1YmNhdGVnb3J5Py5uYW1lLCBcInRodW1ibmFpbDpcIiwgc3ViY2F0ZWdvcnk/LnRodW1ibmFpbClcbiAgICBpZiAoc3ViY2F0ZWdvcnkpIHtcbiAgICAgIHBvcHVsYXRlZEpvYi5zdWJjYXRlZ29yeSA9IHN1YmNhdGVnb3J5XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5sb2coXCJbdjBdIEZpbmFsIGpvYiBkYXRhOlwiLCB7XG4gICAgdGl0bGU6IHBvcHVsYXRlZEpvYi50aXRsZSxcbiAgICBjYXRlZ29yeVRodW1ibmFpbDogcG9wdWxhdGVkSm9iLmNhdGVnb3J5VGh1bWJuYWlsLFxuICAgIHN1YmNhdGVnb3J5OiBwb3B1bGF0ZWRKb2Iuc3ViY2F0ZWdvcnk/Lm5hbWUsXG4gICAgc3ViY2F0ZWdvcnlUaHVtYm5haWw6IHBvcHVsYXRlZEpvYi5zdWJjYXRlZ29yeT8udGh1bWJuYWlsLFxuICB9KVxuXG4gIHJldHVybiBwb3B1bGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEpvYnMoZmlsdGVycz86IHtcbiAgY2F0ZWdvcnk/OiBzdHJpbmdcbiAgbG9jYXRpb24/OiBzdHJpbmdcbiAgYnVkZ2V0PzogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfVxuICByZW1vdGU/OiBib29sZWFuXG4gIHNlYXJjaD86IHN0cmluZ1xufSk6IFByb21pc2U8Sm9iW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcblxuICBsZXQgZmlsdGVyZWRKb2JzID0gZ2V0U3RvcmVkSm9icygpLmZpbHRlcigoam9iKSA9PiBqb2Iuc3RhdHVzID09PSBcImFwcHJvdmVkXCIgfHwgam9iLnN0YXR1cyA9PT0gXCJvcGVuXCIpXG5cbiAgaWYgKGZpbHRlcnM/LnNlYXJjaCkge1xuICAgIGZpbHRlcmVkSm9icyA9IGZpbHRlcmVkSm9icy5maWx0ZXIoXG4gICAgICAoam9iKSA9PlxuICAgICAgICBqb2IudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLnNlYXJjaCEudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgam9iLmRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVycy5zZWFyY2ghLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgIGpvYi5za2lsbHNSZXF1aXJlZC5zb21lKChza2lsbCkgPT4gc2tpbGwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLnNlYXJjaCEudG9Mb3dlckNhc2UoKSkpLFxuICAgIClcbiAgfVxuXG4gIGlmIChmaWx0ZXJzPy5jYXRlZ29yeSkge1xuICAgIGZpbHRlcmVkSm9icyA9IGZpbHRlcmVkSm9icy5maWx0ZXIoKGpvYikgPT4gam9iLmNhdGVnb3J5LnNsdWcgPT09IGZpbHRlcnMuY2F0ZWdvcnkpXG4gIH1cblxuICBpZiAoZmlsdGVycz8ucmVtb3RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBmaWx0ZXJlZEpvYnMgPSBmaWx0ZXJlZEpvYnMuZmlsdGVyKChqb2IpID0+IGpvYi5pc1JlbW90ZSA9PT0gZmlsdGVycy5yZW1vdGUpXG4gIH1cblxuICBpZiAoZmlsdGVycz8uYnVkZ2V0KSB7XG4gICAgZmlsdGVyZWRKb2JzID0gZmlsdGVyZWRKb2JzLmZpbHRlcihcbiAgICAgIChqb2IpID0+IGpvYi5idWRnZXRNYXggPj0gZmlsdGVycy5idWRnZXQhLm1pbiAmJiBqb2IuYnVkZ2V0TWluIDw9IGZpbHRlcnMuYnVkZ2V0IS5tYXgsXG4gICAgKVxuICB9XG5cbiAgaWYgKGZpbHRlcnM/LmxvY2F0aW9uICYmIGZpbHRlcnMubG9jYXRpb24gIT09IFwiYWxsXCIpIHtcbiAgICBmaWx0ZXJlZEpvYnMgPSBmaWx0ZXJlZEpvYnMuZmlsdGVyKChqb2IpID0+IGpvYi5sb2NhdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcnMubG9jYXRpb24hLnRvTG93ZXJDYXNlKCkpKVxuICB9XG5cbiAgY29uc3Qgc29ydGVkSm9icyA9IGZpbHRlcmVkSm9icy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSlcblxuICBjb25zdCBwb3B1bGF0ZWRKb2JzID0gYXdhaXQgUHJvbWlzZS5hbGwoc29ydGVkSm9icy5tYXAocG9wdWxhdGVKb2JDYXRlZ29yeURhdGEpKVxuXG4gIHJldHVybiBwb3B1bGF0ZWRKb2JzXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRKb2JCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPEpvYiB8IG51bGw+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2IgPSBqb2JzLmZpbmQoKGpvYikgPT4gam9iLmlkID09PSBpZClcblxuICBpZiAoam9iKSB7XG4gICAgLy8gSW5jcmVtZW50IHZpZXcgY291bnRcbiAgICBqb2Iudmlld3NDb3VudCA9IChqb2Iudmlld3NDb3VudCB8fCAwKSArIDFcbiAgICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBpZClcbiAgICBpZiAoam9iSW5kZXggIT09IC0xKSB7XG4gICAgICBqb2JzW2pvYkluZGV4XSA9IGpvYlxuICAgICAgc2F2ZUpvYnMoam9icylcbiAgICB9XG5cbiAgICBjb25zdCB7IGdldEFsbFVzZXJzIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2F1dGhcIilcbiAgICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgICBjb25zdCBwb3N0ZXJVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gam9iLnVzZXJJZClcblxuICAgIGlmIChwb3N0ZXJVc2VyKSB7XG4gICAgICBqb2IucG9zdGVyID0ge1xuICAgICAgICBpZDogcG9zdGVyVXNlci5pZCxcbiAgICAgICAgZmlyc3ROYW1lOiBwb3N0ZXJVc2VyLmZpcnN0TmFtZSxcbiAgICAgICAgbGFzdE5hbWU6IHBvc3RlclVzZXIubGFzdE5hbWUsXG4gICAgICAgIHVzZXJuYW1lOiBwb3N0ZXJVc2VyLnVzZXJuYW1lLFxuICAgICAgICBhdmF0YXI6IHBvc3RlclVzZXIuYXZhdGFyLFxuICAgICAgICByYXRpbmc6IDQuNSwgLy8gVE9ETzogQ2FsY3VsYXRlIGZyb20gYWN0dWFsIHJldmlld3NcbiAgICAgICAgdG90YWxSZXZpZXdzOiAwLCAvLyBUT0RPOiBDb3VudCBmcm9tIGFjdHVhbCByZXZpZXdzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHBvcHVsYXRlSm9iQ2F0ZWdvcnlEYXRhKGpvYilcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRKb2JBcHBsaWNhdGlvbnMoam9iSWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iQXBwbGljYXRpb25bXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICByZXR1cm4gYXBwbGljYXRpb25zLmZpbHRlcigoYXBwKSA9PiBhcHAuam9iSWQgPT09IGpvYklkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0Sm9iQXBwbGljYXRpb24oZGF0YToge1xuICBqb2JJZDogc3RyaW5nXG4gIGNvdmVyTGV0dGVyOiBzdHJpbmdcbiAgcHJvcG9zZWRCdWRnZXQ6IG51bWJlclxuICBlc3RpbWF0ZWREdXJhdGlvbjogc3RyaW5nXG4gIHBvcnRmb2xpb0xpbmtzOiBzdHJpbmdbXVxuICB1c2VySWQ/OiBzdHJpbmdcbn0pOiBQcm9taXNlPEpvYkFwcGxpY2F0aW9uPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgaWYgKCFkYXRhLnVzZXJJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgSUQgaXMgcmVxdWlyZWQgdG8gc3VibWl0IGFwcGxpY2F0aW9uXCIpXG4gIH1cblxuICBpZiAoIWRhdGEuY292ZXJMZXR0ZXIudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ292ZXIgbGV0dGVyIGlzIHJlcXVpcmVkXCIpXG4gIH1cblxuICBpZiAoZGF0YS5wcm9wb3NlZEJ1ZGdldCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvcG9zZWQgYnVkZ2V0IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBhcHBsaWVkXG4gIGNvbnN0IGV4aXN0aW5nQXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgY29uc3QgaGFzQXBwbGllZCA9IGV4aXN0aW5nQXBwbGljYXRpb25zLnNvbWUoKGFwcCkgPT4gYXBwLmpvYklkID09PSBkYXRhLmpvYklkICYmIGFwcC5hcHBsaWNhbnRJZCA9PT0gZGF0YS51c2VySWQpXG5cbiAgaWYgKGhhc0FwcGxpZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgaGF2ZSBhbHJlYWR5IGFwcGxpZWQgdG8gdGhpcyBqb2JcIilcbiAgfVxuXG4gIC8vIEdldCB1c2VyIGRhdGEgZm9yIGFwcGxpY2F0aW9uXG4gIGNvbnN0IHsgZ2V0QWxsVXNlcnMgfSA9IGF3YWl0IGltcG9ydChcIi4vYXV0aFwiKVxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlciA9IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGRhdGEudXNlcklkKVxuXG4gIGlmICghdXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBuZXdBcHBsaWNhdGlvbjogSm9iQXBwbGljYXRpb24gPSB7XG4gICAgaWQ6IGBhcHBfJHtEYXRlLm5vdygpfWAsXG4gICAgam9iSWQ6IGRhdGEuam9iSWQsXG4gICAgYXBwbGljYW50SWQ6IGRhdGEudXNlcklkLFxuICAgIGNvdmVyTGV0dGVyOiBkYXRhLmNvdmVyTGV0dGVyLFxuICAgIHByb3Bvc2VkQnVkZ2V0OiBkYXRhLnByb3Bvc2VkQnVkZ2V0LFxuICAgIGVzdGltYXRlZER1cmF0aW9uOiBkYXRhLmVzdGltYXRlZER1cmF0aW9uLFxuICAgIHBvcnRmb2xpb0xpbmtzOiBkYXRhLnBvcnRmb2xpb0xpbmtzLFxuICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgYXBwbGljYW50OiB7XG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGZpcnN0TmFtZTogdXNlci5maXJzdE5hbWUsXG4gICAgICBsYXN0TmFtZTogdXNlci5sYXN0TmFtZSxcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgcmF0aW5nOiA0LjUsIC8vIERlZmF1bHQgcmF0aW5nIGZvciBuZXcgdXNlcnNcbiAgICAgIHRvdGFsUmV2aWV3czogMCxcbiAgICAgIHNraWxsczogW1wiR2VuZXJhbFwiXSwgLy8gRGVmYXVsdCBza2lsbHNcbiAgICB9LFxuICB9XG5cbiAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgYXBwbGljYXRpb25zLnB1c2gobmV3QXBwbGljYXRpb24pXG4gIHNhdmVBcHBsaWNhdGlvbnMoYXBwbGljYXRpb25zKVxuXG4gIC8vIFVwZGF0ZSBqb2IgYXBwbGljYXRpb24gY291bnRcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBkYXRhLmpvYklkKVxuICBpZiAoam9iSW5kZXggIT09IC0xKSB7XG4gICAgam9ic1tqb2JJbmRleF0uYXBwbGljYXRpb25zQ291bnQgPSAoam9ic1tqb2JJbmRleF0uYXBwbGljYXRpb25zQ291bnQgfHwgMCkgKyAxXG4gICAgc2F2ZUpvYnMoam9icylcbiAgfVxuXG4gIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIGpvYiBwb3N0ZXJcbiAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICBjb25zdCBqb2IgPSBqb2JzLmZpbmQoKGopID0+IGouaWQgPT09IGRhdGEuam9iSWQpXG4gIGlmIChqb2IpIHtcbiAgICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgICAgdXNlcklkOiBqb2IudXNlcklkLFxuICAgICAgdHlwZTogXCJqb2JcIixcbiAgICAgIHRpdGxlOiBcIk5ldyBKb2IgQXBwbGljYXRpb25cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHt1c2VyLmZpcnN0TmFtZX0gJHt1c2VyLmxhc3ROYW1lfSBhcHBsaWVkIGZvciB5b3VyIGpvYiBcIiR7am9iLnRpdGxlfVwiYCxcbiAgICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvam9icy8ke2pvYi5pZH0vYXBwbGljYXRpb25zYCxcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG5ld0FwcGxpY2F0aW9uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRKb2JGb3JBcHByb3ZhbChqb2JEYXRhOiBQYXJ0aWFsPEpvYj4sIHVzZXJJZD86IHN0cmluZyk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgaWYgKCF1c2VySWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIElEIGlzIHJlcXVpcmVkIHRvIHN1Ym1pdCBqb2JcIilcbiAgfVxuXG4gIGlmICgham9iRGF0YS50aXRsZT8udHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSm9iIHRpdGxlIGlzIHJlcXVpcmVkXCIpXG4gIH1cblxuICBpZiAoIWpvYkRhdGEuZGVzY3JpcHRpb24/LnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiBkZXNjcmlwdGlvbiBpcyByZXF1aXJlZFwiKVxuICB9XG5cbiAgaWYgKCFqb2JEYXRhLmJ1ZGdldE1pbiB8fCBqb2JEYXRhLmJ1ZGdldE1pbiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWQgYnVkZ2V0IGlzIHJlcXVpcmVkXCIpXG4gIH1cblxuICBjb25zdCB7IGdldEFsbFVzZXJzIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2F1dGhcIilcbiAgY29uc3QgdXNlcnMgPSBnZXRBbGxVc2VycygpXG4gIGNvbnN0IHVzZXIgPSB1c2Vycy5maW5kKCh1KSA9PiB1LmlkID09PSB1c2VySWQpXG5cbiAgaWYgKCF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHsgZ2V0Q2F0ZWdvcnlCeUlkIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NhdGVnb3JpZXNcIilcbiAgY29uc3QgY2F0ZWdvcnkgPSBhd2FpdCBnZXRDYXRlZ29yeUJ5SWQoam9iRGF0YS5jYXRlZ29yeUlkIHx8IFwiXCIpXG5cbiAgY29uc3QgeyBnZXRTdWJjYXRlZ29yeUJ5SWQgfSA9IGF3YWl0IGltcG9ydChcIi4vY2F0ZWdvcmllc1wiKVxuICBjb25zdCBzdWJjYXRlZ29yeSA9IGpvYkRhdGEuc3ViY2F0ZWdvcnlJZCA/IGF3YWl0IGdldFN1YmNhdGVnb3J5QnlJZChqb2JEYXRhLnN1YmNhdGVnb3J5SWQpIDogbnVsbFxuXG4gIGNvbnN0IGNoZWNrQXV0b0pvYkFwcHJvdmFsID0gKCk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIEFVVE8tQVBQUk9WQUwgQ0hFQ0s6IFN0YXJ0aW5nIGF1dG8tYXBwcm92YWwgY2hlY2suLi5cIilcblxuICAgIC8vIEZvciBzZXJ2ZXItc2lkZSBleGVjdXRpb24sIHdlIG5lZWQgdG8gcGFzcyB0aGUgc2V0dGluZyBmcm9tIGNsaWVudFxuICAgIC8vIERlZmF1bHQgdG8gTUFOVUFMIEFQUFJPVkFMIChmYWxzZSkgZm9yIHNlY3VyaXR5XG4gICAgbGV0IGF1dG9BcHByb3ZhbFNldHRpbmcgPSBmYWxzZVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWRtaW5fYXV0b19qb2JfYXBwcm92YWxfZW5hYmxlZFwiKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBBVVRPLUFQUFJPVkFMIENIRUNLOiBSYXcgbG9jYWxTdG9yYWdlIHZhbHVlOlwiLCBKU09OLnN0cmluZ2lmeShzZXR0aW5nKSlcblxuICAgICAgICAvLyBPbmx5IGVuYWJsZSBpZiBleHBsaWNpdGx5IHNldCB0byBcInRydWVcIlxuICAgICAgICBhdXRvQXBwcm92YWxTZXR0aW5nID0gc2V0dGluZyA9PT0gXCJ0cnVlXCJcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgQVVUTy1BUFBST1ZBTCBDSEVDSzogUGFyc2VkIHNldHRpbmc6XCIsIGF1dG9BcHByb3ZhbFNldHRpbmcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBBVVRPLUFQUFJPVkFMIENIRUNLOiBTZXJ2ZXItc2lkZSBleGVjdXRpb24gLSBkZWZhdWx0aW5nIHRvIE1BTlVBTCBBUFBST1ZBTFwiKVxuICAgICAgICBhdXRvQXBwcm92YWxTZXR0aW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0g8J+UpyBBVVRPLUFQUFJPVkFMIENIRUNLOiBFcnJvciBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlOlwiLCBlcnJvcilcbiAgICAgIGF1dG9BcHByb3ZhbFNldHRpbmcgPSBmYWxzZVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJbdjBdIPCflKcgQVVUTy1BUFBST1ZBTCBDSEVDSzogRmluYWwgZGVjaXNpb246XCIsXG4gICAgICBhdXRvQXBwcm92YWxTZXR0aW5nID8gXCJBVVRPLUFQUFJPVkVcIiA6IFwiTUFOVUFMIEFQUFJPVkFMXCIsXG4gICAgKVxuICAgIHJldHVybiBhdXRvQXBwcm92YWxTZXR0aW5nXG4gIH1cblxuICBjb25zdCBzaG91bGRBdXRvQXBwcm92ZSA9IGNoZWNrQXV0b0pvYkFwcHJvdmFsKClcblxuICBjb25zdCBqb2JTdGF0dXMgPSBzaG91bGRBdXRvQXBwcm92ZSA/IFwiYXBwcm92ZWRcIiA6IFwicGVuZGluZ1wiXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBTdGFydGluZyBqb2IgY3JlYXRpb24gcHJvY2Vzc1wiKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IEF1dG8tYXBwcm92YWwgZW5hYmxlZDpcIiwgc2hvdWxkQXV0b0FwcHJvdmUpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogSm9iIHN0YXR1cyB3aWxsIGJlOlwiLCBqb2JTdGF0dXMpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogSm9iIHRpdGxlOlwiLCBqb2JEYXRhLnRpdGxlKVxuXG4gIGNvbnN0IG5ld0pvYjogSm9iID0ge1xuICAgIGlkOiBgam9iXyR7RGF0ZS5ub3coKX1gLFxuICAgIHVzZXJJZCxcbiAgICBjYXRlZ29yeUlkOiBqb2JEYXRhLmNhdGVnb3J5SWQgfHwgXCJcIixcbiAgICBzdWJjYXRlZ29yeUlkOiBqb2JEYXRhLnN1YmNhdGVnb3J5SWQsXG4gICAgdGl0bGU6IGpvYkRhdGEudGl0bGUsXG4gICAgZGVzY3JpcHRpb246IGpvYkRhdGEuZGVzY3JpcHRpb24sXG4gICAgcmVxdWlyZW1lbnRzOiBqb2JEYXRhLnJlcXVpcmVtZW50cyxcbiAgICBpbnN0cnVjdGlvbnM6IGpvYkRhdGEuaW5zdHJ1Y3Rpb25zLFxuICAgIGJ1ZGdldE1pbjogam9iRGF0YS5idWRnZXRNaW4sXG4gICAgYnVkZ2V0TWF4OiBqb2JEYXRhLmJ1ZGdldE1heCB8fCBqb2JEYXRhLmJ1ZGdldE1pbixcbiAgICBkZWFkbGluZTogam9iRGF0YS5kZWFkbGluZSB8fCBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnNwbGl0KFwiVFwiKVswXSxcbiAgICBsb2NhdGlvbjogam9iRGF0YS5sb2NhdGlvbiB8fCBcIlJlbW90ZVwiLFxuICAgIGlzUmVtb3RlOiBqb2JEYXRhLmlzUmVtb3RlID8/IHRydWUsXG4gICAgc3RhdHVzOiBqb2JTdGF0dXMsIC8vIFVzZSB0aGUgZXhwbGljaXRseSBkZXRlcm1pbmVkIHN0YXR1c1xuICAgIHByaW9yaXR5OiBqb2JEYXRhLnByaW9yaXR5IHx8IFwibm9ybWFsXCIsXG4gICAgc2tpbGxzUmVxdWlyZWQ6IGpvYkRhdGEuc2tpbGxzUmVxdWlyZWQgfHwgW10sXG4gICAgYXBwbGljYXRpb25zQ291bnQ6IDAsXG4gICAgdmlld3NDb3VudDogMCxcbiAgICB3b3JrZXJzTmVlZGVkOiBqb2JEYXRhLndvcmtlcnNOZWVkZWQgfHwgMSxcbiAgICBkdXJhdGlvbjogam9iRGF0YS5kdXJhdGlvbixcbiAgICBkdXJhdGlvblR5cGU6IGpvYkRhdGEuZHVyYXRpb25UeXBlLFxuICAgIHRhZ3M6IGpvYkRhdGEudGFncyB8fCBbXSxcbiAgICBhdHRhY2htZW50czogam9iRGF0YS5hdHRhY2htZW50cyB8fCBbXSxcbiAgICByZXF1aXJlU2NyZWVuc2hvdHM6IGpvYkRhdGEucmVxdWlyZVNjcmVlbnNob3RzIHx8IDAsXG4gICAgc2NyZWVuc2hvdENvc3Q6IChqb2JEYXRhLnJlcXVpcmVTY3JlZW5zaG90cyB8fCAwKSAqIDAuMDUsXG4gICAgZXN0aW1hdGVkQXBwcm92YWxEYXlzOiBqb2JEYXRhLmVzdGltYXRlZEFwcHJvdmFsRGF5cyB8fCAxLFxuICAgIHJlcXVpcmVkUHJvb2Y6IGpvYkRhdGEucmVxdWlyZW1lbnRzLFxuICAgIHN1Ym1pdHRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgYXBwcm92ZWRBdDogc2hvdWxkQXV0b0FwcHJvdmUgPyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgOiB1bmRlZmluZWQsXG4gICAgYXBwcm92ZWRCeTogc2hvdWxkQXV0b0FwcHJvdmUgPyBcIlN5c3RlbSAoQXV0by1hcHByb3ZhbClcIiA6IHVuZGVmaW5lZCxcbiAgICBhcHByb3ZhbFJlYXNvbjogc2hvdWxkQXV0b0FwcHJvdmUgPyBcIkF1dG9tYXRpY2FsbHkgYXBwcm92ZWQgLSBBdXRvLWFwcHJvdmFsIGlzIGVuYWJsZWRcIiA6IHVuZGVmaW5lZCxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBjYXRlZ29yeTogY2F0ZWdvcnkgfHwge1xuICAgICAgaWQ6IGpvYkRhdGEuY2F0ZWdvcnlJZCB8fCBcIlwiLFxuICAgICAgbmFtZTogXCJHZW5lcmFsXCIsXG4gICAgICBzbHVnOiBcImdlbmVyYWxcIixcbiAgICB9LFxuICAgIHN1YmNhdGVnb3J5OiBzdWJjYXRlZ29yeVxuICAgICAgPyB7XG4gICAgICAgICAgaWQ6IHN1YmNhdGVnb3J5LmlkLFxuICAgICAgICAgIG5hbWU6IHN1YmNhdGVnb3J5Lm5hbWUsXG4gICAgICAgICAgc2x1Zzogc3ViY2F0ZWdvcnkuc2x1ZyxcbiAgICAgICAgICB0aHVtYm5haWw6IHN1YmNhdGVnb3J5LnRodW1ibmFpbCxcbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQsXG4gICAgcG9zdGVyOiB7XG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIGZpcnN0TmFtZTogdXNlci5maXJzdE5hbWUsXG4gICAgICBsYXN0TmFtZTogdXNlci5sYXN0TmFtZSxcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgcmF0aW5nOiA0LjUsXG4gICAgICB0b3RhbFJldmlld3M6IDAsXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgam9icy5wdXNoKG5ld0pvYilcbiAgc2F2ZUpvYnMoam9icylcblxuICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG4gIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgdXNlcklkLFxuICAgIHR5cGU6IFwiam9iXCIsXG4gICAgdGl0bGU6IHNob3VsZEF1dG9BcHByb3ZlID8gXCJKb2IgQXBwcm92ZWRcIiA6IFwiSm9iIFN1Ym1pdHRlZCBmb3IgUmV2aWV3XCIsXG4gICAgZGVzY3JpcHRpb246IHNob3VsZEF1dG9BcHByb3ZlXG4gICAgICA/IGBZb3VyIGpvYiBcIiR7bmV3Sm9iLnRpdGxlfVwiIGhhcyBiZWVuIGF1dG9tYXRpY2FsbHkgYXBwcm92ZWQgYW5kIGlzIG5vdyBsaXZlYFxuICAgICAgOiBgWW91ciBqb2IgXCIke25ld0pvYi50aXRsZX1cIiBoYXMgYmVlbiBzdWJtaXR0ZWQgYW5kIGlzIHBlbmRpbmcgYWRtaW4gcmV2aWV3YCxcbiAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL2pvYnNgLFxuICB9KVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgSk9CIENSRUFUSU9OOiBKb2IgY3JlYXRlZCBzdWNjZXNzZnVsbHkgd2l0aCBJRDpcIiwgbmV3Sm9iLmlkKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIEpPQiBDUkVBVElPTjogRmluYWwgam9iIHN0YXR1czpcIiwgbmV3Sm9iLnN0YXR1cylcbiAgY29uc29sZS5sb2coXCJbdjBdIOKchSBKT0IgQ1JFQVRJT046IEF1dG8tYXBwcm92ZWQ6XCIsIHNob3VsZEF1dG9BcHByb3ZlKVxuXG4gIHJldHVybiBuZXdKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcHJvdmVKb2Ioam9iSWQ6IHN0cmluZywgYWRtaW5JZDogc3RyaW5nLCByZWFzb24/OiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmRcIilcblxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJhcHByb3ZlZFwiLCBhZG1pbklkLCByZWFzb24pXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJlY29yZFN0YXR1c0NoYW5nZShcbiAgICBqb2JJZCxcbiAgICBvbGRTdGF0dXMsXG4gICAgXCJvcGVuXCIsIC8vIEpvYnMgYmVjb21lIFwib3BlblwiIHdoZW4gYXBwcm92ZWRcbiAgICBhZG1pbklkLFxuICAgIHJlYXNvbiB8fCBcIkpvYiBhcHByb3ZlZCBieSBhZG1pblwiLFxuICAgIHtcbiAgICAgIHJldmlld0lkOiBgcmV2aWV3LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgZGVjaXNpb246IFwiYWNjZXB0ZWRcIixcbiAgICAgIGZlZWRiYWNrOiByZWFzb24sXG4gICAgfSxcbiAgKVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWplY3RKb2Ioam9iSWQ6IHN0cmluZywgYWRtaW5JZDogc3RyaW5nLCByZWFzb246IHN0cmluZyk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYnNbam9iSW5kZXhdLnN0YXR1c1xuICBjb25zdCB1cGRhdGVkSm9iID0gYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCBcInJlamVjdGVkXCIsIGFkbWluSWQsIHJlYXNvbilcbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKGpvYklkLCBvbGRTdGF0dXMsIFwicmVqZWN0ZWRcIiwgYWRtaW5JZCwgcmVhc29uLCB7XG4gICAgcmV2aWV3SWQ6IGByZXZpZXctJHtEYXRlLm5vdygpfWAsXG4gICAgZGVjaXNpb246IFwicmVqZWN0ZWRcIixcbiAgICBmZWVkYmFjazogcmVhc29uLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdXNwZW5kSm9iKGpvYklkOiBzdHJpbmcsIGFkbWluSWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYnNbam9iSW5kZXhdLnN0YXR1c1xuICBjb25zdCB1cGRhdGVkSm9iID0gYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCBcInN1c3BlbmRlZFwiLCBhZG1pbklkKVxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZWNvcmRTdGF0dXNDaGFuZ2Uoam9iSWQsIG9sZFN0YXR1cywgXCJzdXNwZW5kZWRcIiwgYWRtaW5JZCwgXCJKb2Igc3VzcGVuZGVkIGJ5IGFkbWluXCIsIHtcbiAgICByZXZpZXdJZDogYHJldmlldy0ke0RhdGUubm93KCl9YCxcbiAgICBkZWNpc2lvbjogXCJyZXZpc2lvbl9yZXF1ZXN0ZWRcIixcbiAgICBmZWVkYmFjazogXCJKb2Igc3VzcGVuZGVkIGJ5IGFkbWluXCIsXG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBlbmRpbmdKb2JzKCk6IFByb21pc2U8Sm9iW10+IHtcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICByZXR1cm4gam9icy5maWx0ZXIoKGpvYikgPT4gam9iLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBcHByb3ZlZEpvYnMoKTogUHJvbWlzZTxKb2JbXT4ge1xuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIHJldHVybiBqb2JzLmZpbHRlcigoam9iKSA9PiBqb2Iuc3RhdHVzID09PSBcImFwcHJvdmVkXCIgfHwgam9iLnN0YXR1cyA9PT0gXCJvcGVuXCIpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxKb2JzKCk6IFByb21pc2U8Sm9iW10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuXG4gIGNvbnN0IHBvcHVsYXRlZEpvYnMgPSBhd2FpdCBQcm9taXNlLmFsbChqb2JzLm1hcChwb3B1bGF0ZUpvYkNhdGVnb3J5RGF0YSkpXG5cbiAgcmV0dXJuIHBvcHVsYXRlZEpvYnNcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFVzZXJKb2JzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2JbXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIHJldHVybiBqb2JzLmZpbHRlcigoam9iKSA9PiBqb2IudXNlcklkID09PSB1c2VySWQpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVKb2Ioam9iSWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxKb2I+KTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGpvYklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kXCIpXG5cbiAgY29uc3QgdXBkYXRlZEpvYiA9IHtcbiAgICAuLi5qb2JzW2pvYkluZGV4XSxcbiAgICAuLi51cGRhdGVzLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIC8vIElmIGpvYiBpcyBlZGl0ZWQsIGl0IG5lZWRzIHJlLWFwcHJvdmFsXG4gICAgc3RhdHVzOiB1cGRhdGVzLnN0YXR1cyB8fCBcInBlbmRpbmdcIixcbiAgfVxuXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYW5jZWxKb2Ioam9iSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPHsgam9iOiBKb2I7IHJlZnVuZEFtb3VudDogbnVtYmVyIH0+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGpvYklkICYmIGoudXNlcklkID09PSB1c2VySWQpXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIkpvYiBub3QgZm91bmQgb3IgdW5hdXRob3JpemVkXCIpXG5cbiAgY29uc3Qgam9iID0gam9ic1tqb2JJbmRleF1cbiAgY29uc3Qgb2xkU3RhdHVzID0gam9iLnN0YXR1c1xuXG4gIC8vIEdldCB3b3JrIHByb29mcyB0byBzZWUgaG93IG1hbnkgd29ya2VycyBoYXZlIHN1Ym1pdHRlZCB3b3JrXG4gIGNvbnN0IHdvcmtQcm9vZnMgPSBnZXRTdG9yZWRXb3JrUHJvb2ZzKCkuZmlsdGVyKCh3cCkgPT4gd3Auam9iSWQgPT09IGpvYklkKVxuICBjb25zdCBzdWJtaXR0ZWRXb3JrQ291bnQgPSB3b3JrUHJvb2ZzLmxlbmd0aFxuICBjb25zdCByZW1haW5pbmdTbG90cyA9IGpvYi53b3JrZXJzTmVlZGVkIC0gc3VibWl0dGVkV29ya0NvdW50XG5cbiAgY29uc3Qgam9iQ29zdFBlcldvcmtlciA9IGpvYi5idWRnZXRNYXhcbiAgY29uc3QgcGxhdGZvcm1GZWVQZXJXb3JrZXIgPSBqb2JDb3N0UGVyV29ya2VyICogMC4wNVxuICBjb25zdCB0b3RhbENvc3RQZXJXb3JrZXIgPSBqb2JDb3N0UGVyV29ya2VyICsgcGxhdGZvcm1GZWVQZXJXb3JrZXJcbiAgY29uc3QgcmVmdW5kQW1vdW50ID0gcmVtYWluaW5nU2xvdHMgPiAwID8gcmVtYWluaW5nU2xvdHMgKiB0b3RhbENvc3RQZXJXb3JrZXIgOiAwXG5cbiAgaWYgKHJlZnVuZEFtb3VudCA+IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBhZGRXYWxsZXRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi93YWxsZXRcIilcbiAgICAgIGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdXNlcklkLFxuICAgICAgICB0eXBlOiBcInJlZnVuZFwiLFxuICAgICAgICBhbW91bnQ6IHJlZnVuZEFtb3VudCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBSZWZ1bmQgZm9yIGNhbmNlbGxlZCBqb2I6IFwiJHtqb2IudGl0bGV9XCIgKEpvYiAjJHtqb2IuZm9ybWF0dGVkSm9iSWQgfHwgam9iLmlkfSkgLSAke3JlbWFpbmluZ1Nsb3RzfSByZW1haW5pbmcgc2xvdHMgKyBwbGF0Zm9ybSBmZWVzYCxcbiAgICAgICAgcmVmZXJlbmNlSWQ6IGpvYklkLFxuICAgICAgICByZWZlcmVuY2VUeXBlOiBcImpvYl9jYW5jZWxsYXRpb25cIixcbiAgICAgICAgYmFsYW5jZVR5cGU6IFwiZGVwb3NpdFwiLFxuICAgICAgfSlcbiAgICAgIGNvbnNvbGUubG9nKGBbdjBdIOKchSBKb2IgY2FuY2VsbGF0aW9uIHJlZnVuZCBwcm9jZXNzZWQ6ICQke3JlZnVuZEFtb3VudH1gKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFt2MF0g4pqg77iPIEpvYiBjYW5jZWxsYXRpb24gcmVmdW5kIGFscmVhZHkgcHJvY2Vzc2VkIGZvciBqb2I6ICR7am9iSWR9YClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFt2MF0g4p2MIEZhaWxlZCB0byBwcm9jZXNzIGpvYiBjYW5jZWxsYXRpb24gcmVmdW5kOmAsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBqb2Igc3RhdHVzIHRvIGNhbmNlbGxlZCBidXQga2VlcCBpdCBhY2Nlc3NpYmxlIGZvciBzdWJtaXR0ZWQgd29yayByZXZpZXdcbiAgY29uc3QgdXBkYXRlZEpvYiA9IHtcbiAgICAuLi5qb2IsXG4gICAgc3RhdHVzOiBcImNhbmNlbGxlZFwiIGFzIEpvYltcInN0YXR1c1wiXSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBjYW5jZWxsYXRpb25EZXRhaWxzOiB7XG4gICAgICBjYW5jZWxsZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgc3VibWl0dGVkV29ya0NvdW50LFxuICAgICAgcmVtYWluaW5nU2xvdHMsXG4gICAgICByZWZ1bmRBbW91bnQsXG4gICAgICBjYW5SZXZpZXdTdWJtaXNzaW9uczogc3VibWl0dGVkV29ya0NvdW50ID4gMCxcbiAgICB9LFxuICB9XG5cbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKFxuICAgIGpvYklkLFxuICAgIG9sZFN0YXR1cyxcbiAgICBcImNhbmNlbGxlZFwiLFxuICAgIHVzZXJJZCxcbiAgICBgSm9iIGNhbmNlbGxlZC4gJHtzdWJtaXR0ZWRXb3JrQ291bnR9IHdvcmsgc3VibWlzc2lvbnMgY2FuIHN0aWxsIGJlIHJldmlld2VkLiAke3JlbWFpbmluZ1Nsb3RzfSBzbG90cyByZWZ1bmRlZCBpbmNsdWRpbmcgcGxhdGZvcm0gZmVlLmAsXG4gICAge1xuICAgICAgdXNlckFjdGlvbjogXCJjYW5jZWxcIixcbiAgICAgIHN1Ym1pdHRlZFdvcmtDb3VudCxcbiAgICAgIHJlbWFpbmluZ1Nsb3RzLFxuICAgICAgcmVmdW5kQW1vdW50LFxuICAgICAgY2FuUmV2aWV3U3VibWlzc2lvbnM6IHN1Ym1pdHRlZFdvcmtDb3VudCA+IDAsXG4gICAgfSxcbiAgKVxuXG4gIGNvbnNvbGUubG9nKFxuICAgIGBbdjBdIEpvYiAke2pvYklkfSBjYW5jZWxsZWQuIFJlZnVuZDogJCR7cmVmdW5kQW1vdW50fSAoaW5jbHVkaW5nIHBsYXRmb3JtIGZlZSksIFN1Ym1pdHRlZCB3b3JrOiAke3N1Ym1pdHRlZFdvcmtDb3VudH1gLFxuICApXG5cbiAgcmV0dXJuIHsgam9iOiB1cGRhdGVkSm9iLCByZWZ1bmRBbW91bnQgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGF1c2VKb2Ioam9iSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQgJiYgai51c2VySWQgPT09IHVzZXJJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZCBvciB1bmF1dGhvcml6ZWRcIilcblxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2JzW2pvYkluZGV4XS5zdGF0dXNcbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJzdXNwZW5kZWRcIiwgdXNlcklkKVxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZWNvcmRTdGF0dXNDaGFuZ2Uoam9iSWQsIG9sZFN0YXR1cywgXCJzdXNwZW5kZWRcIiwgdXNlcklkLCBcIkpvYiBwYXVzZWQgYnkgb3duZXJcIiwgeyB1c2VyQWN0aW9uOiBcInBhdXNlXCIgfSlcblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhY3RpdmF0ZUpvYihqb2JJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZCAmJiBqLnVzZXJJZCA9PT0gdXNlcklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kIG9yIHVuYXV0aG9yaXplZFwiKVxuXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYnNbam9iSW5kZXhdLnN0YXR1c1xuICAvLyBSZWFjdGl2YXRlZCBqb2JzIG5lZWQgcmUtYXBwcm92YWxcbiAgY29uc3QgdXBkYXRlZEpvYiA9IGF3YWl0IHVwZGF0ZUpvYlN0YXR1cyhqb2JJZCwgXCJwZW5kaW5nXCIsIHVzZXJJZClcbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmVjb3JkU3RhdHVzQ2hhbmdlKGpvYklkLCBvbGRTdGF0dXMsIFwicGVuZGluZ1wiLCB1c2VySWQsIFwiSm9iIHJlYWN0aXZhdGVkIGFuZCByZXN1Ym1pdHRlZCBmb3IgYXBwcm92YWxcIiwge1xuICAgIHVzZXJBY3Rpb246IFwicmVhY3RpdmF0ZVwiLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkSm9iXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyQXBwbGljYXRpb25zKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcblxuICAvLyBGaWx0ZXIgYXBwbGljYXRpb25zIGJ5IHVzZXIgYW5kIGFkZCBqb2IgZGV0YWlsc1xuICBjb25zdCB1c2VyQXBwbGljYXRpb25zID0gYXBwbGljYXRpb25zXG4gICAgLmZpbHRlcigoYXBwKSA9PiBhcHAuYXBwbGljYW50SWQgPT09IHVzZXJJZClcbiAgICAubWFwKChhcHApID0+IHtcbiAgICAgIGNvbnN0IGpvYiA9IGpvYnMuZmluZCgoaikgPT4gai5pZCA9PT0gYXBwLmpvYklkKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwLFxuICAgICAgICBqb2I6IGpvYiB8fCBudWxsLFxuICAgICAgICBhcHBsaWVkQXQ6IGFwcC5jcmVhdGVkQXQsXG4gICAgICB9XG4gICAgfSlcblxuICByZXR1cm4gdXNlckFwcGxpY2F0aW9uc1xufVxuXG5pbXBvcnQgeyBnZXRBbGxVc2VycyB9IGZyb20gXCIuL2F1dGhcIlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3VibWl0V29ya1Byb29mKGRhdGE6IHtcbiAgam9iSWQ6IHN0cmluZ1xuICBhcHBsaWNhdGlvbklkOiBzdHJpbmdcbiAgd29ya2VySWQ6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgc3VibWlzc2lvblRleHQ6IHN0cmluZ1xuICBwcm9vZkZpbGVzPzogYW55W11cbiAgcHJvb2ZMaW5rcz86IHN0cmluZ1tdXG4gIHNjcmVlbnNob3RzPzogYW55W11cbiAgYXR0YWNobWVudHM/OiBhbnlbXVxufSk6IFByb21pc2U8V29ya1Byb29mPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfk50gV09SSyBQUk9PRjogU3RhcnRpbmcgd29yayBwcm9vZiBzdWJtaXNzaW9uXCIpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IEpvYiBJRDpcIiwgZGF0YS5qb2JJZClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfk50gV09SSyBQUk9PRjogV29ya2VyIElEOlwiLCBkYXRhLndvcmtlcklkKVxuXG4gIGNvbnN0IHVzZXJzID0gZ2V0QWxsVXNlcnMoKVxuICBjb25zdCB3b3JrZXJVc2VyID0gdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gZGF0YS53b3JrZXJJZClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkaQgRm91bmQgd29ya2VyIHVzZXI6XCIsIHdvcmtlclVzZXI/LmZpcnN0TmFtZSwgd29ya2VyVXNlcj8ubGFzdE5hbWUsIHdvcmtlclVzZXI/LnVzZXJuYW1lKVxuXG4gIC8vIEdldCBqb2IgZGV0YWlscyB0byBjaGVjayBhcHByb3ZhbCB0eXBlXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iID0gam9icy5maW5kKChqKSA9PiBqLmlkID09PSBkYXRhLmpvYklkKVxuXG4gIGlmICgham9iKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfk50gV09SSyBQUk9PRjogSm9iIGFwcHJvdmFsIHR5cGU6XCIsIGpvYi5hcHByb3ZhbFR5cGUpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IEluc3RhbnQgYXBwcm92YWwgZW5hYmxlZDpcIiwgam9iLmlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZClcblxuICAvLyBHZXQgYXBwbGljYXRpb24gZGV0YWlsc1xuICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICBjb25zdCBhcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9ucy5maW5kKChhcHApID0+IGFwcC5pZCA9PT0gZGF0YS5hcHBsaWNhdGlvbklkKVxuXG4gIGlmICghYXBwbGljYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcHBsaWNhdGlvbiBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IHBheW1lbnRBbW91bnQgPSBhcHBsaWNhdGlvbi5wcm9wb3NlZEJ1ZGdldCB8fCBqb2IuYnVkZ2V0TWF4IHx8IGpvYi5idWRnZXRNaW5cblxuICBjb25zdCBzaG91bGRQcm9jZXNzSW5zdGFudFBheW1lbnQgPSBqb2IuYXBwcm92YWxUeXBlID09PSBcImluc3RhbnRcIiAmJiBqb2IuaXNJbnN0YW50QXBwcm92YWxFbmFibGVkID09PSB0cnVlXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfk50gV09SSyBQUk9PRjogU2hvdWxkIHByb2Nlc3MgaW5zdGFudCBwYXltZW50OlwiLCBzaG91bGRQcm9jZXNzSW5zdGFudFBheW1lbnQpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5OdIFdPUksgUFJPT0Y6IFBheW1lbnQgYW1vdW50OlwiLCBwYXltZW50QW1vdW50KVxuXG4gIGNvbnN0IG5ld1Byb29mOiBXb3JrUHJvb2YgPSB7XG4gICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICBqb2JJZDogZGF0YS5qb2JJZCxcbiAgICBhcHBsaWNhdGlvbklkOiBkYXRhLmFwcGxpY2F0aW9uSWQsXG4gICAgd29ya2VySWQ6IGRhdGEud29ya2VySWQsXG4gICAgZW1wbG95ZXJJZDogam9iLnVzZXJJZCxcbiAgICB0aXRsZTogZGF0YS50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICBzdWJtaXNzaW9uVGV4dDogZGF0YS5zdWJtaXNzaW9uVGV4dCxcbiAgICBwcm9vZkZpbGVzOiBkYXRhLnByb29mRmlsZXMgfHwgW10sXG4gICAgcHJvb2ZMaW5rczogZGF0YS5wcm9vZkxpbmtzIHx8IFtdLFxuICAgIHNjcmVlbnNob3RzOiBkYXRhLnNjcmVlbnNob3RzIHx8IFtdLFxuICAgIGF0dGFjaG1lbnRzOiBkYXRhLmF0dGFjaG1lbnRzIHx8IFtdLFxuICAgIHN0YXR1czogc2hvdWxkUHJvY2Vzc0luc3RhbnRQYXltZW50ID8gXCJhcHByb3ZlZFwiIDogXCJzdWJtaXR0ZWRcIixcbiAgICBzdWJtaXR0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGFwcHJvdmVkQXQ6IHNob3VsZFByb2Nlc3NJbnN0YW50UGF5bWVudCA/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICBwYXltZW50QW1vdW50LFxuICAgIHN1Ym1pc3Npb25OdW1iZXI6IDEsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgd29ya2VyOiB7XG4gICAgICBpZDogZGF0YS53b3JrZXJJZCxcbiAgICAgIGZpcnN0TmFtZTogd29ya2VyVXNlcj8uZmlyc3ROYW1lIHx8IFwiVW5rbm93blwiLFxuICAgICAgbGFzdE5hbWU6IHdvcmtlclVzZXI/Lmxhc3ROYW1lIHx8IFwiV29ya2VyXCIsXG4gICAgICB1c2VybmFtZTogd29ya2VyVXNlcj8udXNlcm5hbWUgfHwgYHVzZXIke2RhdGEud29ya2VySWR9YCxcbiAgICAgIGF2YXRhcjogd29ya2VyVXNlcj8uYXZhdGFyLFxuICAgIH0sXG4gICAgZW1wbG95ZXI6IHtcbiAgICAgIGlkOiBqb2IudXNlcklkLFxuICAgICAgZmlyc3ROYW1lOiB1c2Vycy5maW5kKCh1KSA9PiB1LmlkID09PSBqb2IudXNlcklkKT8uZmlyc3ROYW1lIHx8IFwiSm9iXCIsXG4gICAgICBsYXN0TmFtZTogdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gam9iLnVzZXJJZCk/Lmxhc3ROYW1lIHx8IFwiUG9zdGVyXCIsXG4gICAgICB1c2VybmFtZTogdXNlcnMuZmluZCgodSkgPT4gdS5pZCA9PT0gam9iLnVzZXJJZCk/LnVzZXJuYW1lIHx8IFwiam9icG9zdGVyXCIsXG4gICAgfSxcbiAgfVxuXG4gIGlmIChzaG91bGRQcm9jZXNzSW5zdGFudFBheW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSU5TVEFOVCBQQVlNRU5UOiBQcm9jZXNzaW5nIGluc3RhbnQgcGF5bWVudCBmb3Igd29yayBwcm9vZlwiKVxuXG4gICAgICBjb25zdCB7IGFkZFdhbGxldFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3dhbGxldFwiKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgcGxhdGZvcm0gZmVlICg1JSBkZWZhdWx0KVxuICAgICAgY29uc3QgcGxhdGZvcm1GZWVTZXR0aW5ncyA9IGF3YWl0IGdldFBsYXRmb3JtRmVlU2V0dGluZ3MoKVxuICAgICAgbGV0IHBsYXRmb3JtRmVlUmF0ZSA9IDAuMDUgLy8gRGVmYXVsdCBmYWxsYmFja1xuICAgICAgbGV0IHBsYXRmb3JtRmVlID0gMFxuXG4gICAgICBpZiAocGxhdGZvcm1GZWVTZXR0aW5ncykge1xuICAgICAgICBjb25zdCBmZWVDYWxjdWxhdGlvbiA9IGNhbGN1bGF0ZVBsYXRmb3JtRmVlKHBheW1lbnRBbW91bnQsIHBsYXRmb3JtRmVlU2V0dGluZ3MpXG4gICAgICAgIHBsYXRmb3JtRmVlID0gZmVlQ2FsY3VsYXRpb24ucGxhdGZvcm1GZWVcbiAgICAgICAgcGxhdGZvcm1GZWVSYXRlID0gcGxhdGZvcm1GZWVTZXR0aW5ncy5mZWVQZXJjZW50YWdlIC8gMTAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGF0Zm9ybUZlZSA9IE1hdGgucm91bmQocGF5bWVudEFtb3VudCAqIHBsYXRmb3JtRmVlUmF0ZSAqIDEwMCkgLyAxMDBcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd29ya2VyQW1vdW50ID0gTWF0aC5yb3VuZCgocGF5bWVudEFtb3VudCAtIHBsYXRmb3JtRmVlKSAqIDEwMCkgLyAxMDBcblxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkrAgSU5TVEFOVCBQQVlNRU5UOiBUb3RhbCBhbW91bnQ6XCIsIHBheW1lbnRBbW91bnQpXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBJTlNUQU5UIFBBWU1FTlQ6IFBsYXRmb3JtIGZlZTpcIiwgcGxhdGZvcm1GZWUpXG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBJTlNUQU5UIFBBWU1FTlQ6IFdvcmtlciByZWNlaXZlczpcIiwgd29ya2VyQW1vdW50KVxuXG4gICAgICAvLyBBZGQgbW9uZXkgdG8gd29ya2VyJ3Mgd2l0aGRyYXdhbCBiYWxhbmNlXG4gICAgICBhd2FpdCBhZGRXYWxsZXRUcmFuc2FjdGlvbih7XG4gICAgICAgIHVzZXJJZDogZGF0YS53b3JrZXJJZCxcbiAgICAgICAgdHlwZTogXCJqb2JfcGF5bWVudFwiLFxuICAgICAgICBhbW91bnQ6IHdvcmtlckFtb3VudCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBJbnN0YW50IHBheW1lbnQgZm9yIGpvYjogJHtqb2IudGl0bGV9YCxcbiAgICAgICAgcmVmZXJlbmNlSWQ6IGRhdGEuam9iSWQsXG4gICAgICAgIHJlZmVyZW5jZVR5cGU6IFwiam9iX3BheW1lbnRcIixcbiAgICAgICAgYmFsYW5jZVR5cGU6IFwid2l0aGRyYXdhbFwiLFxuICAgICAgfSlcblxuICAgICAgLy8gUmVjb3JkIHBsYXRmb3JtIGZlZVxuICAgICAgYXdhaXQgYWRkV2FsbGV0VHJhbnNhY3Rpb24oe1xuICAgICAgICB1c2VySWQ6IFwicGxhdGZvcm1cIixcbiAgICAgICAgdHlwZTogXCJwbGF0Zm9ybV9mZWVcIixcbiAgICAgICAgYW1vdW50OiBwbGF0Zm9ybUZlZSxcbiAgICAgICAgZGVzY3JpcHRpb246IGBQbGF0Zm9ybSBmZWUgZm9yIGpvYjogJHtqb2IudGl0bGV9YCxcbiAgICAgICAgcmVmZXJlbmNlSWQ6IGRhdGEuam9iSWQsXG4gICAgICAgIHJlZmVyZW5jZVR5cGU6IFwicGxhdGZvcm1fZmVlXCIsXG4gICAgICAgIGJhbGFuY2VUeXBlOiBcIndpdGhkcmF3YWxcIixcbiAgICAgIH0pXG5cbiAgICAgIG5ld1Byb29mLmFwcHJvdmVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIG5ld1Byb29mLmFwcHJvdmVkQnkgPSBcIlN5c3RlbSAoSW5zdGFudCBBcHByb3ZhbClcIlxuICAgICAgbmV3UHJvb2YucGF5bWVudFByb2Nlc3NlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG5cbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgSU5TVEFOVCBQQVlNRU5UOiBQYXltZW50IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHlcIilcblxuICAgICAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBmb3Igd29ya2VyXG4gICAgICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG4gICAgICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgICAgICB1c2VySWQ6IGRhdGEud29ya2VySWQsXG4gICAgICAgIHR5cGU6IFwicGF5bWVudFwiLFxuICAgICAgICB0aXRsZTogXCJJbnN0YW50IFBheW1lbnQgUmVjZWl2ZWQhIPCfkrBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBZb3UgcmVjZWl2ZWQgJCR7d29ya2VyQW1vdW50LnRvRml4ZWQoMil9IGZvciBjb21wbGV0aW5nIFwiJHtqb2IudGl0bGV9XCIuIFBheW1lbnQgaGFzIGJlZW4gYWRkZWQgdG8geW91ciB3aXRoZHJhd2FsIGJhbGFuY2UuYCxcbiAgICAgICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC93YWxsZXRgLFxuICAgICAgfSlcblxuICAgICAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBmb3IgZW1wbG95ZXJcbiAgICAgIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgIHVzZXJJZDogam9iLnVzZXJJZCxcbiAgICAgICAgdHlwZTogXCJqb2JcIixcbiAgICAgICAgdGl0bGU6IFwiV29yayBTdWJtaXR0ZWQgJiBQYXltZW50IFJlbGVhc2VkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgV29yayBoYXMgYmVlbiBzdWJtaXR0ZWQgZm9yIFwiJHtqb2IudGl0bGV9XCIgYW5kIGluc3RhbnQgcGF5bWVudCBvZiAkJHtwYXltZW50QW1vdW50LnRvRml4ZWQoMil9IGhhcyBiZWVuIHJlbGVhc2VkIHRvIHRoZSB3b3JrZXIuYCxcbiAgICAgICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9qb2JzLyR7ZGF0YS5qb2JJZH1gLFxuICAgICAgfSlcblxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIOKchSBJTlNUQU5UIFBBWU1FTlQ6IE5vdGlmaWNhdGlvbnMgc2VudCBzdWNjZXNzZnVsbHlcIilcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0g4p2MIElOU1RBTlQgUEFZTUVOVDogRXJyb3IgcHJvY2Vzc2luZyBpbnN0YW50IHBheW1lbnQ6XCIsIGVycm9yKVxuICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgd29yayBwcm9vZiBzdWJtaXNzaW9uLCBqdXN0IGxvZyB0aGUgZXJyb3JcbiAgICAgIG5ld1Byb29mLnN0YXR1cyA9IFwic3VibWl0dGVkXCJcbiAgICAgIG5ld1Byb29mLnBheW1lbnRFcnJvciA9IGVycm9yLm1lc3NhZ2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIPCfk50gV09SSyBQUk9PRjogTWFudWFsIGFwcHJvdmFsIHJlcXVpcmVkLCBjcmVhdGluZyBub3RpZmljYXRpb24gZm9yIGVtcGxveWVyXCIpXG4gICAgY29uc3QgeyBjcmVhdGVOb3RpZmljYXRpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vbm90aWZpY2F0aW9uc1wiKVxuICAgIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgICB1c2VySWQ6IGpvYi51c2VySWQsXG4gICAgICB0eXBlOiBcImpvYlwiLFxuICAgICAgdGl0bGU6IFwiV29yayBTdWJtaXR0ZWQgZm9yIFJldmlld1wiLFxuICAgICAgZGVzY3JpcHRpb246IGBXb3JrIGhhcyBiZWVuIHN1Ym1pdHRlZCBmb3IgXCIke2pvYi50aXRsZX1cIi4gUGxlYXNlIHJldmlldyBhbmQgYXBwcm92ZSB3aXRoaW4gJHtqb2IubWFudWFsQXBwcm92YWxEYXlzIHx8IDN9IGRheXMuYCxcbiAgICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvam9icy8ke2RhdGEuam9iSWR9YCxcbiAgICB9KVxuICB9XG5cbiAgY29uc3Qgd29ya1Byb29mcyA9IGdldFN0b3JlZFdvcmtQcm9vZnMoKVxuICB3b3JrUHJvb2ZzLnB1c2gobmV3UHJvb2YpXG4gIHNhdmVXb3JrUHJvb2ZzKHdvcmtQcm9vZnMpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIOKchSBXT1JLIFBST09GOiBXb3JrIHByb29mIHNhdmVkIHN1Y2Nlc3NmdWxseSB3aXRoIHN0YXR1czpcIiwgbmV3UHJvb2Yuc3RhdHVzKVxuXG4gIHJldHVybiBuZXdQcm9vZlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V29ya1Byb29mc0J5Sm9iKGpvYklkOiBzdHJpbmcpOiBQcm9taXNlPFdvcmtQcm9vZltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IHdvcmtQcm9vZnMgPSBnZXRTdG9yZWRXb3JrUHJvb2ZzKClcbiAgcmV0dXJuIHdvcmtQcm9vZnMuZmlsdGVyKChwcm9vZikgPT4gcHJvb2Yuam9iSWQgPT09IGpvYklkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V29ya1Byb29mc0J5V29ya2VyKHdvcmtlcklkOiBzdHJpbmcpOiBQcm9taXNlPFdvcmtQcm9vZltdPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG4gIGNvbnN0IHdvcmtQcm9vZnMgPSBnZXRTdG9yZWRXb3JrUHJvb2ZzKClcbiAgcmV0dXJuIHdvcmtQcm9vZnMuZmlsdGVyKChwcm9vZikgPT4gcHJvb2Yud29ya2VySWQgPT09IHdvcmtlcklkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0V29ya1Byb29mcyhqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxXb3JrUHJvb2ZbXT4ge1xuICByZXR1cm4gYXdhaXQgZ2V0V29ya1Byb29mc0J5Sm9iKGpvYklkKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV2aWV3V29ya1Byb29mKFxuICBwcm9vZklkOiBzdHJpbmcsXG4gIHJldmlld0RhdGE6IHtcbiAgICBkZWNpc2lvbjogXCJhY2NlcHRlZFwiIHwgXCJyZWplY3RlZFwiIHwgXCJyZXZpc2lvbl9yZXF1ZXN0ZWRcIlxuICAgIGZlZWRiYWNrPzogc3RyaW5nXG4gICAgcmV2aXNpb25Ob3Rlcz86IHN0cmluZ1xuICAgIHJldmlld2VySWQ6IHN0cmluZ1xuICB9LFxuKTogUHJvbWlzZTxKb2JSZXZpZXc+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSlcblxuICBjb25zdCB3b3JrUHJvb2ZzID0gZ2V0U3RvcmVkV29ya1Byb29mcygpXG4gIGNvbnN0IHByb29mSW5kZXggPSB3b3JrUHJvb2ZzLmZpbmRJbmRleCgocHJvb2YpID0+IHByb29mLmlkID09PSBwcm9vZklkKVxuXG4gIGlmIChwcm9vZkluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmsgcHJvb2Ygbm90IGZvdW5kXCIpXG4gIH1cblxuICBjb25zdCBwcm9vZiA9IHdvcmtQcm9vZnNbcHJvb2ZJbmRleF1cblxuICAvLyBVcGRhdGUgcHJvb2Ygc3RhdHVzXG4gIHdvcmtQcm9vZnNbcHJvb2ZJbmRleF0gPSB7XG4gICAgLi4ucHJvb2YsXG4gICAgc3RhdHVzOlxuICAgICAgcmV2aWV3RGF0YS5kZWNpc2lvbiA9PT0gXCJhY2NlcHRlZFwiXG4gICAgICAgID8gXCJhY2NlcHRlZFwiXG4gICAgICAgIDogcmV2aWV3RGF0YS5kZWNpc2lvbiA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgPyBcInJlamVjdGVkXCJcbiAgICAgICAgICA6IFwicmV2aXNpb25fcmVxdWVzdGVkXCIsXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cbiAgc2F2ZVdvcmtQcm9vZnMod29ya1Byb29mcylcblxuICAvLyBDcmVhdGUgcmV2aWV3IHJlY29yZFxuICBjb25zdCByZXZpZXc6IEpvYlJldmlldyA9IHtcbiAgICBpZDogYHJldmlldy0ke0RhdGUubm93KCl9YCxcbiAgICBqb2JJZDogcHJvb2Yuam9iSWQsXG4gICAgcHJvb2ZJZDogcHJvb2ZJZCxcbiAgICByZXZpZXdlcklkOiByZXZpZXdEYXRhLnJldmlld2VySWQsXG4gICAgZGVjaXNpb246IHJldmlld0RhdGEuZGVjaXNpb24sXG4gICAgZmVlZGJhY2s6IHJldmlld0RhdGEuZmVlZGJhY2ssXG4gICAgcmV2aXNpb25Ob3RlczogcmV2aWV3RGF0YS5yZXZpc2lvbk5vdGVzLFxuICAgIHJldmlld2VkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfVxuXG4gIC8vIFN0b3JlIHJldmlldyAoaW4gcmVhbCBhcHAsIHRoaXMgd291bGQgZ28gdG8gZGF0YWJhc2UpXG4gIGNvbnN0IHJldmlld3MgPSBnZXRTdG9yZWRKb2JSZXZpZXdzKClcbiAgcmV2aWV3cy5wdXNoKHJldmlldylcbiAgc2F2ZUpvYlJldmlld3MocmV2aWV3cylcblxuICAvLyBVcGRhdGUgam9iIGFuZCBhcHBsaWNhdGlvbiBzdGF0dXMgYmFzZWQgb24gZGVjaXNpb25cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqb2IpID0+IGpvYi5pZCA9PT0gcHJvb2Yuam9iSWQpXG5cbiAgaWYgKGpvYkluZGV4ICE9PSAtMSkge1xuICAgIGNvbnN0IG9sZFN0YXR1cyA9IGpvYnNbam9iSW5kZXhdLnN0YXR1c1xuICAgIGxldCBuZXdTdGF0dXMgPSBvbGRTdGF0dXNcblxuICAgIGlmIChyZXZpZXdEYXRhLmRlY2lzaW9uID09PSBcImFjY2VwdGVkXCIpIHtcbiAgICAgIC8vIFVwZGF0ZSBqb2IgdG8gY29tcGxldGVkXG4gICAgICBuZXdTdGF0dXMgPSBcImNvbXBsZXRlZFwiXG4gICAgICBqb2JzW2pvYkluZGV4XSA9IHtcbiAgICAgICAgLi4uam9ic1tqb2JJbmRleF0sXG4gICAgICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXR1c0NoYW5nZShcbiAgICAgICAgcHJvb2Yuam9iSWQsXG4gICAgICAgIG9sZFN0YXR1cyxcbiAgICAgICAgXCJjb21wbGV0ZWRcIixcbiAgICAgICAgcmV2aWV3RGF0YS5yZXZpZXdlcklkLFxuICAgICAgICBcIldvcmsgcHJvb2YgYWNjZXB0ZWQgLSBqb2IgY29tcGxldGVkXCIsXG4gICAgICAgIHtcbiAgICAgICAgICByZXZpZXdJZDogcmV2aWV3LmlkLFxuICAgICAgICAgIGRlY2lzaW9uOiBcImFjY2VwdGVkXCIsXG4gICAgICAgICAgZmVlZGJhY2s6IHJldmlld0RhdGEuZmVlZGJhY2ssXG4gICAgICAgIH0sXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChyZXZpZXdEYXRhLmRlY2lzaW9uID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgIHJlY29yZFN0YXR1c0NoYW5nZShcbiAgICAgICAgcHJvb2Yuam9iSWQsXG4gICAgICAgIG9sZFN0YXR1cyxcbiAgICAgICAgb2xkU3RhdHVzLCAvLyBTdGF0dXMgbWlnaHQgbm90IGNoYW5nZSwgYnV0IHdlIHJlY29yZCB0aGUgcmV2aWV3XG4gICAgICAgIHJldmlld0RhdGEucmV2aWV3ZXJJZCxcbiAgICAgICAgXCJXb3JrIHByb29mIHJlamVjdGVkIC0gYXdhaXRpbmcgcmV3b3JrIG9yIGRpc3B1dGVcIixcbiAgICAgICAge1xuICAgICAgICAgIHJldmlld0lkOiByZXZpZXcuaWQsXG4gICAgICAgICAgZGVjaXNpb246IFwicmVqZWN0ZWRcIixcbiAgICAgICAgICBmZWVkYmFjazogcmV2aWV3RGF0YS5mZWVkYmFjayxcbiAgICAgICAgICByZXZpc2lvbk5vdGVzOiByZXZpZXdEYXRhLnJldmlzaW9uTm90ZXMsXG4gICAgICAgIH0sXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29yZFN0YXR1c0NoYW5nZShcbiAgICAgICAgcHJvb2Yuam9iSWQsXG4gICAgICAgIG9sZFN0YXR1cyxcbiAgICAgICAgb2xkU3RhdHVzLCAvLyBTdGF0dXMgc3RheXMgdGhlIHNhbWUgZm9yIHJldmlzaW9uIHJlcXVlc3RzXG4gICAgICAgIHJldmlld0RhdGEucmV2aWV3ZXJJZCxcbiAgICAgICAgXCJSZXZpc2lvbiByZXF1ZXN0ZWQgb24gd29yayBwcm9vZlwiLFxuICAgICAgICB7XG4gICAgICAgICAgcmV2aWV3SWQ6IHJldmlldy5pZCxcbiAgICAgICAgICBkZWNpc2lvbjogXCJyZXZpc2lvbl9yZXF1ZXN0ZWRcIixcbiAgICAgICAgICByZXZpc2lvbk5vdGVzOiByZXZpZXdEYXRhLnJldmlzaW9uTm90ZXMsXG4gICAgICAgIH0sXG4gICAgICApXG4gICAgfVxuXG4gICAgc2F2ZUpvYnMoam9icylcblxuICAgIC8vIFVwZGF0ZSBhcHBsaWNhdGlvbiB0byBjb21wbGV0ZWQgaWYgYWNjZXB0ZWRcbiAgICBpZiAocmV2aWV3RGF0YS5kZWNpc2lvbiA9PT0gXCJhY2NlcHRlZFwiKSB7XG4gICAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBnZXRTdG9yZWRBcHBsaWNhdGlvbnMoKVxuICAgICAgY29uc3QgYXBwSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KChhcHApID0+IGFwcC5qb2JJZCA9PT0gcHJvb2Yuam9iSWQgJiYgYXBwLmFwcGxpY2FudElkID09PSBwcm9vZi53b3JrZXJJZClcbiAgICAgIGlmIChhcHBJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYXBwbGljYXRpb25zW2FwcEluZGV4XSA9IHtcbiAgICAgICAgICAuLi5hcHBsaWNhdGlvbnNbYXBwSW5kZXhdLFxuICAgICAgICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIixcbiAgICAgICAgfVxuICAgICAgICBzYXZlQXBwbGljYXRpb25zKGFwcGxpY2F0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV2aWV3XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRKb2JBcHBsaWNhdGlvbkJ5SWQoYXBwbGljYXRpb25JZDogc3RyaW5nKTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbiB8IG51bGw+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3QgYXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgcmV0dXJuIGFwcGxpY2F0aW9ucy5maW5kKChhcHApID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZCkgfHwgbnVsbFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSm9iU3RhdHVzKFxuICBqb2JJZDogc3RyaW5nLFxuICBuZXdTdGF0dXM6IEpvYltcInN0YXR1c1wiXSxcbiAgdXNlcklkPzogc3RyaW5nLFxuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT4sXG4pOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoam9iKSA9PiBqb2IuaWQgPT09IGpvYklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kXCIpXG5cbiAgY29uc3Qgam9iID0gam9ic1tqb2JJbmRleF1cbiAgY29uc3Qgb2xkU3RhdHVzID0gam9iLnN0YXR1c1xuXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSB7XG4gICAgLi4uam9iLFxuICAgIHN0YXR1czogbmV3U3RhdHVzLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIC4uLihuZXdTdGF0dXMgPT09IFwiY29tcGxldGVkXCIgJiYgeyBjb21wbGV0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pLFxuICB9XG5cbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgLy8gQWRkIHRvIHN0YXR1cyBoaXN0b3J5XG4gIGNvbnN0IHN0YXR1c0hpc3RvcnkgPSBnZXRTdG9yZWRKb2JTdGF0dXNIaXN0b3J5KClcbiAgc3RhdHVzSGlzdG9yeS5wdXNoKHtcbiAgICBpZDogYHN0YXR1c18ke0RhdGUubm93KCl9YCxcbiAgICBqb2JJZCxcbiAgICB1c2VySWQsXG4gICAgb2xkU3RhdHVzLFxuICAgIG5ld1N0YXR1cyxcbiAgICBub3RlczogbWV0YWRhdGE/Lm5vdGVzIHx8IGBTdGF0dXMgY2hhbmdlZCBmcm9tICR7b2xkU3RhdHVzfSB0byAke25ld1N0YXR1c31gLFxuICAgIG1ldGFkYXRhLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9KVxuICBzYXZlSm9iU3RhdHVzSGlzdG9yeShzdGF0dXNIaXN0b3J5KVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSBKb2Igc3RhdHVzIHVwZGF0ZWQ6XCIsIGpvYklkLCBcImZyb21cIiwgb2xkU3RhdHVzLCBcInRvXCIsIG5ld1N0YXR1cylcblxuICBpZiAobmV3U3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgY3JlYXRlTm90aWZpY2F0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL25vdGlmaWNhdGlvbnNcIilcblxuICAgICAgLy8gTm90aWZ5IGpvYiBwb3N0ZXJcbiAgICAgIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgICAgIHVzZXJJZDogam9iLnVzZXJJZCxcbiAgICAgICAgdHlwZTogXCJqb2JcIixcbiAgICAgICAgdGl0bGU6IFwiSm9iIENvbXBsZXRlZCBTdWNjZXNzZnVsbHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IGBZb3VyIGpvYiBcIiR7am9iLnRpdGxlfVwiIGhhcyBiZWVuIGNvbXBsZXRlZCBieSBhbGwgcmVxdWlyZWQgd29ya2Vycy5gLFxuICAgICAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL2pvYnMvJHtqb2JJZH1gLFxuICAgICAgfSlcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHdvcmtlcnMsIG5vdGlmeSB0aGVtIGFsbFxuICAgICAgaWYgKG1ldGFkYXRhPy50b3RhbFdvcmtlcnNDb21wbGV0ZWQgJiYgbWV0YWRhdGEudG90YWxXb3JrZXJzQ29tcGxldGVkID4gMSkge1xuICAgICAgICBjb25zdCB7IGdldEpvYkFwcGxpY2F0aW9ucyB9ID0gYXdhaXQgaW1wb3J0KFwiLi9qb2JzXCIpXG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGF3YWl0IGdldEpvYkFwcGxpY2F0aW9ucyhqb2JJZClcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRXb3JrZXJzID0gYXBwbGljYXRpb25zLmZpbHRlcigoYXBwKSA9PiBhcHAuc3RhdHVzID09PSBcImFjY2VwdGVkXCIpXG5cbiAgICAgICAgZm9yIChjb25zdCBhcHAgb2YgYWNjZXB0ZWRXb3JrZXJzKSB7XG4gICAgICAgICAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHVzZXJJZDogYXBwLmFwcGxpY2FudElkLFxuICAgICAgICAgICAgdHlwZTogXCJqb2JcIixcbiAgICAgICAgICAgIHRpdGxlOiBcIkpvYiBGdWxseSBDb21wbGV0ZWRcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgVGhlIGpvYiBcIiR7am9iLnRpdGxlfVwiIGhhcyBiZWVuIGNvbXBsZXRlZCBieSBhbGwgcmVxdWlyZWQgd29ya2Vycy5gLFxuICAgICAgICAgICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9hcHBsaWVkLWpvYnNgLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0gRmFpbGVkIHRvIHNlbmQgY29tcGxldGlvbiBub3RpZmljYXRpb25zOlwiLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlZEpvYlxufVxuXG5leHBvcnQgY29uc3QgSk9CX1NUQVRVUyA9IHtcbiAgUEVORElORzogXCJwZW5kaW5nXCIgYXMgY29uc3QsXG4gIEFQUFJPVkVEOiBcImFwcHJvdmVkXCIgYXMgY29uc3QsXG4gIFJFSkVDVEVEOiBcInJlamVjdGVkXCIgYXMgY29uc3QsXG4gIFNVU1BFTkRFRDogXCJzdXNwZW5kZWRcIiBhcyBjb25zdCxcbiAgT1BFTjogXCJvcGVuXCIgYXMgY29uc3QsXG4gIElOX1BST0dSRVNTOiBcImluX3Byb2dyZXNzXCIgYXMgY29uc3QsXG4gIENPTVBMRVRFRDogXCJjb21wbGV0ZWRcIiBhcyBjb25zdCxcbiAgQ0FOQ0VMTEVEOiBcImNhbmNlbGxlZFwiIGFzIGNvbnN0LFxufVxuXG5leHBvcnQgY29uc3QgZ2V0Sm9iU3RhdHVzQ29sb3IgPSAoc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIEpPQl9TVEFUVVMuUEVORElORzpcbiAgICAgIHJldHVybiBcImJnLXllbGxvdy0xMDAgdGV4dC15ZWxsb3ctODAwXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuQVBQUk9WRUQ6XG4gICAgY2FzZSBKT0JfU1RBVFVTLk9QRU46XG4gICAgICByZXR1cm4gXCJiZy1ncmVlbi0xMDAgdGV4dC1ncmVlbi04MDBcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5SRUpFQ1RFRDpcbiAgICAgIHJldHVybiBcImJnLXJlZC0xMDAgdGV4dC1yZWQtODAwXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuU1VTUEVOREVEOlxuICAgICAgcmV0dXJuIFwiYmctZ3JheS0xMDAgdGV4dC1ncmF5LTgwMFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLklOX1BST0dSRVNTOlxuICAgICAgcmV0dXJuIFwiYmctYmx1ZS0xMDAgdGV4dC1ibHVlLTgwMFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLkNPTVBMRVRFRDpcbiAgICAgIHJldHVybiBcImJnLXB1cnBsZS0xMDAgdGV4dC1wdXJwbGUtODAwXCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuQ0FOQ0VMTEVEOlxuICAgICAgcmV0dXJuIFwiYmctb3JhbmdlLTEwMCB0ZXh0LW9yYW5nZS04MDBcIlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJiZy1ncmF5LTEwMCB0ZXh0LWdyYXktODAwXCJcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Sm9iU3RhdHVzTGFiZWwgPSAoc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICBjYXNlIEpPQl9TVEFUVVMuUEVORElORzpcbiAgICAgIHJldHVybiBcIlBlbmRpbmcgUmV2aWV3XCJcbiAgICBjYXNlIEpPQl9TVEFUVVMuQVBQUk9WRUQ6XG4gICAgICByZXR1cm4gXCJBcHByb3ZlZFwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLlJFSkVDVEVEOlxuICAgICAgcmV0dXJuIFwiUmVqZWN0ZWRcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5TVVNQRU5ERUQ6XG4gICAgICByZXR1cm4gXCJTdXNwZW5kZWRcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5PUEVOOlxuICAgICAgcmV0dXJuIFwiT3BlblwiXG4gICAgY2FzZSBKT0JfU1RBVFVTLklOX1BST0dSRVNTOlxuICAgICAgcmV0dXJuIFwiSW4gUHJvZ3Jlc3NcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5DT01QTEVURUQ6XG4gICAgICByZXR1cm4gXCJDb21wbGV0ZWRcIlxuICAgIGNhc2UgSk9CX1NUQVRVUy5DQU5DRUxMRUQ6XG4gICAgICByZXR1cm4gXCJDYW5jZWxsZWRcIlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdHVzXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNhbkFwcGx5VG9Kb2IgPSAoam9iOiBKb2IpID0+IHtcbiAgcmV0dXJuIGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuQVBQUk9WRUQgfHwgam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5PUEVOXG59XG5cbmV4cG9ydCBjb25zdCBpc0pvYlZpc2libGUgPSAoam9iOiBKb2IsIHVzZXJUeXBlOiBcInVzZXJcIiB8IFwiYWRtaW5cIiA9IFwidXNlclwiKSA9PiB7XG4gIGlmICh1c2VyVHlwZSA9PT0gXCJhZG1pblwiKSB7XG4gICAgcmV0dXJuIHRydWUgLy8gQWRtaW5zIGNhbiBzZWUgYWxsIGpvYnNcbiAgfVxuXG4gIC8vIFJlZ3VsYXIgdXNlcnMgY2FuIG9ubHkgc2VlIGFwcHJvdmVkL29wZW4gam9ic1xuICByZXR1cm4gam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5BUFBST1ZFRCB8fCBqb2Iuc3RhdHVzID09PSBKT0JfU1RBVFVTLk9QRU5cbn1cblxuZXhwb3J0IGNvbnN0IGdldEF2YWlsYWJsZUpvYnMgPSBhc3luYyAoY3VycmVudFVzZXJJZD86IHN0cmluZyk6IFByb21pc2U8Sm9iW10+ID0+IHtcbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuXG4gIHJldHVybiBqb2JzLmZpbHRlcigoam9iKSA9PiB7XG4gICAgLy8gQmFzaWMgc3RhdHVzIGZpbHRlciAtIG9ubHkgc2hvdyBhcHByb3ZlZC9vcGVuIGpvYnMgdGhhdCBhcmVuJ3QgY29tcGxldGVkXG4gICAgY29uc3QgaXNWYWxpZFN0YXR1cyA9XG4gICAgICAoam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5BUFBST1ZFRCB8fCBqb2Iuc3RhdHVzID09PSBKT0JfU1RBVFVTLk9QRU4pICYmIGpvYi5zdGF0dXMgIT09IEpPQl9TVEFUVVMuQ09NUExFVEVEXG5cbiAgICBpZiAoIWlzVmFsaWRTdGF0dXMpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgd29ya2Vyc05lZWRlZCA9IGpvYi53b3JrZXJzTmVlZGVkIHx8IGpvYi5tYXhXb3JrZXJzIHx8IDFcbiAgICBjb25zdCBjdXJyZW50QXBwbGljYXRpb25zID0gam9iLmFwcGxpY2F0aW9uc0NvdW50IHx8IDBcblxuICAgIC8vIElmIGpvYiBoYXMgcmVhY2hlZCBpdHMgd29ya2VyIGxpbWl0LCBkb24ndCBzaG93IGl0IGFzIGF2YWlsYWJsZVxuICAgIGlmIChjdXJyZW50QXBwbGljYXRpb25zID49IHdvcmtlcnNOZWVkZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSBKb2JcIiwgam9iLmlkLCBcImF0IGNhcGFjaXR5OlwiLCBjdXJyZW50QXBwbGljYXRpb25zLCBcIm9mXCIsIHdvcmtlcnNOZWVkZWQsIFwid29ya2Vyc1wiKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXJ2YXRpb25JbmZvID0gbG9jYWxSZXNlcnZhdGlvblN0b3JhZ2UuaXNKb2JSZXNlcnZlZChqb2IuaWQpXG5cbiAgICAvLyBJZiBqb2IgaXMgbm90IHJlc2VydmVkLCBzaG93IGl0IHRvIGV2ZXJ5b25lXG4gICAgaWYgKCFyZXNlcnZhdGlvbkluZm8uaXNSZXNlcnZlZCkgcmV0dXJuIHRydWVcblxuICAgIC8vIElmIGpvYiBuZWVkcyBtdWx0aXBsZSB3b3JrZXJzLCBzaG93IGl0IGV2ZW4gd2hlbiByZXNlcnZlZCAocGFydGlhbCByZXNlcnZhdGlvbilcbiAgICBpZiAoam9iLndvcmtlcnNOZWVkZWQgPiAxKSByZXR1cm4gdHJ1ZVxuXG4gICAgLy8gRm9yIHNpbmdsZS13b3JrZXIgam9icyB0aGF0IGFyZSByZXNlcnZlZDpcbiAgICAvLyBPbmx5IHNob3cgdG8gdGhlIHVzZXIgd2hvIHJlc2VydmVkIGl0LCBoaWRlIGZyb20gb3RoZXJzXG4gICAgaWYgKGpvYi53b3JrZXJzTmVlZGVkID09PSAxICYmIHJlc2VydmF0aW9uSW5mby5pc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gY3VycmVudFVzZXJJZCA9PT0gcmVzZXJ2YXRpb25JbmZvLnVzZXJJZFxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBnZXRKb2JzRm9yRGFzaGJvYXJkID0gKGpvYnM6IEpvYltdLCBjdXJyZW50VXNlcklkPzogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBqb2JzLmZpbHRlcigoam9iKSA9PiB7XG4gICAgLy8gQmFzaWMgc3RhdHVzIGZpbHRlclxuICAgIGNvbnN0IGlzVmFsaWRTdGF0dXMgPVxuICAgICAgKGpvYi5zdGF0dXMgPT09IEpPQl9TVEFUVVMuQVBQUk9WRUQgfHwgam9iLnN0YXR1cyA9PT0gSk9CX1NUQVRVUy5PUEVOKSAmJiBqb2Iuc3RhdHVzICE9PSBKT0JfU1RBVFVTLkNPTVBMRVRFRFxuXG4gICAgaWYgKCFpc1ZhbGlkU3RhdHVzKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHdvcmtlcnNOZWVkZWQgPSBqb2Iud29ya2Vyc05lZWRlZCB8fCBqb2IubWF4V29ya2VycyB8fCAxXG4gICAgY29uc3QgY3VycmVudEFwcGxpY2F0aW9ucyA9IGpvYi5hcHBsaWNhdGlvbnNDb3VudCB8fCAwXG5cbiAgICAvLyBJZiBqb2IgaGFzIHJlYWNoZWQgaXRzIHdvcmtlciBsaW1pdCwgZG9uJ3Qgc2hvdyBpdCBhcyBhdmFpbGFibGVcbiAgICBpZiAoY3VycmVudEFwcGxpY2F0aW9ucyA+PSB3b3JrZXJzTmVlZGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0gRGFzaGJvYXJkIGpvYlwiLCBqb2IuaWQsIFwiYXQgY2FwYWNpdHk6XCIsIGN1cnJlbnRBcHBsaWNhdGlvbnMsIFwib2ZcIiwgd29ya2Vyc05lZWRlZCwgXCJ3b3JrZXJzXCIpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCByZXNlcnZhdGlvbkluZm8gPSBsb2NhbFJlc2VydmF0aW9uU3RvcmFnZS5pc0pvYlJlc2VydmVkKGpvYi5pZClcblxuICAgIC8vIElmIGpvYiBpcyBub3QgcmVzZXJ2ZWQsIHNob3cgaXQgdG8gZXZlcnlvbmVcbiAgICBpZiAoIXJlc2VydmF0aW9uSW5mby5pc1Jlc2VydmVkKSByZXR1cm4gdHJ1ZVxuXG4gICAgLy8gSWYgam9iIG5lZWRzIG11bHRpcGxlIHdvcmtlcnMsIHNob3cgaXQgZXZlbiB3aGVuIHJlc2VydmVkXG4gICAgaWYgKGpvYi53b3JrZXJzTmVlZGVkID4gMSkgcmV0dXJuIHRydWVcblxuICAgIC8vIEZvciBzaW5nbGUtd29ya2VyIGpvYnMgdGhhdCBhcmUgcmVzZXJ2ZWQ6XG4gICAgLy8gT25seSBzaG93IHRvIHRoZSB1c2VyIHdobyByZXNlcnZlZCBpdFxuICAgIGlmIChqb2Iud29ya2Vyc05lZWRlZCA9PT0gMSAmJiByZXNlcnZhdGlvbkluZm8uaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRVc2VySWQgPT09IHJlc2VydmF0aW9uSW5mby51c2VySWRcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiB0byBnZXQgam9iIHN0YXR1cyBoaXN0b3J5XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Sm9iU3RhdHVzSGlzdG9yeShqb2JJZDogc3RyaW5nKTogUHJvbWlzZTxKb2JTdGF0dXNIaXN0b3J5W10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3QgaGlzdG9yeSA9IGdldFN0b3JlZEpvYlN0YXR1c0hpc3RvcnkoKVxuICByZXR1cm4gaGlzdG9yeVxuICAgIC5maWx0ZXIoKGVudHJ5KSA9PiBlbnRyeS5qb2JJZCA9PT0gam9iSWQpXG4gICAgLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGIuY3JlYXRlZEF0KS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNyZWF0ZWRBdCkuZ2V0VGltZSgpKVxufVxuXG4vLyBGdW5jdGlvbiB0byBnZXQgYWxsIHN0YXR1cyBoaXN0b3J5IGZvciBhZG1pblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEpvYlN0YXR1c0hpc3RvcnkoKTogUHJvbWlzZTxKb2JTdGF0dXNIaXN0b3J5W10+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSlcbiAgY29uc3QgaGlzdG9yeSA9IGdldFN0b3JlZEpvYlN0YXR1c0hpc3RvcnkoKVxuICByZXR1cm4gaGlzdG9yeS5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShiLmNyZWF0ZWRBdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkQXQpLmdldFRpbWUoKSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjY2VwdEpvYkFwcGxpY2F0aW9uKGFwcGxpY2F0aW9uSWQ6IHN0cmluZywgZW1wbG95ZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGNvbnN0IGFwcGxpY2F0aW9uSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KChhcHApID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZClcblxuICBpZiAoYXBwbGljYXRpb25JbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcHBsaWNhdGlvbiBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9uID0gYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdXG5cbiAgLy8gVmVyaWZ5IGVtcGxveWVyIG93bnMgdGhlIGpvYlxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGFwcGxpY2F0aW9uLmpvYklkKVxuICBjb25zdCBqb2IgPSBqb2JzW2pvYkluZGV4XVxuXG4gIGlmICgham9iIHx8IGpvYi51c2VySWQgIT09IGVtcGxveWVySWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VwdCB0aGlzIGFwcGxpY2F0aW9uXCIpXG4gIH1cblxuICBjb25zdCB1cGRhdGVkQXBwbGljYXRpb24gPSB7XG4gICAgLi4uYXBwbGljYXRpb24sXG4gICAgc3RhdHVzOiBcImFjY2VwdGVkXCIgYXMgY29uc3QsXG4gICAgYWNjZXB0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdID0gdXBkYXRlZEFwcGxpY2F0aW9uXG4gIHNhdmVBcHBsaWNhdGlvbnMoYXBwbGljYXRpb25zKVxuXG4gIGNvbnN0IHVwZGF0ZWRKb2IgPSB7XG4gICAgLi4uam9iLFxuICAgIHN0YXR1czogXCJjb21wbGV0ZWRcIiBhcyBjb25zdCxcbiAgICBhc3NpZ25lZFdvcmtlcklkOiBhcHBsaWNhdGlvbi5hcHBsaWNhbnRJZCxcbiAgICBjb21wbGV0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgam9ic1tqb2JJbmRleF0gPSB1cGRhdGVkSm9iXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGFkZFdhbGxldFRyYW5zYWN0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3dhbGxldFwiKVxuXG4gICAgY29uc3QgcGF5bWVudEFtb3VudCA9IGFwcGxpY2F0aW9uLnByb3Bvc2VkQnVkZ2V0XG5cbiAgICBpZiAoIXBheW1lbnRBbW91bnQgfHwgcGF5bWVudEFtb3VudCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF5bWVudCBhbW91bnQ6ICR7cGF5bWVudEFtb3VudH1gKVxuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBwbGF0Zm9ybSBmZWUgKDUlIGRlZmF1bHQpXG4gICAgY29uc3QgcGxhdGZvcm1GZWVTZXR0aW5ncyA9IGF3YWl0IGdldFBsYXRmb3JtRmVlU2V0dGluZ3MoKVxuICAgIGxldCBwbGF0Zm9ybUZlZVJhdGUgPSAwLjA1IC8vIERlZmF1bHQgZmFsbGJhY2tcbiAgICBsZXQgcGxhdGZvcm1GZWUgPSAwXG5cbiAgICBpZiAocGxhdGZvcm1GZWVTZXR0aW5ncykge1xuICAgICAgY29uc3QgZmVlQ2FsY3VsYXRpb24gPSBjYWxjdWxhdGVQbGF0Zm9ybUZlZShwYXltZW50QW1vdW50LCBwbGF0Zm9ybUZlZVNldHRpbmdzKVxuICAgICAgcGxhdGZvcm1GZWUgPSBmZWVDYWxjdWxhdGlvbi5wbGF0Zm9ybUZlZVxuICAgICAgcGxhdGZvcm1GZWVSYXRlID0gcGxhdGZvcm1GZWVTZXR0aW5ncy5mZWVQZXJjZW50YWdlIC8gMTAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHBsYXRmb3JtRmVlID0gTWF0aC5yb3VuZChwYXltZW50QW1vdW50ICogcGxhdGZvcm1GZWVSYXRlICogMTAwKSAvIDEwMFxuICAgIH1cblxuICAgIGNvbnN0IHdvcmtlckFtb3VudCA9IE1hdGgucm91bmQoKHBheW1lbnRBbW91bnQgLSBwbGF0Zm9ybUZlZSkgKiAxMDApIC8gMTAwIC8vIFJvdW5kIHRvIDIgZGVjaW1hbHNcblxuICAgIGNvbnNvbGUubG9nKGBbdjBdIPCfkrAgUHJvY2Vzc2luZyBpbnN0YW50IHBheW1lbnQ6YClcbiAgICBjb25zb2xlLmxvZyhgW3YwXSAtIFRvdGFsIGpvYiBhbW91bnQ6ICQke3BheW1lbnRBbW91bnR9YClcbiAgICBjb25zb2xlLmxvZyhgW3YwXSAtIFBsYXRmb3JtIGZlZSAoNSUpOiAkJHtwbGF0Zm9ybUZlZX1gKVxuICAgIGNvbnNvbGUubG9nKGBbdjBdIC0gV29ya2VyIHJlY2VpdmVzOiAkJHt3b3JrZXJBbW91bnR9YClcbiAgICBjb25zb2xlLmxvZyhgW3YwXSAtIFdvcmtlciBJRDogJHthcHBsaWNhdGlvbi5hcHBsaWNhbnRJZH1gKVxuXG4gICAgLy8gQWRkIG1vbmV5IHRvIHdvcmtlcidzIHdpdGhkcmF3YWwgYmFsYW5jZVxuICAgIGF3YWl0IGFkZFdhbGxldFRyYW5zYWN0aW9uKGFwcGxpY2F0aW9uLmFwcGxpY2FudElkLCB7XG4gICAgICB0eXBlOiBcImpvYl9wYXltZW50XCIsXG4gICAgICBhbW91bnQ6IHdvcmtlckFtb3VudCxcbiAgICAgIGRlc2NyaXB0aW9uOiBgUGF5bWVudCBmb3Igam9iOiAke2pvYi50aXRsZX1gLFxuICAgICAgam9iSWQ6IGpvYi5pZCxcbiAgICAgIGZyb21Vc2VySWQ6IGVtcGxveWVySWQsXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGBbdjBdIOKchSBQYXltZW50IHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB3b3JrZXIgJHthcHBsaWNhdGlvbi5hcHBsaWNhbnRJZH0gd2FsbGV0OiAkJHt3b3JrZXJBbW91bnR9YClcblxuICAgIC8vIFJlY29yZCBwbGF0Zm9ybSBmZWVcbiAgICBhd2FpdCBhZGRXYWxsZXRUcmFuc2FjdGlvbihcInBsYXRmb3JtXCIsIHtcbiAgICAgIHR5cGU6IFwicGxhdGZvcm1fZmVlXCIsXG4gICAgICBhbW91bnQ6IHBsYXRmb3JtRmVlLFxuICAgICAgZGVzY3JpcHRpb246IGBQbGF0Zm9ybSBmZWUgZm9yIGpvYjogJHtqb2IudGl0bGV9YCxcbiAgICAgIGpvYklkOiBqb2IuaWQsXG4gICAgICBmcm9tVXNlcklkOiBlbXBsb3llcklkLFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhgW3YwXSDinIUgUGxhdGZvcm0gZmVlIHJlY29yZGVkOiAkJHtwbGF0Zm9ybUZlZX1gKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIOKdjCBFcnJvciBwcm9jZXNzaW5nIGluc3RhbnQgcGF5bWVudDpcIiwgZXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBQYXltZW50IHByb2Nlc3NpbmcgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIC8vIENyZWF0ZSBub3RpZmljYXRpb24gZm9yIGFwcGxpY2FudFxuICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG4gIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgdXNlcklkOiBhcHBsaWNhdGlvbi5hcHBsaWNhbnRJZCxcbiAgICB0eXBlOiBcImpvYlwiLFxuICAgIHRpdGxlOiBcIkpvYiBBY2NlcHRlZCAmIFBheW1lbnQgUmVsZWFzZWQhXCIsXG4gICAgZGVzY3JpcHRpb246IGBZb3VyIGFwcGxpY2F0aW9uIGZvciBcIiR7am9iLnRpdGxlfVwiIGhhcyBiZWVuIGFjY2VwdGVkIGFuZCBwYXltZW50IG9mICQke2FwcGxpY2F0aW9uLnByb3Bvc2VkQnVkZ2V0IC0gYXBwbGljYXRpb24ucHJvcG9zZWRCdWRnZXQgKiAwLjA1fSBoYXMgYmVlbiBhZGRlZCB0byB5b3VyIHdpdGhkcmF3YWwgYmFsYW5jZSFgLFxuICAgIGFjdGlvblVybDogYC9kYXNoYm9hcmQvd2FsbGV0YCxcbiAgfSlcblxuICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIGZvciBlbXBsb3llclxuICBhd2FpdCBjcmVhdGVOb3RpZmljYXRpb24oe1xuICAgIHVzZXJJZDogZW1wbG95ZXJJZCxcbiAgICB0eXBlOiBcImpvYlwiLFxuICAgIHRpdGxlOiBcIkpvYiBDb21wbGV0ZWRcIixcbiAgICBkZXNjcmlwdGlvbjogYEpvYiBcIiR7am9iLnRpdGxlfVwiIGhhcyBiZWVuIGNvbXBsZXRlZCBhbmQgcGF5bWVudCBoYXMgYmVlbiByZWxlYXNlZCB0byB0aGUgd29ya2VyLmAsXG4gICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9qb2JzYCxcbiAgfSlcblxuICByZXR1cm4gdXBkYXRlZEFwcGxpY2F0aW9uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWplY3RKb2JBcHBsaWNhdGlvbihcbiAgYXBwbGljYXRpb25JZDogc3RyaW5nLFxuICBlbXBsb3llcklkOiBzdHJpbmcsXG4gIHJlYXNvbjogc3RyaW5nLFxuKTogUHJvbWlzZTxKb2JBcHBsaWNhdGlvbj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGNvbnN0IGFwcGxpY2F0aW9uSW5kZXggPSBhcHBsaWNhdGlvbnMuZmluZEluZGV4KChhcHApID0+IGFwcC5pZCA9PT0gYXBwbGljYXRpb25JZClcblxuICBpZiAoYXBwbGljYXRpb25JbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcHBsaWNhdGlvbiBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9uID0gYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdXG5cbiAgLy8gVmVyaWZ5IGVtcGxveWVyIG93bnMgdGhlIGpvYlxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IGpvYiA9IGpvYnMuZmluZCgoaikgPT4gai5pZCA9PT0gYXBwbGljYXRpb24uam9iSWQpXG5cbiAgaWYgKCFqb2IgfHwgam9iLnVzZXJJZCAhPT0gZW1wbG95ZXJJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBkb24ndCBoYXZlIHBlcm1pc3Npb24gdG8gcmVqZWN0IHRoaXMgYXBwbGljYXRpb25cIilcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRBcHBsaWNhdGlvbiA9IHtcbiAgICAuLi5hcHBsaWNhdGlvbixcbiAgICBzdGF0dXM6IFwicmVqZWN0ZWRcIiBhcyBjb25zdCxcbiAgICByZWplY3RlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgcmVqZWN0aW9uUmVhc29uOiByZWFzb24sXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH1cblxuICBhcHBsaWNhdGlvbnNbYXBwbGljYXRpb25JbmRleF0gPSB1cGRhdGVkQXBwbGljYXRpb25cbiAgc2F2ZUFwcGxpY2F0aW9ucyhhcHBsaWNhdGlvbnMpXG5cbiAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBmb3IgYXBwbGljYW50XG4gIGNvbnN0IHsgY3JlYXRlTm90aWZpY2F0aW9uIH0gPSBhd2FpdCBpbXBvcnQoXCIuL25vdGlmaWNhdGlvbnNcIilcbiAgYXdhaXQgY3JlYXRlTm90aWZpY2F0aW9uKHtcbiAgICB1c2VySWQ6IGFwcGxpY2F0aW9uLmFwcGxpY2FudElkLFxuICAgIHR5cGU6IFwiam9iXCIsXG4gICAgdGl0bGU6IFwiQXBwbGljYXRpb24gUmVqZWN0ZWRcIixcbiAgICBkZXNjcmlwdGlvbjogYFlvdXIgYXBwbGljYXRpb24gZm9yIFwiJHtqb2IudGl0bGV9XCIgd2FzIG5vdCBzZWxlY3RlZC4gS2VlcCBhcHBseWluZyB0byBvdGhlciBvcHBvcnR1bml0aWVzIWAsXG4gICAgYWN0aW9uVXJsOiBgL2Rhc2hib2FyZC9hcHBsaWVkLWpvYnNgLFxuICB9KVxuXG4gIHJldHVybiB1cGRhdGVkQXBwbGljYXRpb25cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJKb2JzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb2JbXT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IHVzZXJKb2JzID0gam9icy5maWx0ZXIoKGpvYikgPT4gam9iLnVzZXJJZCA9PT0gdXNlcklkKVxuXG4gIGNvbnN0IGpvYnNXaXRoQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdXNlckpvYnMubWFwKGFzeW5jIChqb2IpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBhcHBsaWNhdGlvbnMgZm9yIHRoaXMgam9iXG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGF3YWl0IGdldEpvYkFwcGxpY2F0aW9ucyhqb2IuaWQpXG4gICAgICAgIGNvbnN0IGFwcGxpY2F0aW9uc0NvdW50ID0gYXBwbGljYXRpb25zLmxlbmd0aFxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbdjBdIEpvYiAke2pvYi5pZH0gKCR7am9iLnRpdGxlfSk6IEZvdW5kICR7YXBwbGljYXRpb25zQ291bnR9IGFwcGxpY2F0aW9uc2ApXG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBqb2Igd2l0aCBhY3R1YWwgY291bnRzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uam9iLFxuICAgICAgICAgIGFwcGxpY2F0aW9uc0NvdW50LFxuICAgICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHVzZSBhIHNpbXBsZSB2aWV3IGNvdW50IGJhc2VkIG9uIGFwcGxpY2F0aW9uc1xuICAgICAgICAgIC8vIEluIGEgcmVhbCBzeXN0ZW0sIHRoaXMgd291bGQgYmUgdHJhY2tlZCBzZXBhcmF0ZWx5XG4gICAgICAgICAgdmlld3NDb3VudDogTWF0aC5tYXgoam9iLnZpZXdzQ291bnQgfHwgMCwgYXBwbGljYXRpb25zQ291bnQgKiAyKSxcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW3YwXSBFcnJvciBjb3VudGluZyBhcHBsaWNhdGlvbnMgZm9yIGpvYiAke2pvYi5pZH06YCwgZXJyb3IpXG4gICAgICAgIHJldHVybiBqb2JcbiAgICAgIH1cbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiBqb2JzV2l0aENvdW50c1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXBwbHlUb0pvYihkYXRhOiB7XG4gIGpvYklkOiBzdHJpbmdcbiAgYXBwbGljYW50SWQ6IHN0cmluZ1xuICBjb3ZlckxldHRlcjogc3RyaW5nXG4gIHByb3Bvc2VkQnVkZ2V0OiBudW1iZXJcbiAgZXN0aW1hdGVkRHVyYXRpb246IHN0cmluZ1xuICBwb3J0Zm9saW9MaW5rczogc3RyaW5nW11cbn0pOiBQcm9taXNlPEpvYkFwcGxpY2F0aW9uPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCflI0gV09SS0VSIFZBTElEQVRJT046IENoZWNraW5nIGFwcGxpY2F0aW9uIGZvciBqb2I6XCIsIGRhdGEuam9iSWQsIFwiYnkgd29ya2VyOlwiLCBkYXRhLmFwcGxpY2FudElkKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iID0gam9icy5maW5kKChqKSA9PiBqLmlkID09PSBkYXRhLmpvYklkKVxuXG4gIGlmICgham9iKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgaWYgKGpvYi5zdGF0dXMgIT09IFwiYXBwcm92ZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiBpcyBub3QgYXZhaWxhYmxlIGZvciBhcHBsaWNhdGlvbnNcIilcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHVzZXIgYWxyZWFkeSBhcHBsaWVkIHRvIHRoaXMgam9iXG4gIGNvbnN0IGV4aXN0aW5nQXBwbGljYXRpb25zID0gZ2V0U3RvcmVkQXBwbGljYXRpb25zKClcbiAgY29uc3QgZXhpc3RpbmdBcHBsaWNhdGlvbiA9IGV4aXN0aW5nQXBwbGljYXRpb25zLmZpbmQoXG4gICAgKGFwcCkgPT4gYXBwLmpvYklkID09PSBkYXRhLmpvYklkICYmIGFwcC5hcHBsaWNhbnRJZCA9PT0gZGF0YS5hcHBsaWNhbnRJZCxcbiAgKVxuXG4gIGlmIChleGlzdGluZ0FwcGxpY2F0aW9uKSB7XG4gICAgY29uc29sZS5sb2coXCJbdjBdIOKaoO+4jyBXT1JLRVIgVkFMSURBVElPTjogVXNlciBhbHJlYWR5IGFwcGxpZWQgdG8gdGhpcyBqb2IgLSB0cmVhdGluZyBhcyByZXN1Ym1pc3Npb25cIilcblxuICAgIC8vIFVwZGF0ZSBleGlzdGluZyBhcHBsaWNhdGlvbiBpbnN0ZWFkIG9mIGNyZWF0aW5nIG5ldyBvbmVcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiam9iX2FwcGxpY2F0aW9uc1wiKSB8fCBcIltdXCIpXG4gICAgY29uc3QgYXBwbGljYXRpb25JbmRleCA9IGFwcGxpY2F0aW9ucy5maW5kSW5kZXgoKGFwcDogSm9iQXBwbGljYXRpb24pID0+IGFwcC5pZCA9PT0gZXhpc3RpbmdBcHBsaWNhdGlvbi5pZClcblxuICAgIGlmIChhcHBsaWNhdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdID0ge1xuICAgICAgICAuLi5hcHBsaWNhdGlvbnNbYXBwbGljYXRpb25JbmRleF0sXG4gICAgICAgIGNvdmVyTGV0dGVyOiBkYXRhLmNvdmVyTGV0dGVyLFxuICAgICAgICBwcm9wb3NlZEJ1ZGdldDogZGF0YS5wcm9wb3NlZEJ1ZGdldCxcbiAgICAgICAgZXN0aW1hdGVkRHVyYXRpb246IGRhdGEuZXN0aW1hdGVkRHVyYXRpb24sXG4gICAgICAgIHBvcnRmb2xpb0xpbmtzOiBkYXRhLnBvcnRmb2xpb0xpbmtzLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcmVzdWJtaXNzaW9uQ291bnQ6IChhcHBsaWNhdGlvbnNbYXBwbGljYXRpb25JbmRleF0ucmVzdWJtaXNzaW9uQ291bnQgfHwgMCkgKyAxLFxuICAgICAgfVxuXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImpvYl9hcHBsaWNhdGlvbnNcIiwgSlNPTi5zdHJpbmdpZnkoYXBwbGljYXRpb25zKSlcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgV09SS0VSIFZBTElEQVRJT046IEFwcGxpY2F0aW9uIHVwZGF0ZWQgYXMgcmVzdWJtaXNzaW9uXCIpXG4gICAgICByZXR1cm4gYXBwbGljYXRpb25zW2FwcGxpY2F0aW9uSW5kZXhdXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgam9iIGhhcyByZWFjaGVkIHdvcmtlciBsaW1pdFxuICBjb25zdCBhY2NlcHRlZEFwcGxpY2F0aW9ucyA9IGV4aXN0aW5nQXBwbGljYXRpb25zLmZpbHRlcigoYXBwKSA9PiBhcHAuc3RhdHVzID09PSBcImFjY2VwdGVkXCIpXG4gIGNvbnN0IHdvcmtlcnNOZWVkZWQgPSBqb2Iud29ya2Vyc05lZWRlZCB8fCBqb2IubWF4V29ya2VycyB8fCAxXG5cbiAgaWYgKGFjY2VwdGVkQXBwbGljYXRpb25zLmxlbmd0aCA+PSB3b3JrZXJzTmVlZGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGpvYiBoYXMgYWxyZWFkeSByZWFjaGVkIGl0cyB3b3JrZXIgbGltaXQgb2YgJHt3b3JrZXJzTmVlZGVkfSB3b3JrZXJzYClcbiAgfVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDinIUgV09SS0VSIFZBTElEQVRJT046IE5ldyBhcHBsaWNhdGlvbiBhbGxvd2VkXCIpXG4gIGNvbnNvbGUubG9nKFxuICAgIFwiW3YwXSDwn5OKIFdPUktFUiBWQUxJREFUSU9OOiBDdXJyZW50IGFjY2VwdGVkIHdvcmtlcnM6XCIsXG4gICAgYWNjZXB0ZWRBcHBsaWNhdGlvbnMubGVuZ3RoLFxuICAgIFwiLyBOZWVkZWQ6XCIsXG4gICAgd29ya2Vyc05lZWRlZCxcbiAgKVxuXG4gIC8vIEdldCB1c2VyIGRhdGEgZm9yIGFwcGxpY2F0aW9uXG4gIGNvbnN0IHsgZ2V0QWxsVXNlcnMgfSA9IGF3YWl0IGltcG9ydChcIi4vYXV0aFwiKVxuICBjb25zdCB1c2VycyA9IGdldEFsbFVzZXJzKClcbiAgY29uc3QgdXNlciA9IHVzZXJzLmZpbmQoKHUpID0+IHUuaWQgPT09IGRhdGEuYXBwbGljYW50SWQpXG5cbiAgaWYgKCF1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIilcbiAgfVxuXG4gIGNvbnN0IG5ld0FwcGxpY2F0aW9uOiBKb2JBcHBsaWNhdGlvbiA9IHtcbiAgICBpZDogYGFwcF8ke0RhdGUubm93KCl9YCxcbiAgICBqb2JJZDogZGF0YS5qb2JJZCxcbiAgICBhcHBsaWNhbnRJZDogZGF0YS5hcHBsaWNhbnRJZCxcbiAgICBjb3ZlckxldHRlcjogZGF0YS5jb3ZlckxldHRlcixcbiAgICBwcm9wb3NlZEJ1ZGdldDogZGF0YS5wcm9wb3NlZEJ1ZGdldCxcbiAgICBlc3RpbWF0ZWREdXJhdGlvbjogZGF0YS5lc3RpbWF0ZWREdXJhdGlvbixcbiAgICBwb3J0Zm9saW9MaW5rczogZGF0YS5wb3J0Zm9saW9MaW5rcyxcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIGFwcGxpY2FudDoge1xuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBmaXJzdE5hbWU6IHVzZXIuZmlyc3ROYW1lLFxuICAgICAgbGFzdE5hbWU6IHVzZXIubGFzdE5hbWUsXG4gICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgIGF2YXRhcjogdXNlci5hdmF0YXIsXG4gICAgICByYXRpbmc6IHVzZXIucmF0aW5nLFxuICAgICAgdG90YWxSZXZpZXdzOiB1c2VyLnRvdGFsUmV2aWV3cyxcbiAgICAgIHNraWxsczogdXNlci5za2lsbHMsXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGdldFN0b3JlZEFwcGxpY2F0aW9ucygpXG4gIGFwcGxpY2F0aW9ucy5wdXNoKG5ld0FwcGxpY2F0aW9uKVxuICBzYXZlQXBwbGljYXRpb25zKGFwcGxpY2F0aW9ucylcblxuICAvLyBVcGRhdGUgam9iIGFwcGxpY2F0aW9uIGNvdW50XG4gIGNvbnN0IGpvYkluZGV4ID0gam9icy5maW5kSW5kZXgoKGopID0+IGouaWQgPT09IGRhdGEuam9iSWQpXG4gIGlmIChqb2JJbmRleCAhPT0gLTEpIHtcbiAgICBqb2JzW2pvYkluZGV4XS5hcHBsaWNhdGlvbnNDb3VudCA9IChqb2JzW2pvYkluZGV4XS5hcHBsaWNhdGlvbnNDb3VudCB8fCAwKSArIDFcbiAgICBzYXZlSm9icyhqb2JzKVxuICB9XG5cbiAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBmb3Igam9iIHBvc3RlclxuICBjb25zdCB7IGNyZWF0ZU5vdGlmaWNhdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9ub3RpZmljYXRpb25zXCIpXG4gIGF3YWl0IGNyZWF0ZU5vdGlmaWNhdGlvbih7XG4gICAgdXNlcklkOiBqb2IudXNlcklkLFxuICAgIHR5cGU6IFwiam9iXCIsXG4gICAgdGl0bGU6IFwiTmV3IEpvYiBBcHBsaWNhdGlvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBgJHt1c2VyLmZpcnN0TmFtZX0gJHt1c2VyLmxhc3ROYW1lfSBhcHBsaWVkIGZvciB5b3VyIGpvYiBcIiR7am9iLnRpdGxlfVwiYCxcbiAgICBhY3Rpb25Vcmw6IGAvZGFzaGJvYXJkL2pvYnMvJHtqb2IuaWR9L2FwcGxpY2F0aW9uc2AsXG4gIH0pXG5cbiAgcmV0dXJuIG5ld0FwcGxpY2F0aW9uXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVKb2IoZGF0YTogYW55KTogUHJvbWlzZTxKb2I+IHtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSlcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IFN0YXJ0aW5nIGpvYiBjcmVhdGlvbiBwcm9jZXNzXCIpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogV29ya2VycyBuZWVkZWQ6XCIsIGRhdGEud29ya2Vyc05lZWRlZClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBCdWRnZXQgcGVyIHdvcmtlcjpcIiwgZGF0YS5idWRnZXRNaW4sIFwiLVwiLCBkYXRhLmJ1ZGdldE1heClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBTY3JlZW5zaG90IHJlcXVpcmVtZW50czpcIiwgZGF0YS5yZXF1aXJlU2NyZWVuc2hvdHMgfHwgMClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBBcHByb3ZhbCB0eXBlOlwiLCBkYXRhLmFwcHJvdmFsVHlwZSlcbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkrwgSk9CIENSRUFUSU9OOiBNYW51YWwgYXBwcm92YWwgZGF5czpcIiwgZGF0YS5tYW51YWxBcHByb3ZhbERheXMpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogQ291bnRyeSByZXN0cmljdGlvbnMgZW5hYmxlZDpcIiwgZGF0YS5lbmFibGVDb3VudHJ5UmVzdHJpY3Rpb25zKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IFJlc3RyaWN0aW9uIHR5cGU6XCIsIGRhdGEucmVzdHJpY3Rpb25UeXBlKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IEFsbG93ZWQgY291bnRyaWVzOlwiLCBkYXRhLmFsbG93ZWRDb3VudHJpZXMpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5K8IEpPQiBDUkVBVElPTjogUmVzdHJpY3RlZCBjb3VudHJpZXM6XCIsIGRhdGEucmVzdHJpY3RlZENvdW50cmllcylcblxuICBjb25zdCBpc0luc3RhbnRBcHByb3ZhbCA9IGRhdGEuYXBwcm92YWxUeXBlID09PSBcImluc3RhbnRcIlxuXG4gIGNvbnN0IGlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZCA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBzZXR0aW5nID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhZG1pbl9pbnN0YW50X2FwcHJvdmFsX2VuYWJsZWRcIilcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogbG9jYWxTdG9yYWdlIHNldHRpbmcgZm91bmQ6XCIsIHNldHRpbmcpXG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSBzZXR0aW5nID09PSBcInRydWVcIlxuICAgICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBJTlNUQU5ULUFQUFJPVkFMOiBJbnN0YW50IGFwcHJvdmFsIGVuYWJsZWQ6XCIsIGVuYWJsZWQpXG4gICAgICAgIHJldHVybiBlbmFibGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBzZXJ2ZXIgc2lkZSBvciB3aGVuIGxvY2FsU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlLCBkZWZhdWx0IHRvIHRydWUgZm9yIGluc3RhbnQgYXBwcm92YWwgcmVxdWVzdHNcbiAgICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogU2VydmVyIHNpZGUgb3Igbm8gbG9jYWxTdG9yYWdlLCBkZWZhdWx0aW5nIHRvIHRydWUgZm9yIGluc3RhbnQgcmVxdWVzdHNcIilcbiAgICAgICAgcmV0dXJuIGlzSW5zdGFudEFwcHJvdmFsXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogRXJyb3IgY2hlY2tpbmcgc2V0dGluZzpcIiwgZXJyb3IpXG4gICAgICAvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCBhbGxvdyBpbnN0YW50IGFwcHJvdmFsIGlmIHVzZXIgcmVxdWVzdGVkIGl0XG4gICAgICByZXR1cm4gaXNJbnN0YW50QXBwcm92YWxcbiAgICB9XG4gIH1cblxuICBjb25zdCBnZXREZWZhdWx0TWFudWFsQXBwcm92YWxEYXlzID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHREYXlzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhZG1pbl9kZWZhdWx0X21hbnVhbF9hcHByb3ZhbF9kYXlzXCIpXG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF5cyA/IE51bWJlci5wYXJzZUludChkZWZhdWx0RGF5cykgOiAzXG4gICAgICB9XG4gICAgICByZXR1cm4gMyAvLyBEZWZhdWx0IGZhbGxiYWNrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIPCflKcgREVGQVVMVC1EQVlTOiBFcnJvciBnZXR0aW5nIGRlZmF1bHQgZGF5czpcIiwgZXJyb3IpXG4gICAgICByZXR1cm4gM1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNhblVzZUluc3RhbnRBcHByb3ZhbCA9IGlzSW5zdGFudEFwcHJvdmFsICYmIGlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZCgpXG5cbiAgY29uc3QgZXhpc3RpbmdKb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGNvbnN0IG5leHRKb2JOdW1iZXIgPSBleGlzdGluZ0pvYnMubGVuZ3RoICsgMVxuICBjb25zdCBmb3JtYXR0ZWRKb2JJZCA9IFN0cmluZyhuZXh0Sm9iTnVtYmVyKS5wYWRTdGFydCgzLCBcIjBcIilcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SvCBKT0IgQ1JFQVRJT046IEdlbmVyYXRlZCBqb2IgbnVtYmVyOlwiLCBuZXh0Sm9iTnVtYmVyLCBcImZvcm1hdHRlZCBhczpcIiwgZm9ybWF0dGVkSm9iSWQpXG5cbiAgY29uc3Qgam9iU3RhdHVzID0gXCJhcHByb3ZlZFwiIC8vIEFsbCBqb2JzIGFyZSBhcHByb3ZlZCBpbW1lZGlhdGVseSwgaW5zdGFudCBwYXltZW50IGhhcHBlbnMgb24gd29yayBzdWJtaXNzaW9uXG5cbiAgY29uc3QgZmluYWxNYW51YWxBcHByb3ZhbERheXMgPSBkYXRhLm1hbnVhbEFwcHJvdmFsRGF5cyB8fCBnZXREZWZhdWx0TWFudWFsQXBwcm92YWxEYXlzKClcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBJTlNUQU5ULUFQUFJPVkFMOiBVc2VyIHJlcXVlc3RlZCBpbnN0YW50IGFwcHJvdmFsOlwiLCBpc0luc3RhbnRBcHByb3ZhbClcbiAgY29uc29sZS5sb2coXCJbdjBdIPCflKcgSU5TVEFOVC1BUFBST1ZBTDogQ2FuIHVzZSBpbnN0YW50IGFwcHJvdmFsOlwiLCBjYW5Vc2VJbnN0YW50QXBwcm92YWwpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5SnIElOU1RBTlQtQVBQUk9WQUw6IEpvYiBzdGF0dXMgd2lsbCBiZTpcIiwgam9iU3RhdHVzKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+UpyBNQU5VQUwtQVBQUk9WQUw6IEZpbmFsIG1hbnVhbCBhcHByb3ZhbCBkYXlzOlwiLCBmaW5hbE1hbnVhbEFwcHJvdmFsRGF5cylcblxuICBjb25zdCBidWRnZXRQZXJXb3JrZXIgPSBkYXRhLmJ1ZGdldE1heCB8fCBkYXRhLmJ1ZGdldE1pblxuICBjb25zdCBiYXNlSm9iQ29zdCA9IGJ1ZGdldFBlcldvcmtlciAqIGRhdGEud29ya2Vyc05lZWRlZFxuXG4gIC8vIENhbGN1bGF0ZSBzY3JlZW5zaG90IGNvc3RzXG4gIGxldCBzY3JlZW5zaG90Q29zdCA9IDBcbiAgaWYgKGRhdGEucmVxdWlyZVNjcmVlbnNob3RzID4gMCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyB9ID0gYXdhaXQgaW1wb3J0KFwiLi9zY3JlZW5zaG90LXByaWNpbmdcIilcbiAgICAgIGNvbnN0IHNjcmVlbnNob3RDYWxjdWxhdGlvbiA9IGF3YWl0IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyhkYXRhLnJlcXVpcmVTY3JlZW5zaG90cywgYmFzZUpvYkNvc3QpXG4gICAgICBzY3JlZW5zaG90Q29zdCA9IHNjcmVlbnNob3RDYWxjdWxhdGlvbi50b3RhbFNjcmVlbnNob3RDb3N0XG4gICAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+TuCBKT0IgQ1JFQVRJT046IFNjcmVlbnNob3QgY29zdCBjYWxjdWxhdGVkOlwiLCBzY3JlZW5zaG90Q29zdClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlt2MF0g8J+TuCBKT0IgQ1JFQVRJT046IEVycm9yIGNhbGN1bGF0aW5nIHNjcmVlbnNob3QgY29zdHM6XCIsIGVycm9yKVxuICAgICAgLy8gRmFsbGJhY2sgY2FsY3VsYXRpb25cbiAgICAgIHNjcmVlbnNob3RDb3N0ID0gZGF0YS5yZXF1aXJlU2NyZWVuc2hvdHMgKiAwLjA1XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3VidG90YWwgPSBiYXNlSm9iQ29zdCArIHNjcmVlbnNob3RDb3N0XG5cbiAgbGV0IHBsYXRmb3JtRmVlID0gMFxuICBsZXQgcGxhdGZvcm1GZWVSYXRlID0gMC4wNSAvLyBEZWZhdWx0IGZhbGxiYWNrXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwbGF0Zm9ybUZlZVNldHRpbmdzID0gYXdhaXQgZ2V0UGxhdGZvcm1GZWVTZXR0aW5ncygpXG4gICAgaWYgKHBsYXRmb3JtRmVlU2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IGZlZUNhbGN1bGF0aW9uID0gY2FsY3VsYXRlUGxhdGZvcm1GZWUoc3VidG90YWwsIHBsYXRmb3JtRmVlU2V0dGluZ3MpXG4gICAgICBwbGF0Zm9ybUZlZSA9IGZlZUNhbGN1bGF0aW9uLnBsYXRmb3JtRmVlXG4gICAgICBwbGF0Zm9ybUZlZVJhdGUgPSBwbGF0Zm9ybUZlZVNldHRpbmdzLmZlZVBlcmNlbnRhZ2UgLyAxMDBcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIEpPQiBDUkVBVElPTjogVXNpbmcgY29uZmlndXJhYmxlIHBsYXRmb3JtIGZlZTpcIiwgcGxhdGZvcm1GZWVTZXR0aW5ncy5mZWVQZXJjZW50YWdlICsgXCIlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBsYXRmb3JtRmVlID0gc3VidG90YWwgKiBwbGF0Zm9ybUZlZVJhdGVcbiAgICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIEpPQiBDUkVBVElPTjogVXNpbmcgZGVmYXVsdCBwbGF0Zm9ybSBmZWU6IDUlXCIpXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIPCfkrAgSk9CIENSRUFUSU9OOiBFcnJvciBsb2FkaW5nIHBsYXRmb3JtIGZlZSBzZXR0aW5ncywgdXNpbmcgZGVmYXVsdDpcIiwgZXJyb3IpXG4gICAgcGxhdGZvcm1GZWUgPSBzdWJ0b3RhbCAqIHBsYXRmb3JtRmVlUmF0ZVxuICB9XG5cbiAgY29uc3QgdG90YWxXaXRoRmVlcyA9IHN1YnRvdGFsICsgcGxhdGZvcm1GZWVcblxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IEJhc2Ugam9iIGNvc3Q6XCIsIGJhc2VKb2JDb3N0KVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFNjcmVlbnNob3QgY29zdDpcIiwgc2NyZWVuc2hvdENvc3QpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIEpPQiBDUkVBVElPTjogU3VidG90YWw6XCIsIHN1YnRvdGFsKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+SsCBKT0IgQ1JFQVRJT046IFBsYXRmb3JtIGZlZTpcIiwgcGxhdGZvcm1GZWUpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5KwIEpPQiBDUkVBVElPTjogVG90YWwgd2l0aCBmZWVzOlwiLCB0b3RhbFdpdGhGZWVzKVxuXG4gIC8vIENoZWNrIGFuZCBkZWR1Y3QgZnJvbSB1c2VyJ3MgZGVwb3NpdCB3YWxsZXRcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGdldFdhbGxldCwgYWRkV2FsbGV0VHJhbnNhY3Rpb24gfSA9IGF3YWl0IGltcG9ydChcIi4vd2FsbGV0XCIpXG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgZ2V0V2FsbGV0KGRhdGEudXNlcklkKVxuXG4gICAgaWYgKHdhbGxldC5kZXBvc2l0QmFsYW5jZSA8IHRvdGFsV2l0aEZlZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEluc3VmZmljaWVudCBkZXBvc2l0IGJhbGFuY2UuIFJlcXVpcmVkOiAkJHt0b3RhbFdpdGhGZWVzLnRvRml4ZWQoMil9LCBBdmFpbGFibGU6ICQke3dhbGxldC5kZXBvc2l0QmFsYW5jZS50b0ZpeGVkKDIpfWAsXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IHRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBgSm9iIGNyZWF0aW9uIGRlcG9zaXQgZm9yOiAke2RhdGEudGl0bGV9ICgke2RhdGEud29ya2Vyc05lZWRlZH0gd29ya2VycyDDlyAkJHtidWRnZXRQZXJXb3JrZXJ9YFxuICAgIGlmIChzY3JlZW5zaG90Q29zdCA+IDApIHtcbiAgICAgIHRyYW5zYWN0aW9uRGVzY3JpcHRpb24gKz0gYCArICQke3NjcmVlbnNob3RDb3N0LnRvRml4ZWQoMil9IHNjcmVlbnNob3QgZmVlYFxuICAgIH1cbiAgICB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uICs9IGAgKyAkJHtwbGF0Zm9ybUZlZS50b0ZpeGVkKDIpfSBwbGF0Zm9ybSBmZWUpYFxuXG4gICAgLy8gRGVkdWN0IGVzdGltYXRlZCBjb3N0IGZyb20gZGVwb3NpdCBiYWxhbmNlXG4gICAgYXdhaXQgYWRkV2FsbGV0VHJhbnNhY3Rpb24oe1xuICAgICAgdXNlcklkOiBkYXRhLnVzZXJJZCxcbiAgICAgIHR5cGU6IFwicGF5bWVudFwiLFxuICAgICAgYW1vdW50OiAtdG90YWxXaXRoRmVlcyxcbiAgICAgIGRlc2NyaXB0aW9uOiB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgcmVmZXJlbmNlSWQ6IGBqb2JfJHtEYXRlLm5vdygpfWAsXG4gICAgICByZWZlcmVuY2VUeXBlOiBcImpvYl9jcmVhdGlvblwiLFxuICAgICAgYmFsYW5jZVR5cGU6IFwiZGVwb3NpdFwiLFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g4pyFIEpPQiBDUkVBVElPTjogRGVwb3NpdCBkZWR1Y3RlZCBzdWNjZXNzZnVsbHk6XCIsIHRvdGFsV2l0aEZlZXMpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0g4p2MIEpPQiBDUkVBVElPTjogRGVwb3NpdCBkZWR1Y3Rpb24gZmFpbGVkOlwiLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIGpvYiBjcmVhdGlvbiBkZXBvc2l0OiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgfVxuXG4gIGNvbnN0IG5ld0pvYjogSm9iID0ge1xuICAgIGlkOiBgam9iXyR7RGF0ZS5ub3coKX1gLFxuICAgIGpvYk51bWJlcjogbmV4dEpvYk51bWJlciwgLy8gQWRkZWQgc2VxdWVudGlhbCBqb2IgbnVtYmVyXG4gICAgZm9ybWF0dGVkSm9iSWQ6IGZvcm1hdHRlZEpvYklkLCAvLyBBZGRlZCBmb3JtYXR0ZWQgam9iIElEIGZvciBkaXNwbGF5XG4gICAgdXNlcklkOiBkYXRhLnVzZXJJZCxcbiAgICBjYXRlZ29yeUlkOiBkYXRhLmNhdGVnb3J5SWQsXG4gICAgc3ViY2F0ZWdvcnlJZDogZGF0YS5zdWJjYXRlZ29yeUlkLFxuICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uLFxuICAgIHJlcXVpcmVtZW50czogZGF0YS5yZXF1aXJlbWVudHMsXG4gICAgaW5zdHJ1Y3Rpb25zOiBkYXRhLmluc3RydWN0aW9ucyxcbiAgICBidWRnZXRNaW46IGRhdGEuYnVkZ2V0TWluLFxuICAgIGJ1ZGdldE1heDogZGF0YS5idWRnZXRNYXgsXG4gICAgZGVhZGxpbmU6IGRhdGEuZGVhZGxpbmUsXG4gICAgbG9jYXRpb246IGRhdGEubG9jYXRpb24gfHwgXCJSZW1vdGVcIixcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICBzdGF0dXM6IGpvYlN0YXR1cyxcbiAgICBwcmlvcml0eTogXCJub3JtYWxcIixcbiAgICBza2lsbHNSZXF1aXJlZDogW10sXG4gICAgYXBwbGljYXRpb25zQ291bnQ6IDAsXG4gICAgdmlld3NDb3VudDogMCxcbiAgICB3b3JrZXJzTmVlZGVkOiBkYXRhLndvcmtlcnNOZWVkZWQsXG4gICAgbWF4V29ya2VyczogZGF0YS53b3JrZXJzTmVlZGVkLFxuICAgIHRhZ3M6IGRhdGEudGFncyB8fCBbXSxcbiAgICBhdHRhY2htZW50czogZGF0YS5hdHRhY2htZW50cyB8fCBbXSxcbiAgICByZXF1aXJlU2NyZWVuc2hvdHM6IGRhdGEucmVxdWlyZVNjcmVlbnNob3RzIHx8IDAsXG4gICAgc2NyZWVuc2hvdENvc3Q6IChkYXRhLnJlcXVpcmVTY3JlZW5zaG90cyB8fCAwKSAqIDAuMDUsXG4gICAgZXN0aW1hdGVkQXBwcm92YWxEYXlzOiBkYXRhLmVzdGltYXRlZEFwcHJvdmFsRGF5cyB8fCAxLFxuICAgIGFwcHJvdmFsVHlwZTogZGF0YS5hcHByb3ZhbFR5cGUgfHwgXCJtYW51YWxcIixcbiAgICBtYW51YWxBcHByb3ZhbERheXM6IGZpbmFsTWFudWFsQXBwcm92YWxEYXlzLFxuICAgIGlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZDogY2FuVXNlSW5zdGFudEFwcHJvdmFsLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHN1Ym1pdHRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgYXBwcm92ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBBbGwgam9icyBhcmUgYXBwcm92ZWQgaW1tZWRpYXRlbHlcbiAgICBhcHByb3ZlZEJ5OiBcIlN5c3RlbVwiLFxuICAgIGFwcHJvdmFsUmVhc29uOiBcIkpvYiBhcHByb3ZlZCBmb3IgcG9zdGluZ1wiLFxuICAgIGVzdGltYXRlZFRvdGFsQ29zdDogc3VidG90YWwsXG4gICAgZGVwb3NpdERlZHVjdGVkOiB0b3RhbFdpdGhGZWVzLFxuICAgIGVuYWJsZUNvdW50cnlSZXN0cmljdGlvbnM6IGRhdGEuZW5hYmxlQ291bnRyeVJlc3RyaWN0aW9ucyB8fCBmYWxzZSxcbiAgICByZXN0cmljdGlvblR5cGU6IGRhdGEucmVzdHJpY3Rpb25UeXBlIHx8IFwiaW5jbHVkZVwiLFxuICAgIGFsbG93ZWRDb3VudHJpZXM6IGRhdGEuYWxsb3dlZENvdW50cmllcyB8fCBbXSxcbiAgICByZXN0cmljdGVkQ291bnRyaWVzOiBkYXRhLnJlc3RyaWN0ZWRDb3VudHJpZXMgfHwgW10sXG4gICAgY2F0ZWdvcnk6IHtcbiAgICAgIGlkOiBkYXRhLmNhdGVnb3J5SWQsXG4gICAgICBuYW1lOiBcIlVua25vd24gQ2F0ZWdvcnlcIixcbiAgICAgIHNsdWc6IFwidW5rbm93blwiLFxuICAgIH0sXG4gIH1cblxuICBjb25zdCBqb2JzID0gZ2V0U3RvcmVkSm9icygpXG4gIGpvYnMucHVzaChuZXdKb2IpXG4gIHNhdmVKb2JzKGpvYnMpXG5cbiAgcmV0dXJuIG5ld0pvYlxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlSm9iT24oam9iSWQ6IHN0cmluZywgdXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPEpvYj4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKVxuXG4gIGNvbnN0IGpvYnMgPSBnZXRTdG9yZWRKb2JzKClcbiAgY29uc3Qgam9iSW5kZXggPSBqb2JzLmZpbmRJbmRleCgoaikgPT4gai5pZCA9PT0gam9iSWQgJiYgai51c2VySWQgPT09IHVzZXJJZClcbiAgaWYgKGpvYkluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiSm9iIG5vdCBmb3VuZCBvciB1bmF1dGhvcml6ZWRcIilcblxuICBjb25zdCBqb2IgPSBqb2JzW2pvYkluZGV4XVxuICBjb25zdCBvbGRTdGF0dXMgPSBqb2Iuc3RhdHVzXG5cbiAgLy8gT25seSBhbGxvdyB0b2dnbGUgaWYgam9iIHdhcyBwcmV2aW91c2x5IGFwcHJvdmVkL29wZW4gb3Igc3VzcGVuZGVkXG4gIGlmICghW1wic3VzcGVuZGVkXCIsIFwib3BlblwiLCBcImFwcHJvdmVkXCJdLmluY2x1ZGVzKG9sZFN0YXR1cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJKb2IgY2Fubm90IGJlIHR1cm5lZCBvbiBmcm9tIGN1cnJlbnQgc3RhdHVzXCIpXG4gIH1cblxuICBjb25zdCB1cGRhdGVkSm9iID0gYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCBcIm9wZW5cIiwgdXNlcklkKVxuICBqb2JzW2pvYkluZGV4XSA9IHVwZGF0ZWRKb2JcbiAgc2F2ZUpvYnMoam9icylcblxuICByZWNvcmRTdGF0dXNDaGFuZ2Uoam9iSWQsIG9sZFN0YXR1cywgXCJvcGVuXCIsIHVzZXJJZCwgXCJKb2IgdHVybmVkIG9uIGJ5IG93bmVyXCIsIHtcbiAgICB1c2VyQWN0aW9uOiBcInRvZ2dsZV9vblwiLFxuICAgIGluc3RhbnRUb2dnbGU6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZUpvYk9mZihqb2JJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8Sm9iPiB7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqKSA9PiBqLmlkID09PSBqb2JJZCAmJiBqLnVzZXJJZCA9PT0gdXNlcklkKVxuICBpZiAoam9iSW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJKb2Igbm90IGZvdW5kIG9yIHVuYXV0aG9yaXplZFwiKVxuXG4gIGNvbnN0IGpvYiA9IGpvYnNbam9iSW5kZXhdXG4gIGNvbnN0IG9sZFN0YXR1cyA9IGpvYi5zdGF0dXNcblxuICAvLyBPbmx5IGFsbG93IHRvZ2dsZSBpZiBqb2IgaXMgY3VycmVudGx5IG9wZW4vYXBwcm92ZWRcbiAgaWYgKCFbXCJvcGVuXCIsIFwiYXBwcm92ZWRcIl0uaW5jbHVkZXMob2xkU3RhdHVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkpvYiBjYW5ub3QgYmUgdHVybmVkIG9mZiBmcm9tIGN1cnJlbnQgc3RhdHVzXCIpXG4gIH1cblxuICBjb25zdCB1cGRhdGVkSm9iID0gYXdhaXQgdXBkYXRlSm9iU3RhdHVzKGpvYklkLCBcInN1c3BlbmRlZFwiLCB1c2VySWQpXG4gIGpvYnNbam9iSW5kZXhdID0gdXBkYXRlZEpvYlxuICBzYXZlSm9icyhqb2JzKVxuXG4gIHJlY29yZFN0YXR1c0NoYW5nZShqb2JJZCwgb2xkU3RhdHVzLCBcInN1c3BlbmRlZFwiLCB1c2VySWQsIFwiSm9iIHR1cm5lZCBvZmYgYnkgb3duZXJcIiwge1xuICAgIHVzZXJBY3Rpb246IFwidG9nZ2xlX29mZlwiLFxuICAgIGluc3RhbnRUb2dnbGU6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIHVwZGF0ZWRKb2Jcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUpvYldvcmtlcnMoXG4gIGpvYklkOiBzdHJpbmcsXG4gIG5ld1dvcmtlckNvdW50OiBudW1iZXIsXG4gIHVzZXJJZDogc3RyaW5nLFxuKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZzsgYWRkaXRpb25hbENvc3Q/OiBudW1iZXIgfT4ge1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKVxuXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBTdGFydGluZyB3b3JrZXIgY291bnQgdXBkYXRlIGZvciBqb2I6XCIsIGpvYklkKVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogTmV3IHdvcmtlciBjb3VudDpcIiwgbmV3V29ya2VyQ291bnQpXG5cbiAgY29uc3Qgam9icyA9IGdldFN0b3JlZEpvYnMoKVxuICBjb25zdCBqb2JJbmRleCA9IGpvYnMuZmluZEluZGV4KChqb2IpID0+IGpvYi5pZCA9PT0gam9iSWQgJiYgam9iLnVzZXJJZCA9PT0gdXNlcklkKVxuXG4gIGlmIChqb2JJbmRleCA9PT0gLTEpIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g4p2MIFVQREFURS1XT1JLRVJTOiBKb2Igbm90IGZvdW5kIG9yIHVuYXV0aG9yaXplZFwiKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiBcIkpvYiBub3QgZm91bmQgb3IgeW91IGRvbid0IGhhdmUgcGVybWlzc2lvbiB0byBtb2RpZnkgaXQuXCIgfVxuICB9XG5cbiAgY29uc3Qgam9iID0gam9ic1tqb2JJbmRleF1cbiAgY29uc3QgY3VycmVudFdvcmtlckNvdW50ID0gam9iLndvcmtlcnNOZWVkZWRcbiAgY29uc3Qgd29ya2VyRGlmZmVyZW5jZSA9IG5ld1dvcmtlckNvdW50IC0gY3VycmVudFdvcmtlckNvdW50XG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IEN1cnJlbnQgd29ya2VyczpcIiwgY3VycmVudFdvcmtlckNvdW50KVxuICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogV29ya2VyIGRpZmZlcmVuY2U6XCIsIHdvcmtlckRpZmZlcmVuY2UpXG5cbiAgaWYgKHdvcmtlckRpZmZlcmVuY2UgPT09IDApIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogTm8gY2hhbmdlIGluIHdvcmtlciBjb3VudFwiKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6IFwiV29ya2VyIGNvdW50IHVuY2hhbmdlZC5cIiB9XG4gIH1cblxuICBpZiAod29ya2VyRGlmZmVyZW5jZSA8IDApIHtcbiAgICBjb25zb2xlLmxvZyhcIlt2MF0g8J+RpSBVUERBVEUtV09SS0VSUzogUmVkdWNpbmcgd29ya2VyIGNvdW50IC0gbm8gYWRkaXRpb25hbCBwYXltZW50IG5lZWRlZFwiKVxuICAgIGpvYnNbam9iSW5kZXhdLndvcmtlcnNOZWVkZWQgPSBuZXdXb3JrZXJDb3VudFxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKEpPQlNfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGpvYnMpKVxuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBVcGRhdGVkIGpvYiBzYXZlZCB0byBsb2NhbFN0b3JhZ2Ugd2l0aCBrZXk6XCIsIEpPQlNfU1RPUkFHRV9LRVkpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogYFdvcmtlciBjb3VudCByZWR1Y2VkIHRvICR7bmV3V29ya2VyQ291bnR9LmAgfVxuICB9XG5cbiAgY29uc3QgY29zdFBlcldvcmtlciA9IGpvYi5idWRnZXRNYXggfHwgam9iLmJ1ZGdldE1pbiB8fCAwXG4gIGNvbnN0IGFkZGl0aW9uYWxCYXNlQ29zdCA9IHdvcmtlckRpZmZlcmVuY2UgKiBjb3N0UGVyV29ya2VyXG5cbiAgLy8gQ2FsY3VsYXRlIGFkZGl0aW9uYWwgc2NyZWVuc2hvdCBjb3N0cyBwcm9wb3J0aW9uYWxseVxuICBsZXQgYWRkaXRpb25hbFNjcmVlbnNob3RDb3N0ID0gMFxuICBpZiAoam9iLnJlcXVpcmVTY3JlZW5zaG90cyA+IDApIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBjYWxjdWxhdGVTY3JlZW5zaG90Q29zdHMgfSA9IGF3YWl0IGltcG9ydChcIi4vc2NyZWVuc2hvdC1wcmljaW5nXCIpXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzY3JlZW5zaG90IGNvc3QgZm9yIG5ldyB0b3RhbCB3b3JrZXJzXG4gICAgICBjb25zdCBuZXdUb3RhbEJhc2VDb3N0ID0gbmV3V29ya2VyQ291bnQgKiBjb3N0UGVyV29ya2VyXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBjdXJyZW50IHNjcmVlbnNob3QgY29zdCBmb3IgY29tcGFyaXNvblxuICAgICAgY29uc3QgY3VycmVudFRvdGFsQmFzZUNvc3QgPSBjdXJyZW50V29ya2VyQ291bnQgKiBjb3N0UGVyV29ya2VyXG4gICAgICBjb25zdCBjdXJyZW50U2NyZWVuc2hvdENvc3QgPSAoYXdhaXQgY2FsY3VsYXRlU2NyZWVuc2hvdENvc3RzKGpvYi5yZXF1aXJlU2NyZWVuc2hvdHMsIGN1cnJlbnRUb3RhbEJhc2VDb3N0KSlcbiAgICAgICAgLnRvdGFsU2NyZWVuc2hvdENvc3RcblxuICAgICAgY29uc3QgbmV3U2NyZWVuc2hvdENvc3QgPSAoYXdhaXQgY2FsY3VsYXRlU2NyZWVuc2hvdENvc3RzKGpvYi5yZXF1aXJlU2NyZWVuc2hvdHMsIG5ld1RvdGFsQmFzZUNvc3QpKVxuICAgICAgICAudG90YWxTY3JlZW5zaG90Q29zdFxuXG4gICAgICBhZGRpdGlvbmFsU2NyZWVuc2hvdENvc3QgPSBuZXdTY3JlZW5zaG90Q29zdCAtIGN1cnJlbnRTY3JlZW5zaG90Q29zdFxuICAgICAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IEFkZGl0aW9uYWwgc2NyZWVuc2hvdCBjb3N0OlwiLCBhZGRpdGlvbmFsU2NyZWVuc2hvdENvc3QpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIOKdjCBVUERBVEUtV09SS0VSUzogRXJyb3IgY2FsY3VsYXRpbmcgc2NyZWVuc2hvdCBjb3N0czpcIiwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGxhdGZvcm1GZWVSYXRlID0gMC4wNVxuICBjb25zdCBzdWJ0b3RhbCA9IGFkZGl0aW9uYWxCYXNlQ29zdCArIGFkZGl0aW9uYWxTY3JlZW5zaG90Q29zdFxuICBjb25zdCBwbGF0Zm9ybUZlZSA9IHN1YnRvdGFsICogcGxhdGZvcm1GZWVSYXRlXG4gIGNvbnN0IHRvdGFsQWRkaXRpb25hbENvc3QgPSBzdWJ0b3RhbCArIHBsYXRmb3JtRmVlXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIPCfkaUgVVBEQVRFLVdPUktFUlM6IENvc3QgYnJlYWtkb3duOlwiLCB7XG4gICAgYWRkaXRpb25hbEJhc2VDb3N0LFxuICAgIGFkZGl0aW9uYWxTY3JlZW5zaG90Q29zdCxcbiAgICBwbGF0Zm9ybUZlZSxcbiAgICB0b3RhbEFkZGl0aW9uYWxDb3N0LFxuICB9KVxuXG4gIGNvbnN0IHsgZ2V0V2FsbGV0IH0gPSBhd2FpdCBpbXBvcnQoXCIuL3dhbGxldFwiKVxuICAvLyBDaGVjayB3YWxsZXQgYmFsYW5jZVxuICBjb25zdCB3YWxsZXQgPSBhd2FpdCBnZXRXYWxsZXQodXNlcklkKVxuICBpZiAod2FsbGV0LmRlcG9zaXRCYWxhbmNlIDwgdG90YWxBZGRpdGlvbmFsQ29zdCkge1xuICAgIGNvbnNvbGUubG9nKFwiW3YwXSDinYwgVVBEQVRFLVdPUktFUlM6IEluc3VmZmljaWVudCBiYWxhbmNlXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogYEluc3VmZmljaWVudCBkZXBvc2l0IGJhbGFuY2UuIFJlcXVpcmVkOiAkJHt0b3RhbEFkZGl0aW9uYWxDb3N0LnRvRml4ZWQoMil9LCBBdmFpbGFibGU6ICQke3dhbGxldC5kZXBvc2l0QmFsYW5jZS50b0ZpeGVkKDIpfWAsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyBhZGRXYWxsZXRUcmFuc2FjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KFwiLi93YWxsZXRcIilcblxuICBsZXQgdHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IGBBZGRpdGlvbmFsIHdvcmtlcnMgZm9yIGpvYjogJHtqb2IudGl0bGV9ICgrJHt3b3JrZXJEaWZmZXJlbmNlfSB3b3JrZXJzKWBcbiAgaWYgKGFkZGl0aW9uYWxTY3JlZW5zaG90Q29zdCA+IDApIHtcbiAgICB0cmFuc2FjdGlvbkRlc2NyaXB0aW9uICs9IGAgKyAkJHthZGRpdGlvbmFsU2NyZWVuc2hvdENvc3QudG9GaXhlZCgyKX0gc2NyZWVuc2hvdCBmZWVgXG4gIH1cbiAgdHJhbnNhY3Rpb25EZXNjcmlwdGlvbiArPSBgICsgJCR7cGxhdGZvcm1GZWUudG9GaXhlZCgyKX0gcGxhdGZvcm0gZmVlKWBcblxuICAvLyBEZWR1Y3QgZnJvbSB3YWxsZXRcbiAgYXdhaXQgYWRkV2FsbGV0VHJhbnNhY3Rpb24oe1xuICAgIHVzZXJJZDogdXNlcklkLFxuICAgIHR5cGU6IFwicGF5bWVudFwiLFxuICAgIGFtb3VudDogLXRvdGFsQWRkaXRpb25hbENvc3QsXG4gICAgZGVzY3JpcHRpb246IHRyYW5zYWN0aW9uRGVzY3JpcHRpb24sXG4gICAgcmVmZXJlbmNlSWQ6IGpvYklkLFxuICAgIHJlZmVyZW5jZVR5cGU6IFwid29ya2VyX3VwZGF0ZVwiLFxuICAgIGJhbGFuY2VUeXBlOiBcImRlcG9zaXRcIixcbiAgfSlcblxuICBjb25zdCBuZXdUb3RhbEJhc2VDb3N0ID0gbmV3V29ya2VyQ291bnQgKiBjb3N0UGVyV29ya2VyXG4gIGxldCBuZXdUb3RhbFNjcmVlbnNob3RDb3N0ID0gMFxuXG4gIGlmIChqb2IucmVxdWlyZVNjcmVlbnNob3RzID4gMCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGNhbGN1bGF0ZVNjcmVlbnNob3RDb3N0cyB9ID0gYXdhaXQgaW1wb3J0KFwiLi9zY3JlZW5zaG90LXByaWNpbmdcIilcbiAgICAgIG5ld1RvdGFsU2NyZWVuc2hvdENvc3QgPSAoYXdhaXQgY2FsY3VsYXRlU2NyZWVuc2hvdENvc3RzKGpvYi5yZXF1aXJlU2NyZWVuc2hvdHMsIG5ld1RvdGFsQmFzZUNvc3QpKVxuICAgICAgICAudG90YWxTY3JlZW5zaG90Q29zdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvciByZWNhbGN1bGF0aW5nIHRvdGFsIHNjcmVlbnNob3QgY29zdHM6XCIsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5ld1N1YnRvdGFsID0gbmV3VG90YWxCYXNlQ29zdCArIG5ld1RvdGFsU2NyZWVuc2hvdENvc3RcbiAgY29uc3QgbmV3UGxhdGZvcm1GZWUgPSBuZXdTdWJ0b3RhbCAqIHBsYXRmb3JtRmVlUmF0ZVxuICBjb25zdCBuZXdUb3RhbENvc3QgPSBuZXdTdWJ0b3RhbCArIG5ld1BsYXRmb3JtRmVlXG5cbiAgam9ic1tqb2JJbmRleF0gPSB7XG4gICAgLi4uam9iLFxuICAgIHdvcmtlcnNOZWVkZWQ6IG5ld1dvcmtlckNvdW50LFxuICAgIGVzdGltYXRlZFRvdGFsQ29zdDogbmV3VG90YWxDb3N0LFxuICB9XG5cbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oSk9CU19TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoam9icykpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBVcGRhdGVkIGpvYiBzYXZlZCB0byBsb2NhbFN0b3JhZ2Ugd2l0aCBrZXk6XCIsIEpPQlNfU1RPUkFHRV9LRVkpXG5cbiAgY29uc29sZS5sb2coXCJbdjBdIOKchSBVUERBVEUtV09SS0VSUzogV29ya2VyIGNvdW50IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5XCIpXG4gIGNvbnNvbGUubG9nKFwiW3YwXSDwn5GlIFVQREFURS1XT1JLRVJTOiBOZXcgdG90YWwgY29zdDpcIiwgbmV3VG90YWxDb3N0LnRvRml4ZWQoMikpXG5cbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiB0cnVlLFxuICAgIG1lc3NhZ2U6IGBXb3JrZXIgY291bnQgdXBkYXRlZCB0byAke25ld1dvcmtlckNvdW50fS4gQWRkaXRpb25hbCBjb3N0OiAkJHt0b3RhbEFkZGl0aW9uYWxDb3N0LnRvRml4ZWQoMil9YCxcbiAgICBhZGRpdGlvbmFsQ29zdDogdG90YWxBZGRpdGlvbmFsQ29zdCxcbiAgfVxufVxuXG5leHBvcnQgeyBnZXRTdG9yZWRKb2JzIH1cbiJdLCJuYW1lcyI6WyJKT0JTX1NUT1JBR0VfS0VZIiwiQVBQTElDQVRJT05TX1NUT1JBR0VfS0VZIiwiV09SS19QUk9PRlNfU1RPUkFHRV9LRVkiLCJKT0JfUkVWSUVXU19TVE9SQUdFX0tFWSIsIkpPQl9TVEFUVVNfSElTVE9SWV9TVE9SQUdFX0tFWSIsImdldFN0b3JlZEpvYnMiLCJzdG9yZWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiam9icyIsIkpTT04iLCJwYXJzZSIsInNhdmVKb2JzIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsImdldFN0b3JlZEFwcGxpY2F0aW9ucyIsInNhdmVBcHBsaWNhdGlvbnMiLCJhcHBsaWNhdGlvbnMiLCJnZXRTdG9yZWRXb3JrUHJvb2ZzIiwic2F2ZVdvcmtQcm9vZnMiLCJ3b3JrUHJvb2ZzIiwiZ2V0U3RvcmVkSm9iUmV2aWV3cyIsInNhdmVKb2JSZXZpZXdzIiwicmV2aWV3cyIsImdldFN0b3JlZEpvYlN0YXR1c0hpc3RvcnkiLCJzYXZlSm9iU3RhdHVzSGlzdG9yeSIsImhpc3RvcnkiLCJyZWNvcmRTdGF0dXNDaGFuZ2UiLCJqb2JJZCIsIm9sZFN0YXR1cyIsIm5ld1N0YXR1cyIsInVzZXJJZCIsIm5vdGVzIiwibWV0YWRhdGEiLCJzdGF0dXNFbnRyeSIsImlkIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImNyZWF0ZWRBdCIsInRvSVNPU3RyaW5nIiwicHVzaCIsImxvZyIsImdldFN1YmNhdGVnb3J5QnlJZCIsImdldENhdGVnb3J5QnlJZCIsImdldFBsYXRmb3JtRmVlU2V0dGluZ3MiLCJjYWxjdWxhdGVQbGF0Zm9ybUZlZSIsImxvY2FsUmVzZXJ2YXRpb25TdG9yYWdlIiwicG9wdWxhdGVKb2JDYXRlZ29yeURhdGEiLCJqb2IiLCJ0aXRsZSIsImNhdGVnb3J5SWQiLCJzdWJjYXRlZ29yeUlkIiwicG9wdWxhdGVkSm9iIiwiY2F0ZWdvcnkiLCJ0aHVtYm5haWwiLCJmdWxsQ2F0ZWdvcnkiLCJuYW1lIiwic2x1ZyIsImNhdGVnb3J5VGh1bWJuYWlsIiwic3ViY2F0ZWdvcnkiLCJzdWJjYXRlZ29yeVRodW1ibmFpbCIsImdldEpvYnMiLCJmaWx0ZXJzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZmlsdGVyZWRKb2JzIiwiZmlsdGVyIiwic3RhdHVzIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImRlc2NyaXB0aW9uIiwic2tpbGxzUmVxdWlyZWQiLCJzb21lIiwic2tpbGwiLCJyZW1vdGUiLCJ1bmRlZmluZWQiLCJpc1JlbW90ZSIsImJ1ZGdldCIsImJ1ZGdldE1heCIsIm1pbiIsImJ1ZGdldE1pbiIsIm1heCIsImxvY2F0aW9uIiwic29ydGVkSm9icyIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJwb3B1bGF0ZWRKb2JzIiwiYWxsIiwibWFwIiwiZ2V0Sm9iQnlJZCIsImZpbmQiLCJ2aWV3c0NvdW50Iiwiam9iSW5kZXgiLCJmaW5kSW5kZXgiLCJqIiwiZ2V0QWxsVXNlcnMiLCJ1c2VycyIsInBvc3RlclVzZXIiLCJ1IiwicG9zdGVyIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJ1c2VybmFtZSIsImF2YXRhciIsInJhdGluZyIsInRvdGFsUmV2aWV3cyIsImdldEpvYkFwcGxpY2F0aW9ucyIsImFwcCIsInN1Ym1pdEpvYkFwcGxpY2F0aW9uIiwiZGF0YSIsIkVycm9yIiwiY292ZXJMZXR0ZXIiLCJ0cmltIiwicHJvcG9zZWRCdWRnZXQiLCJleGlzdGluZ0FwcGxpY2F0aW9ucyIsImhhc0FwcGxpZWQiLCJhcHBsaWNhbnRJZCIsInVzZXIiLCJuZXdBcHBsaWNhdGlvbiIsImVzdGltYXRlZER1cmF0aW9uIiwicG9ydGZvbGlvTGlua3MiLCJhcHBsaWNhbnQiLCJza2lsbHMiLCJhcHBsaWNhdGlvbnNDb3VudCIsImNyZWF0ZU5vdGlmaWNhdGlvbiIsInR5cGUiLCJhY3Rpb25VcmwiLCJzdWJtaXRKb2JGb3JBcHByb3ZhbCIsImpvYkRhdGEiLCJjaGVja0F1dG9Kb2JBcHByb3ZhbCIsImF1dG9BcHByb3ZhbFNldHRpbmciLCJzZXR0aW5nIiwic2hvdWxkQXV0b0FwcHJvdmUiLCJqb2JTdGF0dXMiLCJuZXdKb2IiLCJyZXF1aXJlbWVudHMiLCJpbnN0cnVjdGlvbnMiLCJkZWFkbGluZSIsInNwbGl0IiwicHJpb3JpdHkiLCJ3b3JrZXJzTmVlZGVkIiwiZHVyYXRpb24iLCJkdXJhdGlvblR5cGUiLCJ0YWdzIiwiYXR0YWNobWVudHMiLCJyZXF1aXJlU2NyZWVuc2hvdHMiLCJzY3JlZW5zaG90Q29zdCIsImVzdGltYXRlZEFwcHJvdmFsRGF5cyIsInJlcXVpcmVkUHJvb2YiLCJzdWJtaXR0ZWRBdCIsImFwcHJvdmVkQXQiLCJhcHByb3ZlZEJ5IiwiYXBwcm92YWxSZWFzb24iLCJ1cGRhdGVkQXQiLCJhcHByb3ZlSm9iIiwiYWRtaW5JZCIsInJlYXNvbiIsInVwZGF0ZWRKb2IiLCJ1cGRhdGVKb2JTdGF0dXMiLCJyZXZpZXdJZCIsImRlY2lzaW9uIiwiZmVlZGJhY2siLCJyZWplY3RKb2IiLCJzdXNwZW5kSm9iIiwiZ2V0UGVuZGluZ0pvYnMiLCJnZXRBcHByb3ZlZEpvYnMiLCJnZXRBbGxKb2JzIiwiZ2V0QWxsVXNlckpvYnMiLCJ1cGRhdGVKb2IiLCJ1cGRhdGVzIiwiY2FuY2VsSm9iIiwid3AiLCJzdWJtaXR0ZWRXb3JrQ291bnQiLCJsZW5ndGgiLCJyZW1haW5pbmdTbG90cyIsImpvYkNvc3RQZXJXb3JrZXIiLCJwbGF0Zm9ybUZlZVBlcldvcmtlciIsInRvdGFsQ29zdFBlcldvcmtlciIsInJlZnVuZEFtb3VudCIsImFkZFdhbGxldFRyYW5zYWN0aW9uIiwiYW1vdW50IiwiZm9ybWF0dGVkSm9iSWQiLCJyZWZlcmVuY2VJZCIsInJlZmVyZW5jZVR5cGUiLCJiYWxhbmNlVHlwZSIsIm1lc3NhZ2UiLCJjYW5jZWxsYXRpb25EZXRhaWxzIiwiY2FuY2VsbGVkQXQiLCJjYW5SZXZpZXdTdWJtaXNzaW9ucyIsInVzZXJBY3Rpb24iLCJwYXVzZUpvYiIsInJlYWN0aXZhdGVKb2IiLCJnZXRVc2VyQXBwbGljYXRpb25zIiwidXNlckFwcGxpY2F0aW9ucyIsImFwcGxpZWRBdCIsInN1Ym1pdFdvcmtQcm9vZiIsIndvcmtlcklkIiwid29ya2VyVXNlciIsImFwcHJvdmFsVHlwZSIsImlzSW5zdGFudEFwcHJvdmFsRW5hYmxlZCIsImFwcGxpY2F0aW9uIiwiYXBwbGljYXRpb25JZCIsInBheW1lbnRBbW91bnQiLCJzaG91bGRQcm9jZXNzSW5zdGFudFBheW1lbnQiLCJuZXdQcm9vZiIsImVtcGxveWVySWQiLCJzdWJtaXNzaW9uVGV4dCIsInByb29mRmlsZXMiLCJwcm9vZkxpbmtzIiwic2NyZWVuc2hvdHMiLCJzdWJtaXNzaW9uTnVtYmVyIiwid29ya2VyIiwiZW1wbG95ZXIiLCJwbGF0Zm9ybUZlZVNldHRpbmdzIiwicGxhdGZvcm1GZWVSYXRlIiwicGxhdGZvcm1GZWUiLCJmZWVDYWxjdWxhdGlvbiIsImZlZVBlcmNlbnRhZ2UiLCJyb3VuZCIsIndvcmtlckFtb3VudCIsInBheW1lbnRQcm9jZXNzZWRBdCIsInRvRml4ZWQiLCJwYXltZW50RXJyb3IiLCJtYW51YWxBcHByb3ZhbERheXMiLCJnZXRXb3JrUHJvb2ZzQnlKb2IiLCJwcm9vZiIsImdldFdvcmtQcm9vZnNCeVdvcmtlciIsImdldFdvcmtQcm9vZnMiLCJyZXZpZXdXb3JrUHJvb2YiLCJwcm9vZklkIiwicmV2aWV3RGF0YSIsInByb29mSW5kZXgiLCJyZXZpZXciLCJyZXZpZXdlcklkIiwicmV2aXNpb25Ob3RlcyIsInJldmlld2VkQXQiLCJhcHBJbmRleCIsImdldEpvYkFwcGxpY2F0aW9uQnlJZCIsImNvbXBsZXRlZEF0Iiwic3RhdHVzSGlzdG9yeSIsInRvdGFsV29ya2Vyc0NvbXBsZXRlZCIsImFjY2VwdGVkV29ya2VycyIsIkpPQl9TVEFUVVMiLCJQRU5ESU5HIiwiQVBQUk9WRUQiLCJSRUpFQ1RFRCIsIlNVU1BFTkRFRCIsIk9QRU4iLCJJTl9QUk9HUkVTUyIsIkNPTVBMRVRFRCIsIkNBTkNFTExFRCIsImdldEpvYlN0YXR1c0NvbG9yIiwiZ2V0Sm9iU3RhdHVzTGFiZWwiLCJjYW5BcHBseVRvSm9iIiwiaXNKb2JWaXNpYmxlIiwidXNlclR5cGUiLCJnZXRBdmFpbGFibGVKb2JzIiwiY3VycmVudFVzZXJJZCIsImlzVmFsaWRTdGF0dXMiLCJtYXhXb3JrZXJzIiwiY3VycmVudEFwcGxpY2F0aW9ucyIsInJlc2VydmF0aW9uSW5mbyIsImlzSm9iUmVzZXJ2ZWQiLCJpc1Jlc2VydmVkIiwiZ2V0Sm9ic0ZvckRhc2hib2FyZCIsImdldEpvYlN0YXR1c0hpc3RvcnkiLCJlbnRyeSIsImdldEFsbEpvYlN0YXR1c0hpc3RvcnkiLCJhY2NlcHRKb2JBcHBsaWNhdGlvbiIsImFwcGxpY2F0aW9uSW5kZXgiLCJ1cGRhdGVkQXBwbGljYXRpb24iLCJhY2NlcHRlZEF0IiwiYXNzaWduZWRXb3JrZXJJZCIsImZyb21Vc2VySWQiLCJyZWplY3RKb2JBcHBsaWNhdGlvbiIsInJlamVjdGVkQXQiLCJyZWplY3Rpb25SZWFzb24iLCJnZXRVc2VySm9icyIsInVzZXJKb2JzIiwiam9ic1dpdGhDb3VudHMiLCJhcHBseVRvSm9iIiwiZXhpc3RpbmdBcHBsaWNhdGlvbiIsInJlc3VibWlzc2lvbkNvdW50IiwiYWNjZXB0ZWRBcHBsaWNhdGlvbnMiLCJjcmVhdGVKb2IiLCJlbmFibGVDb3VudHJ5UmVzdHJpY3Rpb25zIiwicmVzdHJpY3Rpb25UeXBlIiwiYWxsb3dlZENvdW50cmllcyIsInJlc3RyaWN0ZWRDb3VudHJpZXMiLCJpc0luc3RhbnRBcHByb3ZhbCIsImVuYWJsZWQiLCJnZXREZWZhdWx0TWFudWFsQXBwcm92YWxEYXlzIiwiZGVmYXVsdERheXMiLCJOdW1iZXIiLCJwYXJzZUludCIsImNhblVzZUluc3RhbnRBcHByb3ZhbCIsImV4aXN0aW5nSm9icyIsIm5leHRKb2JOdW1iZXIiLCJTdHJpbmciLCJwYWRTdGFydCIsImZpbmFsTWFudWFsQXBwcm92YWxEYXlzIiwiYnVkZ2V0UGVyV29ya2VyIiwiYmFzZUpvYkNvc3QiLCJjYWxjdWxhdGVTY3JlZW5zaG90Q29zdHMiLCJzY3JlZW5zaG90Q2FsY3VsYXRpb24iLCJ0b3RhbFNjcmVlbnNob3RDb3N0Iiwic3VidG90YWwiLCJ0b3RhbFdpdGhGZWVzIiwiZ2V0V2FsbGV0Iiwid2FsbGV0IiwiZGVwb3NpdEJhbGFuY2UiLCJ0cmFuc2FjdGlvbkRlc2NyaXB0aW9uIiwiam9iTnVtYmVyIiwiZXN0aW1hdGVkVG90YWxDb3N0IiwiZGVwb3NpdERlZHVjdGVkIiwidG9nZ2xlSm9iT24iLCJpbnN0YW50VG9nZ2xlIiwidG9nZ2xlSm9iT2ZmIiwidXBkYXRlSm9iV29ya2VycyIsIm5ld1dvcmtlckNvdW50Iiwic3VjY2VzcyIsImN1cnJlbnRXb3JrZXJDb3VudCIsIndvcmtlckRpZmZlcmVuY2UiLCJjb3N0UGVyV29ya2VyIiwiYWRkaXRpb25hbEJhc2VDb3N0IiwiYWRkaXRpb25hbFNjcmVlbnNob3RDb3N0IiwibmV3VG90YWxCYXNlQ29zdCIsImN1cnJlbnRUb3RhbEJhc2VDb3N0IiwiY3VycmVudFNjcmVlbnNob3RDb3N0IiwibmV3U2NyZWVuc2hvdENvc3QiLCJ0b3RhbEFkZGl0aW9uYWxDb3N0IiwibmV3VG90YWxTY3JlZW5zaG90Q29zdCIsIm5ld1N1YnRvdGFsIiwibmV3UGxhdGZvcm1GZWUiLCJuZXdUb3RhbENvc3QiLCJhZGRpdGlvbmFsQ29zdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./lib/jobs.ts\n");

/***/ }),

/***/ "(ssr)/./lib/local-reservation-storage.ts":
/*!******************************************!*\
  !*** ./lib/local-reservation-storage.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   localReservationStorage: () => (/* binding */ localReservationStorage)\n/* harmony export */ });\nclass LocalReservationStorage {\n    // Get all reservations from localStorage\n    getReservations() {\n        if (true) return [];\n        try {\n            const stored = localStorage.getItem(this.RESERVATIONS_KEY);\n            return stored ? JSON.parse(stored) : [];\n        } catch (error) {\n            console.error(\"Error loading reservations from localStorage:\", error);\n            return [];\n        }\n    }\n    // Save reservations to localStorage\n    saveReservations(reservations) {\n        if (true) return;\n        try {\n            localStorage.setItem(this.RESERVATIONS_KEY, JSON.stringify(reservations));\n            this.dispatchStorageEvent(this.RESERVATIONS_KEY, reservations);\n        } catch (error) {\n            console.error(\"Error saving reservations to localStorage:\", error);\n        }\n    }\n    // Get reservation settings\n    getSettings() {\n        if (true) {\n            return this.getDefaultSettings();\n        }\n        try {\n            const stored = localStorage.getItem(this.SETTINGS_KEY);\n            return stored ? JSON.parse(stored) : this.getDefaultSettings();\n        } catch (error) {\n            console.error(\"Error loading settings from localStorage:\", error);\n            return this.getDefaultSettings();\n        }\n    }\n    // Save reservation settings\n    saveSettings(settings) {\n        if (true) return;\n        try {\n            localStorage.setItem(this.SETTINGS_KEY, JSON.stringify(settings));\n        } catch (error) {\n            console.error(\"Error saving settings to localStorage:\", error);\n        }\n    }\n    // Get job reservation status (which jobs are reserved)\n    getJobReservations() {\n        if (true) return {};\n        try {\n            const stored = localStorage.getItem(this.JOB_RESERVATIONS_KEY);\n            return stored ? JSON.parse(stored) : {};\n        } catch (error) {\n            console.error(\"Error loading job reservations from localStorage:\", error);\n            return {};\n        }\n    }\n    // Save job reservation status\n    saveJobReservations(jobReservations) {\n        if (true) return;\n        try {\n            localStorage.setItem(this.JOB_RESERVATIONS_KEY, JSON.stringify(jobReservations));\n            this.dispatchStorageEvent(this.JOB_RESERVATIONS_KEY, jobReservations);\n        } catch (error) {\n            console.error(\"Error saving job reservations to localStorage:\", error);\n        }\n    }\n    // Create a new reservation\n    createReservation(jobId, userId, reservationMinutes) {\n        const now = new Date();\n        const expiresAt = new Date(now.getTime() + reservationMinutes * 60 * 1000);\n        const reservation = {\n            id: this.generateId(),\n            jobId,\n            userId,\n            reservedAt: now.toISOString(),\n            expiresAt: expiresAt.toISOString(),\n            status: \"active\",\n            createdAt: now.toISOString(),\n            updatedAt: now.toISOString()\n        };\n        // Add to reservations list\n        const reservations = this.getReservations();\n        reservations.push(reservation);\n        this.saveReservations(reservations);\n        // Update job reservations mapping\n        const jobReservations = this.getJobReservations();\n        jobReservations[jobId] = {\n            userId,\n            expiresAt: expiresAt.toISOString()\n        };\n        this.saveJobReservations(jobReservations);\n        return reservation;\n    }\n    // Cancel a reservation\n    cancelReservation(reservationId) {\n        const reservations = this.getReservations();\n        const reservationIndex = reservations.findIndex((r)=>r.id === reservationId);\n        if (reservationIndex === -1) return false;\n        const reservation = reservations[reservationIndex];\n        reservation.status = \"cancelled\";\n        reservation.updatedAt = new Date().toISOString();\n        this.saveReservations(reservations);\n        // Remove from job reservations\n        const jobReservations = this.getJobReservations();\n        delete jobReservations[reservation.jobId];\n        this.saveJobReservations(jobReservations);\n        return true;\n    }\n    // Check and expire old reservations\n    expireOldReservations() {\n        const now = new Date();\n        const reservations = this.getReservations();\n        const jobReservations = this.getJobReservations();\n        const expiredReservations = [];\n        let hasChanges = false;\n        reservations.forEach((reservation)=>{\n            if (reservation.status === \"active\" && new Date(reservation.expiresAt) < now) {\n                reservation.status = \"expired\";\n                reservation.updatedAt = now.toISOString();\n                expiredReservations.push(reservation);\n                // Remove from job reservations\n                delete jobReservations[reservation.jobId];\n                hasChanges = true;\n            }\n        });\n        if (hasChanges) {\n            this.saveReservations(reservations);\n            this.saveJobReservations(jobReservations);\n        }\n        return expiredReservations;\n    }\n    // Get user's active reservations\n    getUserActiveReservations(userId) {\n        const reservations = this.getReservations();\n        return reservations.filter((r)=>r.userId === userId && r.status === \"active\");\n    }\n    // Check if job is reserved\n    isJobReserved(jobId) {\n        const jobReservations = this.getJobReservations();\n        const reservation = jobReservations[jobId];\n        if (!reservation) {\n            return {\n                isReserved: false\n            };\n        }\n        // Check if expired\n        if (new Date(reservation.expiresAt) < new Date()) {\n            // Clean up expired reservation\n            delete jobReservations[jobId];\n            this.saveJobReservations(jobReservations);\n            return {\n                isReserved: false\n            };\n        }\n        return {\n            isReserved: true,\n            userId: reservation.userId,\n            expiresAt: reservation.expiresAt\n        };\n    }\n    // Get default settings\n    getDefaultSettings() {\n        return {\n            id: \"default\",\n            isEnabled: true,\n            defaultReservationMinutes: 60,\n            maxReservationMinutes: 1440,\n            maxConcurrentReservations: 5,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n        };\n    }\n    // Generate a simple ID\n    generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    // Clear all data (for testing/reset)\n    clearAll() {\n        if (true) return;\n        localStorage.removeItem(this.RESERVATIONS_KEY);\n        localStorage.removeItem(this.SETTINGS_KEY);\n        localStorage.removeItem(this.JOB_RESERVATIONS_KEY);\n    }\n    dispatchStorageEvent(key, data) {\n        if (false) {}\n    }\n    constructor(){\n        this.RESERVATIONS_KEY = \"microjob_reservations\";\n        this.SETTINGS_KEY = \"microjob_reservation_settings\";\n        this.JOB_RESERVATIONS_KEY = \"microjob_job_reservations\";\n    }\n}\n// Export singleton instance\nconst localReservationStorage = new LocalReservationStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDN0I7UUFFQSxPQUFPO1lBQ0xBLFlBQVk7WUFDWjNCLFFBQVFNLFlBQVlOLE1BQU07WUFDMUJJLFdBQVdFLFlBQVlGLFNBQVM7UUFDbEM7SUFDRjtJQUVBLHVCQUF1QjtJQUNmZCxxQkFBK0M7UUFDckQsT0FBTztZQUNMaUIsSUFBSTtZQUNKcUIsV0FBVztZQUNYQywyQkFBMkI7WUFDM0JDLHVCQUF1QjtZQUN2QkMsMkJBQTJCO1lBQzNCbkIsV0FBVyxJQUFJVCxPQUFPTyxXQUFXO1lBQ2pDRyxXQUFXLElBQUlWLE9BQU9PLFdBQVc7UUFDbkM7SUFDRjtJQUVBLHVCQUF1QjtJQUNmRixhQUFxQjtRQUMzQixPQUFPTCxLQUFLRCxHQUFHLEdBQUc4QixRQUFRLENBQUMsTUFBTUMsS0FBS0MsTUFBTSxHQUFHRixRQUFRLENBQUMsSUFBSUcsTUFBTSxDQUFDO0lBQ3JFO0lBRUEscUNBQXFDO0lBQ3JDQyxXQUFpQjtRQUNmLElBQUksSUFBNkIsRUFBRTtRQUVuQzNELGFBQWE0RCxVQUFVLENBQUMsSUFBSSxDQUFDMUQsZ0JBQWdCO1FBQzdDRixhQUFhNEQsVUFBVSxDQUFDLElBQUksQ0FBQzlDLFlBQVk7UUFDekNkLGFBQWE0RCxVQUFVLENBQUMsSUFBSSxDQUFDMUMsb0JBQW9CO0lBQ25EO0lBRVFQLHFCQUFxQmtELEdBQVcsRUFBRUMsSUFBUyxFQUFFO1FBQ25ELElBQUksS0FBNkIsRUFBRSxFQU1sQztJQUNIOzthQW5PaUI1RCxtQkFBbUI7YUFDbkJZLGVBQWU7YUFDZkksdUJBQXVCOztBQWtPMUM7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlELDBCQUEwQixJQUFJdEUsMEJBQXlCIiwic291cmNlcyI6WyIvaG9tZS9wcm9qZWN0L2xpYi9sb2NhbC1yZXNlcnZhdGlvbi1zdG9yYWdlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgTG9jYWxSZXNlcnZhdGlvbiB7XG4gIGlkOiBzdHJpbmdcbiAgam9iSWQ6IHN0cmluZ1xuICB1c2VySWQ6IHN0cmluZ1xuICByZXNlcnZlZEF0OiBzdHJpbmdcbiAgZXhwaXJlc0F0OiBzdHJpbmdcbiAgc3RhdHVzOiBcImFjdGl2ZVwiIHwgXCJleHBpcmVkXCIgfCBcImNvbXBsZXRlZFwiIHwgXCJjYW5jZWxsZWRcIlxuICBjcmVhdGVkQXQ6IHN0cmluZ1xuICB1cGRhdGVkQXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsUmVzZXJ2YXRpb25TZXR0aW5ncyB7XG4gIGlkOiBzdHJpbmdcbiAgaXNFbmFibGVkOiBib29sZWFuXG4gIGRlZmF1bHRSZXNlcnZhdGlvbk1pbnV0ZXM6IG51bWJlclxuICBtYXhSZXNlcnZhdGlvbk1pbnV0ZXM6IG51bWJlclxuICBtYXhDb25jdXJyZW50UmVzZXJ2YXRpb25zOiBudW1iZXJcbiAgY3JlYXRlZEF0OiBzdHJpbmdcbiAgdXBkYXRlZEF0OiBzdHJpbmdcbn1cblxuY2xhc3MgTG9jYWxSZXNlcnZhdGlvblN0b3JhZ2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IFJFU0VSVkFUSU9OU19LRVkgPSBcIm1pY3Jvam9iX3Jlc2VydmF0aW9uc1wiXG4gIHByaXZhdGUgcmVhZG9ubHkgU0VUVElOR1NfS0VZID0gXCJtaWNyb2pvYl9yZXNlcnZhdGlvbl9zZXR0aW5nc1wiXG4gIHByaXZhdGUgcmVhZG9ubHkgSk9CX1JFU0VSVkFUSU9OU19LRVkgPSBcIm1pY3Jvam9iX2pvYl9yZXNlcnZhdGlvbnNcIlxuXG4gIC8vIEdldCBhbGwgcmVzZXJ2YXRpb25zIGZyb20gbG9jYWxTdG9yYWdlXG4gIGdldFJlc2VydmF0aW9ucygpOiBMb2NhbFJlc2VydmF0aW9uW10ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gW11cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdG9yZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlJFU0VSVkFUSU9OU19LRVkpXG4gICAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDogW11cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgcmVzZXJ2YXRpb25zIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIFNhdmUgcmVzZXJ2YXRpb25zIHRvIGxvY2FsU3RvcmFnZVxuICBzYXZlUmVzZXJ2YXRpb25zKHJlc2VydmF0aW9uczogTG9jYWxSZXNlcnZhdGlvbltdKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuUkVTRVJWQVRJT05TX0tFWSwgSlNPTi5zdHJpbmdpZnkocmVzZXJ2YXRpb25zKSlcbiAgICAgIHRoaXMuZGlzcGF0Y2hTdG9yYWdlRXZlbnQodGhpcy5SRVNFUlZBVElPTlNfS0VZLCByZXNlcnZhdGlvbnMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgcmVzZXJ2YXRpb25zIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHJlc2VydmF0aW9uIHNldHRpbmdzXG4gIGdldFNldHRpbmdzKCk6IExvY2FsUmVzZXJ2YXRpb25TZXR0aW5ncyB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTZXR0aW5ncygpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuU0VUVElOR1NfS0VZKVxuICAgICAgcmV0dXJuIHN0b3JlZCA/IEpTT04ucGFyc2Uoc3RvcmVkKSA6IHRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2U6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFNldHRpbmdzKClcbiAgICB9XG4gIH1cblxuICAvLyBTYXZlIHJlc2VydmF0aW9uIHNldHRpbmdzXG4gIHNhdmVTZXR0aW5ncyhzZXR0aW5nczogTG9jYWxSZXNlcnZhdGlvblNldHRpbmdzKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuU0VUVElOR1NfS0VZLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlOlwiLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgam9iIHJlc2VydmF0aW9uIHN0YXR1cyAod2hpY2ggam9icyBhcmUgcmVzZXJ2ZWQpXG4gIGdldEpvYlJlc2VydmF0aW9ucygpOiBSZWNvcmQ8c3RyaW5nLCB7IHVzZXJJZDogc3RyaW5nOyBleHBpcmVzQXQ6IHN0cmluZyB9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMuSk9CX1JFU0VSVkFUSU9OU19LRVkpXG4gICAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDoge31cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGxvYWRpbmcgam9iIHJlc2VydmF0aW9ucyBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgICByZXR1cm4ge31cbiAgICB9XG4gIH1cblxuICAvLyBTYXZlIGpvYiByZXNlcnZhdGlvbiBzdGF0dXNcbiAgc2F2ZUpvYlJlc2VydmF0aW9ucyhqb2JSZXNlcnZhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHsgdXNlcklkOiBzdHJpbmc7IGV4cGlyZXNBdDogc3RyaW5nIH0+KTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuSk9CX1JFU0VSVkFUSU9OU19LRVksIEpTT04uc3RyaW5naWZ5KGpvYlJlc2VydmF0aW9ucykpXG4gICAgICB0aGlzLmRpc3BhdGNoU3RvcmFnZUV2ZW50KHRoaXMuSk9CX1JFU0VSVkFUSU9OU19LRVksIGpvYlJlc2VydmF0aW9ucylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBqb2IgcmVzZXJ2YXRpb25zIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHJlc2VydmF0aW9uXG4gIGNyZWF0ZVJlc2VydmF0aW9uKGpvYklkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nLCByZXNlcnZhdGlvbk1pbnV0ZXM6IG51bWJlcik6IExvY2FsUmVzZXJ2YXRpb24ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgcmVzZXJ2YXRpb25NaW51dGVzICogNjAgKiAxMDAwKVxuXG4gICAgY29uc3QgcmVzZXJ2YXRpb246IExvY2FsUmVzZXJ2YXRpb24gPSB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZUlkKCksXG4gICAgICBqb2JJZCxcbiAgICAgIHVzZXJJZCxcbiAgICAgIHJlc2VydmVkQXQ6IG5vdy50b0lTT1N0cmluZygpLFxuICAgICAgZXhwaXJlc0F0OiBleHBpcmVzQXQudG9JU09TdHJpbmcoKSxcbiAgICAgIHN0YXR1czogXCJhY3RpdmVcIixcbiAgICAgIGNyZWF0ZWRBdDogbm93LnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5vdy50b0lTT1N0cmluZygpLFxuICAgIH1cblxuICAgIC8vIEFkZCB0byByZXNlcnZhdGlvbnMgbGlzdFxuICAgIGNvbnN0IHJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0UmVzZXJ2YXRpb25zKClcbiAgICByZXNlcnZhdGlvbnMucHVzaChyZXNlcnZhdGlvbilcbiAgICB0aGlzLnNhdmVSZXNlcnZhdGlvbnMocmVzZXJ2YXRpb25zKVxuXG4gICAgLy8gVXBkYXRlIGpvYiByZXNlcnZhdGlvbnMgbWFwcGluZ1xuICAgIGNvbnN0IGpvYlJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0Sm9iUmVzZXJ2YXRpb25zKClcbiAgICBqb2JSZXNlcnZhdGlvbnNbam9iSWRdID0ge1xuICAgICAgdXNlcklkLFxuICAgICAgZXhwaXJlc0F0OiBleHBpcmVzQXQudG9JU09TdHJpbmcoKSxcbiAgICB9XG4gICAgdGhpcy5zYXZlSm9iUmVzZXJ2YXRpb25zKGpvYlJlc2VydmF0aW9ucylcblxuICAgIHJldHVybiByZXNlcnZhdGlvblxuICB9XG5cbiAgLy8gQ2FuY2VsIGEgcmVzZXJ2YXRpb25cbiAgY2FuY2VsUmVzZXJ2YXRpb24ocmVzZXJ2YXRpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVzZXJ2YXRpb25zID0gdGhpcy5nZXRSZXNlcnZhdGlvbnMoKVxuICAgIGNvbnN0IHJlc2VydmF0aW9uSW5kZXggPSByZXNlcnZhdGlvbnMuZmluZEluZGV4KChyKSA9PiByLmlkID09PSByZXNlcnZhdGlvbklkKVxuXG4gICAgaWYgKHJlc2VydmF0aW9uSW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2VcblxuICAgIGNvbnN0IHJlc2VydmF0aW9uID0gcmVzZXJ2YXRpb25zW3Jlc2VydmF0aW9uSW5kZXhdXG4gICAgcmVzZXJ2YXRpb24uc3RhdHVzID0gXCJjYW5jZWxsZWRcIlxuICAgIHJlc2VydmF0aW9uLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuXG4gICAgdGhpcy5zYXZlUmVzZXJ2YXRpb25zKHJlc2VydmF0aW9ucylcblxuICAgIC8vIFJlbW92ZSBmcm9tIGpvYiByZXNlcnZhdGlvbnNcbiAgICBjb25zdCBqb2JSZXNlcnZhdGlvbnMgPSB0aGlzLmdldEpvYlJlc2VydmF0aW9ucygpXG4gICAgZGVsZXRlIGpvYlJlc2VydmF0aW9uc1tyZXNlcnZhdGlvbi5qb2JJZF1cbiAgICB0aGlzLnNhdmVKb2JSZXNlcnZhdGlvbnMoam9iUmVzZXJ2YXRpb25zKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIENoZWNrIGFuZCBleHBpcmUgb2xkIHJlc2VydmF0aW9uc1xuICBleHBpcmVPbGRSZXNlcnZhdGlvbnMoKTogTG9jYWxSZXNlcnZhdGlvbltdIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3QgcmVzZXJ2YXRpb25zID0gdGhpcy5nZXRSZXNlcnZhdGlvbnMoKVxuICAgIGNvbnN0IGpvYlJlc2VydmF0aW9ucyA9IHRoaXMuZ2V0Sm9iUmVzZXJ2YXRpb25zKClcbiAgICBjb25zdCBleHBpcmVkUmVzZXJ2YXRpb25zOiBMb2NhbFJlc2VydmF0aW9uW10gPSBbXVxuXG4gICAgbGV0IGhhc0NoYW5nZXMgPSBmYWxzZVxuXG4gICAgcmVzZXJ2YXRpb25zLmZvckVhY2goKHJlc2VydmF0aW9uKSA9PiB7XG4gICAgICBpZiAocmVzZXJ2YXRpb24uc3RhdHVzID09PSBcImFjdGl2ZVwiICYmIG5ldyBEYXRlKHJlc2VydmF0aW9uLmV4cGlyZXNBdCkgPCBub3cpIHtcbiAgICAgICAgcmVzZXJ2YXRpb24uc3RhdHVzID0gXCJleHBpcmVkXCJcbiAgICAgICAgcmVzZXJ2YXRpb24udXBkYXRlZEF0ID0gbm93LnRvSVNPU3RyaW5nKClcbiAgICAgICAgZXhwaXJlZFJlc2VydmF0aW9ucy5wdXNoKHJlc2VydmF0aW9uKVxuXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGpvYiByZXNlcnZhdGlvbnNcbiAgICAgICAgZGVsZXRlIGpvYlJlc2VydmF0aW9uc1tyZXNlcnZhdGlvbi5qb2JJZF1cbiAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKGhhc0NoYW5nZXMpIHtcbiAgICAgIHRoaXMuc2F2ZVJlc2VydmF0aW9ucyhyZXNlcnZhdGlvbnMpXG4gICAgICB0aGlzLnNhdmVKb2JSZXNlcnZhdGlvbnMoam9iUmVzZXJ2YXRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiBleHBpcmVkUmVzZXJ2YXRpb25zXG4gIH1cblxuICAvLyBHZXQgdXNlcidzIGFjdGl2ZSByZXNlcnZhdGlvbnNcbiAgZ2V0VXNlckFjdGl2ZVJlc2VydmF0aW9ucyh1c2VySWQ6IHN0cmluZyk6IExvY2FsUmVzZXJ2YXRpb25bXSB7XG4gICAgY29uc3QgcmVzZXJ2YXRpb25zID0gdGhpcy5nZXRSZXNlcnZhdGlvbnMoKVxuICAgIHJldHVybiByZXNlcnZhdGlvbnMuZmlsdGVyKChyKSA9PiByLnVzZXJJZCA9PT0gdXNlcklkICYmIHIuc3RhdHVzID09PSBcImFjdGl2ZVwiKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgam9iIGlzIHJlc2VydmVkXG4gIGlzSm9iUmVzZXJ2ZWQoam9iSWQ6IHN0cmluZyk6IHsgaXNSZXNlcnZlZDogYm9vbGVhbjsgdXNlcklkPzogc3RyaW5nOyBleHBpcmVzQXQ/OiBzdHJpbmcgfSB7XG4gICAgY29uc3Qgam9iUmVzZXJ2YXRpb25zID0gdGhpcy5nZXRKb2JSZXNlcnZhdGlvbnMoKVxuICAgIGNvbnN0IHJlc2VydmF0aW9uID0gam9iUmVzZXJ2YXRpb25zW2pvYklkXVxuXG4gICAgaWYgKCFyZXNlcnZhdGlvbikge1xuICAgICAgcmV0dXJuIHsgaXNSZXNlcnZlZDogZmFsc2UgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGV4cGlyZWRcbiAgICBpZiAobmV3IERhdGUocmVzZXJ2YXRpb24uZXhwaXJlc0F0KSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgIC8vIENsZWFuIHVwIGV4cGlyZWQgcmVzZXJ2YXRpb25cbiAgICAgIGRlbGV0ZSBqb2JSZXNlcnZhdGlvbnNbam9iSWRdXG4gICAgICB0aGlzLnNhdmVKb2JSZXNlcnZhdGlvbnMoam9iUmVzZXJ2YXRpb25zKVxuICAgICAgcmV0dXJuIHsgaXNSZXNlcnZlZDogZmFsc2UgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpc1Jlc2VydmVkOiB0cnVlLFxuICAgICAgdXNlcklkOiByZXNlcnZhdGlvbi51c2VySWQsXG4gICAgICBleHBpcmVzQXQ6IHJlc2VydmF0aW9uLmV4cGlyZXNBdCxcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgZGVmYXVsdCBzZXR0aW5nc1xuICBwcml2YXRlIGdldERlZmF1bHRTZXR0aW5ncygpOiBMb2NhbFJlc2VydmF0aW9uU2V0dGluZ3Mge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogXCJkZWZhdWx0XCIsXG4gICAgICBpc0VuYWJsZWQ6IHRydWUsXG4gICAgICBkZWZhdWx0UmVzZXJ2YXRpb25NaW51dGVzOiA2MCwgLy8gMSBob3VyIGRlZmF1bHRcbiAgICAgIG1heFJlc2VydmF0aW9uTWludXRlczogMTQ0MCwgLy8gMjQgaG91cnMgbWF4XG4gICAgICBtYXhDb25jdXJyZW50UmVzZXJ2YXRpb25zOiA1LFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhIHNpbXBsZSBJRFxuICBwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKS50b1N0cmluZygzNikgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMilcbiAgfVxuXG4gIC8vIENsZWFyIGFsbCBkYXRhIChmb3IgdGVzdGluZy9yZXNldClcbiAgY2xlYXJBbGwoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVyblxuXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5SRVNFUlZBVElPTlNfS0VZKVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU0VUVElOR1NfS0VZKVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuSk9CX1JFU0VSVkFUSU9OU19LRVkpXG4gIH1cblxuICBwcml2YXRlIGRpc3BhdGNoU3RvcmFnZUV2ZW50KGtleTogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChcInJlc2VydmF0aW9uU3RvcmFnZUNoYW5nZVwiLCB7XG4gICAgICAgICAgZGV0YWlsOiB7IGtleSwgZGF0YSB9LFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGxvY2FsUmVzZXJ2YXRpb25TdG9yYWdlID0gbmV3IExvY2FsUmVzZXJ2YXRpb25TdG9yYWdlKClcbiJdLCJuYW1lcyI6WyJMb2NhbFJlc2VydmF0aW9uU3RvcmFnZSIsImdldFJlc2VydmF0aW9ucyIsInN0b3JlZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJSRVNFUlZBVElPTlNfS0VZIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwic2F2ZVJlc2VydmF0aW9ucyIsInJlc2VydmF0aW9ucyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJkaXNwYXRjaFN0b3JhZ2VFdmVudCIsImdldFNldHRpbmdzIiwiZ2V0RGVmYXVsdFNldHRpbmdzIiwiU0VUVElOR1NfS0VZIiwic2F2ZVNldHRpbmdzIiwic2V0dGluZ3MiLCJnZXRKb2JSZXNlcnZhdGlvbnMiLCJKT0JfUkVTRVJWQVRJT05TX0tFWSIsInNhdmVKb2JSZXNlcnZhdGlvbnMiLCJqb2JSZXNlcnZhdGlvbnMiLCJjcmVhdGVSZXNlcnZhdGlvbiIsImpvYklkIiwidXNlcklkIiwicmVzZXJ2YXRpb25NaW51dGVzIiwibm93IiwiRGF0ZSIsImV4cGlyZXNBdCIsImdldFRpbWUiLCJyZXNlcnZhdGlvbiIsImlkIiwiZ2VuZXJhdGVJZCIsInJlc2VydmVkQXQiLCJ0b0lTT1N0cmluZyIsInN0YXR1cyIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInB1c2giLCJjYW5jZWxSZXNlcnZhdGlvbiIsInJlc2VydmF0aW9uSWQiLCJyZXNlcnZhdGlvbkluZGV4IiwiZmluZEluZGV4IiwiciIsImV4cGlyZU9sZFJlc2VydmF0aW9ucyIsImV4cGlyZWRSZXNlcnZhdGlvbnMiLCJoYXNDaGFuZ2VzIiwiZm9yRWFjaCIsImdldFVzZXJBY3RpdmVSZXNlcnZhdGlvbnMiLCJmaWx0ZXIiLCJpc0pvYlJlc2VydmVkIiwiaXNSZXNlcnZlZCIsImlzRW5hYmxlZCIsImRlZmF1bHRSZXNlcnZhdGlvbk1pbnV0ZXMiLCJtYXhSZXNlcnZhdGlvbk1pbnV0ZXMiLCJtYXhDb25jdXJyZW50UmVzZXJ2YXRpb25zIiwidG9TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyIiwiY2xlYXJBbGwiLCJyZW1vdmVJdGVtIiwia2V5IiwiZGF0YSIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImxvY2FsUmVzZXJ2YXRpb25TdG9yYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./lib/local-reservation-storage.ts\n");

/***/ })

};
;